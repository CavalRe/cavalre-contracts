{
  "solcInput": {
    "language": "Solidity",
    "sources": {
      "/Users/williamcory/cavalre-contracts/playground/contracts/FloatCalculator.s.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.26;\n\nimport {Float, FloatLib} from \"/Users/williamcory/cavalre-contracts/libraries/FloatLib.sol\";\nimport {FloatStrings} from \"/Users/williamcory/cavalre-contracts/libraries/FloatStrings.sol\";\n\ncontract FloatCalculator {\n    using FloatLib for Float;\n    using FloatLib for uint256;\n    using FloatStrings for Float;\n\n    // Helper to convert signed value to Float\n    function _toFloat(int256 a, uint8 decimals) internal pure returns (Float) {\n        if (a >= 0) {\n            return uint256(a).toFloat(decimals);\n        } else {\n            return uint256(-a).toFloat(decimals).minus();\n        }\n    }\n\n    // ==================\n    //     Arithmetic\n    // ==================\n\n    function add(int256 a, int256 b, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        return fa.plus(fb).toString();\n    }\n\n    function subtract(int256 a, int256 b, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        return fa.minus(fb).toString();\n    }\n\n    function multiply(int256 a, int256 b, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        return fa.times(fb).toString();\n    }\n\n    function divide(int256 a, int256 b, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        return fa.divide(fb).toString();\n    }\n\n    function negate(int256 a, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        return fa.minus().toString();\n    }\n\n    // ==================\n    //    Comparisons\n    // ==================\n\n    function isEqual(int256 a, int256 b, uint8 decimals) external pure returns (bool) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        return fa.isEQ(fb);\n    }\n\n    function isGreaterThan(int256 a, int256 b, uint8 decimals) external pure returns (bool) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        return fa.isGT(fb);\n    }\n\n    function isLessThan(int256 a, int256 b, uint8 decimals) external pure returns (bool) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        return fa.isLT(fb);\n    }\n\n    function isGreaterOrEqual(int256 a, int256 b, uint8 decimals) external pure returns (bool) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        return fa.isGEQ(fb);\n    }\n\n    function isLessOrEqual(int256 a, int256 b, uint8 decimals) external pure returns (bool) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        return fa.isLEQ(fb);\n    }\n\n    function isZero(int256 a, uint8 decimals) external pure returns (bool) {\n        Float fa = _toFloat(a, decimals);\n        return fa.isZero();\n    }\n\n    // ==================\n    //  Transformations\n    // ==================\n\n    function absoluteValue(int256 a, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        return fa.abs().toString();\n    }\n\n    function getParts(int256 a, uint8 decimals) external pure returns (string memory intPart, string memory fracPart) {\n        Float fa = _toFloat(a, decimals);\n        (Float intFloat, Float fracFloat) = fa.parts();\n        return (intFloat.toString(), fracFloat.toString());\n    }\n\n    function shift(int256 a, uint8 decimals, int256 places) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        return fa.shift(places).toString();\n    }\n\n    function roundTo(int256 a, uint8 decimals, uint256 digits) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        return fa.round(digits).toString();\n    }\n\n    // ==================\n    //  Special Functions\n    // ==================\n\n    function exponential(int256 a, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        return fa.exp().toString();\n    }\n\n    function naturalLog(int256 a, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        return fa.log().toString();\n    }\n\n    function power(int256 base, int256 exp, uint8 decimals) external pure returns (string memory) {\n        Float fb = _toFloat(base, decimals);\n        Float fe = _toFloat(exp, decimals);\n        return fb.pow(fe).toString();\n    }\n\n    function squareRoot(int256 a, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        return fa.sqrt().toString();\n    }\n\n    function fullMulDiv(int256 a, int256 b, int256 c, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        Float fc = _toFloat(c, decimals);\n        return FloatLib.fullMulDiv(fa, fb, fc).toString();\n    }\n\n    // ==================\n    //     Utilities\n    // ==================\n\n    function toFloatString(int256 value, uint8 decimals) external pure returns (string memory) {\n        return _toFloat(value, decimals).toString();\n    }\n\n    function getComponents(int256 value, uint8 decimals) external pure returns (int256 mantissa, int256 exponent) {\n        Float f = _toFloat(value, decimals);\n        return FloatLib.components(f);\n    }\n\n    function fromComponents(int256 mantissa, int256 exponent) external pure returns (string memory) {\n        return FloatLib.from(mantissa, exponent).toString();\n    }\n\n    function normalize(int256 mantissa, int256 exponent) external pure returns (string memory) {\n        return FloatLib.normalize(mantissa, exponent).toString();\n    }\n\n    // ==================\n    //     Constants\n    // ==================\n\n    function zero() external pure returns (string memory) {\n        return FloatLib.ZERO.toString();\n    }\n\n    function one() external pure returns (string memory) {\n        return FloatLib.ONE.toString();\n    }\n\n    function two() external pure returns (string memory) {\n        return FloatLib.TWO.toString();\n    }\n\n    function ten() external pure returns (string memory) {\n        return FloatLib.TEN.toString();\n    }\n\n    function pi() external pure returns (string memory) {\n        return FloatLib.PI.toString();\n    }\n}\n"
      },
      "/Users/williamcory/cavalre-contracts/libraries/FloatStrings.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.26;\n\nimport {Float, FloatLib} from \"/Users/williamcory/cavalre-contracts/libraries/FloatLib.sol\";\nimport {FixedPointMathLib} from \"/Users/williamcory/cavalre-contracts/node_modules/solady/src/utils/FixedPointMathLib.sol\";\n\nlibrary FloatStrings {\n    using FixedPointMathLib for int256;\n    using FloatLib for Float;\n\n    // Most significant bit\n    function msb(int256 value_) internal pure returns (uint256) {\n        if (value_ == 0) {\n            return 0;\n        }\n\n        return toStringBytes(value_.abs()).length;\n    }\n\n    function shiftStringBytesLeft(bytes memory strBytes_, uint256 numChars_) public pure returns (bytes memory) {\n        bytes memory _result = new bytes(strBytes_.length + numChars_);\n\n        for (uint256 _i = 0; _i < _result.length; _i++) {\n            if (_i < strBytes_.length) {\n                _result[_i] = strBytes_[_i];\n            } else {\n                _result[_i] = \"0\";\n            }\n        }\n\n        return _result;\n    }\n\n    function shiftStringLeft(string memory str_, uint256 numChars_) public pure returns (string memory) {\n        return string(shiftStringBytesLeft(bytes(str_), numChars_));\n    }\n\n    function shiftStringBytesRight(bytes memory strBytes_, uint256 numChars_)\n        public\n        pure\n        returns (bytes memory _result, bytes memory _remainder)\n    {\n        uint256 _resultChars;\n        uint256 _remainderChars;\n        uint256 _excessChars;\n        if (numChars_ > strBytes_.length) {\n            _resultChars = 0;\n            _excessChars = numChars_ - strBytes_.length;\n            _result = new bytes(1);\n        } else {\n            _resultChars = strBytes_.length - numChars_;\n            _result = new bytes(_resultChars);\n        }\n        _remainderChars = numChars_;\n        _remainder = new bytes(_remainderChars);\n\n        for (uint256 _i = 0; _i < strBytes_.length; _i++) {\n            if (_i < _resultChars) {\n                _result[_i] = strBytes_[_i];\n            } else {\n                _remainder[_remainderChars - 1 + _resultChars - _i] =\n                    strBytes_[strBytes_.length - 1 + _resultChars - _i];\n            }\n        }\n\n        return (_result, _remainder);\n    }\n\n    function shiftStringRight(string memory str_, uint256 numChars_)\n        public\n        pure\n        returns (string memory _result, string memory _remainder)\n    {\n        bytes memory _strBytes = bytes(str_);\n        bytes memory _resultBytes;\n        bytes memory _remainderBytes;\n        (_resultBytes, _remainderBytes) = shiftStringBytesRight(_strBytes, numChars_);\n        _result = string(_resultBytes);\n        _remainder = string(_remainderBytes);\n    }\n\n    function toStringBytes(uint256 value_) public pure returns (bytes memory) {\n        // Handle the special case of zero.\n        if (value_ == 0) {\n            return bytes(\"0\");\n        }\n\n        // Determine the length of the decimal number.\n        uint256 _digits = digits(value_);\n\n        // Create a temporary byte array to fill with the digits of the number.\n        bytes memory _buffer = new bytes(_digits);\n        while (value_ != 0) {\n            _digits -= 1;\n            _buffer[_digits] = bytes1(uint8(48 + (value_ % 10)));\n            value_ /= 10;\n        }\n\n        // Convert the byte array to a string and return it.\n        return _buffer;\n    }\n\n    function toStringBytes(Float value_) internal pure returns (bytes memory, bytes memory) {\n        Float _norm = FloatLib.normalize(value_);\n        (Float _intPart, Float _fracPart) = FloatLib.parts(_norm);\n\n        // Integer part\n        bytes memory _integerPartBytes;\n        Float _absInt = FloatLib.abs(_intPart);\n        (int256 _intMantissa, int256 _intExponent) = FloatLib.components(_absInt);\n        if (_intMantissa == 0) {\n            _integerPartBytes = bytes(\"0\");\n        } else {\n            uint256 _intVal = FloatLib.toUInt(_absInt, 0);\n            _integerPartBytes = toStringBytes(_intVal);\n        }\n\n        // Fractional part\n        bytes memory _fractionalPartBytes;\n        Float _absFrac = FloatLib.abs(_fracPart);\n        (int256 _fracMantissa, int256 _fracExponent) = FloatLib.components(_absFrac);\n        if (_fracMantissa == 0) {\n            _fractionalPartBytes = bytes(\"0\");\n        } else {\n            bytes memory _mantBytes =\n                toStringBytes(uint256(int256(_fracMantissa >= 0 ? _fracMantissa : -_fracMantissa)));\n            uint256 _digits = uint256(-_fracExponent); // exponent is negative for fractional part\n            _fractionalPartBytes = new bytes(_digits);\n            for (uint256 _i = 0; _i < _digits; _i++) {\n                if (_i < _mantBytes.length) {\n                    _fractionalPartBytes[_digits - 1 - _i] = _mantBytes[_mantBytes.length - 1 - _i];\n                } else {\n                    _fractionalPartBytes[_digits - 1 - _i] = bytes1(\"0\");\n                }\n            }\n        }\n\n        return (_integerPartBytes, _fractionalPartBytes);\n    }\n\n    function toString(uint256 value_) public pure returns (string memory) {\n        return string(toStringBytes(value_));\n    }\n\n    function toString(int256 value_) public pure returns (string memory) {\n        return string(abi.encodePacked(value_ < 0 ? \"-\" : \"\", toStringBytes(value_.abs())));\n    }\n\n    function trimStringBytesRight(bytes memory strBytes_) public pure returns (bytes memory) {\n        uint256 _i = strBytes_.length - 1;\n        while (_i > 0 && strBytes_[_i] == \"0\") {\n            _i--;\n        }\n        bytes memory _result = new bytes(_i + 1);\n        for (uint256 _j = 0; _j < _i + 1; _j++) {\n            _result[_j] = strBytes_[_j];\n        }\n        return _result;\n    }\n\n    function trimStringRight(string memory str_) public pure returns (string memory) {\n        return string(trimStringBytesRight(bytes(str_)));\n    }\n\n    function toString(Float number_) internal pure returns (string memory) {\n        bytes memory _integerPartBytes;\n        bytes memory _fractionalPartBytes;\n\n        number_ = FloatLib.normalize(number_);\n\n        Float _max = FloatLib.normalize(int256(FloatLib.NORMALIZED_MANTISSA_MAX), 0);\n\n        int256 _ushift = int256(FloatLib.SIGNIFICANT_DIGITS) - 1;\n        int256 _ishift = _ushift;\n\n        (int256 _mantissa, int256 _exponent) = FloatLib.components(number_);\n        // int256 _mant = int256(_mantissa);\n        // int256 _exp = int256(_exponent);\n        if (FloatLib.abs(number_).isLT(_max) && _exponent >= -_ishift) {\n            (_integerPartBytes, _fractionalPartBytes) = toStringBytes(number_);\n            return string(\n                abi.encodePacked(\n                    _mantissa < 0 ? \"-\" : \"\",\n                    string(_integerPartBytes),\n                    \".\",\n                    string(trimStringBytesRight(_fractionalPartBytes))\n                )\n            );\n        } else {\n            (_integerPartBytes, _fractionalPartBytes) = toStringBytes(FloatLib.normalize(_mantissa, -_ishift));\n            return string(\n                abi.encodePacked(\n                    _mantissa < 0 ? \"-\" : \"\",\n                    string(_integerPartBytes),\n                    \".\",\n                    string(trimStringBytesRight(_fractionalPartBytes)),\n                    \"e\",\n                    toString(_exponent + _ishift)\n                )\n            );\n        }\n    }\n\n    function digits(uint256 number_) public pure returns (uint8) {\n        if (number_ == 0) {\n            return 1; // Zero has 1 significant digit\n        }\n\n        uint8 count = 0;\n        while (number_ != 0) {\n            count++;\n            number_ /= 10; // Remove the least significant digit\n        }\n        return count;\n    }\n}\n"
      },
      "/Users/williamcory/cavalre-contracts/node_modules/solady/src/utils/FixedPointMathLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error ExpOverflow();\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error FactorialOverflow();\n\n    /// @dev The operation failed, due to an overflow.\n    error RPowOverflow();\n\n    /// @dev The mantissa is too big to fit.\n    error MantissaOverflow();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error MulWadFailed();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error SMulWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error DivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error SDivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error MulDivFailed();\n\n    /// @dev The division failed, as the denominator is zero.\n    error DivFailed();\n\n    /// @dev The full precision multiply-divide operation failed, either due\n    /// to the result being larger than 256 bits, or a division by a zero.\n    error FullMulDivFailed();\n\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\n    error LnWadUndefined();\n\n    /// @dev The input outside the acceptable domain.\n    error OutOfDomain();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The scalar of ETH and most ERC20s.\n    uint256 internal constant WAD = 1e18;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if gt(x, div(not(0), y)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function sMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require((x == 0 || z / x == y) && !(x == -1 && y == type(int256).min))`.\n            if iszero(gt(or(iszero(x), eq(sdiv(z, x), y)), lt(not(x), eq(y, shl(255, 1))))) {\n                mstore(0x00, 0xedcd4dd4) // `SMulWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawMulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawSMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if iszero(eq(div(z, y), x)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := add(iszero(iszero(mod(z, WAD))), div(z, WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up, but without overflow checks.\n    function rawMulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function sDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, WAD)\n            // Equivalent to `require(y != 0 && ((x * WAD) / WAD == x))`.\n            if iszero(mul(y, eq(sdiv(z, WAD), x))) {\n                mstore(0x00, 0x5c43740d) // `SDivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawDivWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawSDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up, but without overflow and divide by zero checks.\n    function rawDivWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `x` to the power of `y`.\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\n    /// Note: This function is an approximation.\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Using `ln(x)` means `x` must be greater than 0.\n        return expWad((lnWad(x) * y) / int256(WAD));\n    }\n\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is less than 0.5 we return zero.\n            // This happens when `x <= (log(1e-18) * 1e18) ~ -4.15e19`.\n            if (x <= -41446531673892822313) return r;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // When the result is greater than `(2**255 - 1) / 1e18` we can not represent it as\n                // an int. This happens when `x >= floor(log((2**255 - 1) / 1e18) * 1e18) ≈ 135`.\n                if iszero(slt(x, 135305999368893231589)) {\n                    mstore(0x00, 0xa37bfec9) // `ExpOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            // `x` is now in the range `(-42, 136) * 1e18`. Convert to `(-42, 136) * 2**96`\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5 ** 18;\n\n            // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // `k` is in the range `[-61, 195]`.\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // `p` is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already `2**96` too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range `(0.09, 0.25) * 2**96`.\n\n            // We now need to multiply r by:\n            // - The scale factor `s ≈ 6.031367120`.\n            // - The `2**k` factor from the range reduction.\n            // - The `1e18 / 2**96` factor for base conversion.\n            // We do this all at once, with an intermediate result in `2**213`\n            // basis, so the final right shift is always by a positive amount.\n            r = int256(\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\n            );\n        }\n    }\n\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We want to convert `x` from `10**18` fixed point to `2**96` fixed point.\n            // We do this by multiplying by `2**96 / 10**18`. But since\n            // `ln(x * C) = ln(x) + ln(C)`, we can simply do nothing here\n            // and add `ln(2**96 / 10**18)` at the end.\n\n            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // We place the check here for more optimal stack operations.\n            if iszero(sgt(x, 0)) {\n                mstore(0x00, 0x1615e638) // `LnWadUndefined()`.\n                revert(0x1c, 0x04)\n            }\n            // forgefmt: disable-next-item\n            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            x := shr(159, shl(r, x))\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // `p` is made monic, we will multiply by a scale factor later.\n            // forgefmt: disable-next-item\n            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.\n                sar(96, mul(add(43456485725739037958740375743393,\n                sar(96, mul(add(24828157081833163892658089445524,\n                sar(96, mul(add(3273285459638523848632254066296,\n                    x), x))), x))), x)), 11111509109440967052023855526967)\n            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)\n            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)\n            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n\n            // `q` is monic by convention.\n            let q := add(5573035233440673466300451813936, x)\n            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))\n            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))\n            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))\n            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))\n            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))\n            q := add(909429971244387300277376558375, sar(96, mul(x, q)))\n\n            // `p / q` is in the range `(0, 0.125) * 2**96`.\n\n            // Finalization, we need to:\n            // - Multiply by the scale factor `s = 5.549…`.\n            // - Add `ln(2**96 / 10**18)`.\n            // - Add `k * ln(2)`.\n            // - Multiply by `10**18 / 2**96 = 5**18 >> 78`.\n\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already `2**96` too large.\n            p := sdiv(p, q)\n            // Multiply by the scaling factor: `s * 5**18 * 2**96`, base is now `5**18 * 2**192`.\n            p := mul(1677202110996718588342820967067443963516166, p)\n            // Add `ln(2) * k * 5**18 * 2**192`.\n            // forgefmt: disable-next-item\n            p := add(mul(16597577552685614221487285958193947469193820559219878177908093499208371, sub(159, r)), p)\n            // Add `ln(2**96 / 10**18) * 5**18 * 2**192`.\n            p := add(600920179829731861736702779321621459595472258049074101567377883020018308, p)\n            // Base conversion: mul `2**18 / 2**192`.\n            r := sar(174, p)\n        }\n    }\n\n    /// @dev Returns `W_0(x)`, denominated in `WAD`.\n    /// See: https://en.wikipedia.org/wiki/Lambert_W_function\n    /// a.k.a. Product log function. This is an approximation of the principal branch.\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lambertW0Wad(int256 x) internal pure returns (int256 w) {\n        // forgefmt: disable-next-item\n        unchecked {\n            if ((w = x) <= -367879441171442322) revert OutOfDomain(); // `x` less than `-1/e`.\n            (int256 wad, int256 p) = (int256(WAD), x);\n            uint256 c; // Whether we need to avoid catastrophic cancellation.\n            uint256 i = 4; // Number of iterations.\n            if (w <= 0x1ffffffffffff) {\n                if (-0x4000000000000 <= w) {\n                    i = 1; // Inputs near zero only take one step to converge.\n                } else if (w <= -0x3ffffffffffffff) {\n                    i = 32; // Inputs near `-1/e` take very long to converge.\n                }\n            } else if (uint256(w >> 63) == uint256(0)) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // Inline log2 for more performance, since the range is small.\n                    let v := shr(49, w)\n                    let l := shl(3, lt(0xff, v))\n                    l := add(or(l, byte(and(0x1f, shr(shr(l, v), 0x8421084210842108cc6318c6db6d54be)),\n                        0x0706060506020504060203020504030106050205030304010505030400000000)), 49)\n                    w := sdiv(shl(l, 7), byte(sub(l, 31), 0x0303030303030303040506080c13))\n                    c := gt(l, 60)\n                    i := add(2, add(gt(l, 53), c))\n                }\n            } else {\n                int256 ll = lnWad(w = lnWad(w));\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // `w = ln(x) - ln(ln(x)) + b * ln(ln(x)) / ln(x)`.\n                    w := add(sdiv(mul(ll, 1023715080943847266), w), sub(w, ll))\n                    i := add(3, iszero(shr(68, x)))\n                    c := iszero(shr(143, x))\n                }\n                if (c == uint256(0)) {\n                    do { // If `x` is big, use Newton's so that intermediate values won't overflow.\n                        int256 e = expWad(w);\n                        /// @solidity memory-safe-assembly\n                        assembly {\n                            let t := mul(w, div(e, wad))\n                            w := sub(w, sdiv(sub(t, x), div(add(e, t), wad)))\n                        }\n                        if (p <= w) break;\n                        p = w;\n                    } while (--i != uint256(0));\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        w := sub(w, sgt(w, 2))\n                    }\n                    return w;\n                }\n            }\n            do { // Otherwise, use Halley's for faster convergence.\n                int256 e = expWad(w);\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let t := add(w, wad)\n                    let s := sub(mul(w, e), mul(x, wad))\n                    w := sub(w, sdiv(mul(s, wad), sub(mul(e, t), sdiv(mul(add(t, wad), s), add(t, t)))))\n                }\n                if (p <= w) break;\n                p = w;\n            } while (--i != c);\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sub(w, sgt(w, 2))\n            }\n            // For certain ranges of `x`, we'll use the quadratic-rate recursive formula of\n            // R. Iacono and J.P. Boyd for the last iteration, to avoid catastrophic cancellation.\n            if (c == uint256(0)) return w;\n            int256 t = w | 1;\n            /// @solidity memory-safe-assembly\n            assembly {\n                x := sdiv(mul(x, wad), t)\n            }\n            x = (t * (wad + lnWad(x)));\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sdiv(x, add(wad, t))\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  GENERAL NUMBER UTILITIES                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `a * b == x * y`, with full precision.\n    function fullMulEq(uint256 a, uint256 b, uint256 x, uint256 y)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(mul(a, b), mul(x, y)), eq(mulmod(x, y, not(0)), mulmod(a, b, not(0))))\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/21/muldiv\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // 512-bit multiply `[p1 p0] = x * y`.\n            // Compute the product mod `2**256` and mod `2**256 - 1`\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that `product = p1 * 2**256 + p0`.\n\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`.\n            for {} 1 {} {\n                // If overflows.\n                if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n\n                    /*------------------- 512 by 256 division --------------------*/\n\n                    // Make division exact by subtracting the remainder from `[p1 p0]`.\n                    let r := mulmod(x, y, d) // Compute remainder using mulmod.\n                    let t := and(d, sub(0, d)) // The least significant bit of `d`. `t >= 1`.\n                    // Make sure `z` is less than `2**256`. Also prevents `d == 0`.\n                    // Placing the check here seems to give more optimal stack operations.\n                    if iszero(gt(d, p1)) {\n                        mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    d := div(d, t) // Divide `d` by `t`, which is a power of two.\n                    // Invert `d mod 2**256`\n                    // Now that `d` is an odd number, it has an inverse\n                    // modulo `2**256` such that `d * inv = 1 mod 2**256`.\n                    // Compute the inverse by starting with a seed that is correct\n                    // correct for four bits. That is, `d * inv = 1 mod 2**4`.\n                    let inv := xor(2, mul(3, d))\n                    // Now use Newton-Raphson iteration to improve the precision.\n                    // Thanks to Hensel's lifting lemma, this also works in modular\n                    // arithmetic, doubling the correct bits in each step.\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\n                    z :=\n                        mul(\n                            // Divide [p1 p0] by the factors of two.\n                            // Shift in bits from `p1` into `p0`. For this we need\n                            // to flip `t` such that it is `2**256 / t`.\n                            or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                            mul(sub(2, mul(d, inv)), inv) // inverse mod 2**256\n                        )\n                    break\n                }\n                z := div(z, d)\n                break\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Behavior is undefined if `d` is zero or the final result cannot fit in 256 bits.\n    /// Performs the full 512 bit calculation regardless.\n    function fullMulDivUnchecked(uint256 x, uint256 y, uint256 d)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            let mm := mulmod(x, y, not(0))\n            let p1 := sub(mm, add(z, lt(mm, z)))\n            let t := and(d, sub(0, d))\n            let r := mulmod(x, y, d)\n            d := div(d, t)\n            let inv := xor(2, mul(3, d))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            z :=\n                mul(\n                    or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                    mul(sub(2, mul(d, inv)), inv)\n                )\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Uniswap-v3-core under MIT license:\n    /// https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        z = fullMulDiv(x, y, d);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mulmod(x, y, d) {\n                z := add(z, 1)\n                if iszero(z) {\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / 2 ** n)` with full precision.\n    /// Throws if result overflows a uint256.\n    /// Credit to Philogy under MIT license:\n    /// https://github.com/SorellaLabs/angstrom/blob/main/contracts/src/libraries/X128MathLib.sol\n    function fullMulDivN(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`. We'll call this `z`.\n            for {} 1 {} {\n                if iszero(or(iszero(x), eq(div(z, x), y))) {\n                    let k := and(n, 0xff) // `n`, cleaned.\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n                    //         |      p1     |      z     |\n                    // Before: | p1_0 ¦ p1_1 | z_0  ¦ z_1 |\n                    // Final:  |   0  ¦ p1_0 | p1_1 ¦ z_0 |\n                    // Check that final `z` doesn't overflow by checking that p1_0 = 0.\n                    if iszero(shr(k, p1)) {\n                        z := add(shl(sub(256, k), p1), shr(k, z))\n                        break\n                    }\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                z := shr(and(n, 0xff), z)\n                break\n            }\n        }\n    }\n\n    /// @dev Returns `floor(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(z, d)\n        }\n    }\n\n    /// @dev Returns `ceil(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(z, d))), div(z, d))\n        }\n    }\n\n    /// @dev Returns `x`, the modular multiplicative inverse of `a`, such that `(a * x) % n == 1`.\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256 x) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let g := n\n            let r := mod(a, n)\n            for { let y := 1 } 1 {} {\n                let q := div(g, r)\n                let t := g\n                g := r\n                r := sub(t, mul(r, q))\n                let u := x\n                x := y\n                y := sub(u, mul(y, q))\n                if iszero(r) { break }\n            }\n            x := mul(eq(g, 1), add(x, mul(slt(x, 0), n)))\n        }\n    }\n\n    /// @dev Returns `ceil(x / d)`.\n    /// Reverts if `d` is zero.\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(d) {\n                mstore(0x00, 0x65244e4e) // `DivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`. Alias for `saturatingSub`.\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`.\n    function saturatingSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Returns `min(2 ** 256 - 1, x + y)`.\n    function saturatingAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(sub(0, lt(add(x, y), x)), add(x, y))\n        }\n    }\n\n    /// @dev Returns `min(2 ** 256 - 1, x * y)`.\n    function saturatingMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(sub(or(iszero(x), eq(div(mul(x, y), x), y)), 1), mul(x, y))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, address x, address y) internal pure returns (address z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `x != 0 ? x : y`, without branching.\n    function coalesce(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, mul(y, iszero(x)))\n        }\n    }\n\n    /// @dev Returns `x != bytes32(0) ? x : y`, without branching.\n    function coalesce(bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, mul(y, iszero(x)))\n        }\n    }\n\n    /// @dev Returns `x != address(0) ? x : y`, without branching.\n    function coalesce(address x, address y) internal pure returns (address z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, mul(y, iszero(shl(96, x))))\n        }\n    }\n\n    /// @dev Exponentiate `x` to `y` by squaring, denominated in base `b`.\n    /// Reverts if the computation overflows.\n    function rpow(uint256 x, uint256 y, uint256 b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(b, iszero(y)) // `0 ** 0 = 1`. Otherwise, `0 ** n = 0`.\n            if x {\n                z := xor(b, mul(xor(b, x), and(y, 1))) // `z = isEven(y) ? scale : x`\n                let half := shr(1, b) // Divide `b` by 2.\n                // Divide `y` by 2 every iteration.\n                for { y := shr(1, y) } y { y := shr(1, y) } {\n                    let xx := mul(x, x) // Store x squared.\n                    let xxRound := add(xx, half) // Round to the nearest number.\n                    // Revert if `xx + half` overflowed, or if `x ** 2` overflows.\n                    if or(lt(xxRound, xx), shr(128, x)) {\n                        mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                        revert(0x1c, 0x04)\n                    }\n                    x := div(xxRound, b) // Set `x` to scaled `xxRound`.\n                    // If `y` is odd:\n                    if and(y, 1) {\n                        let zx := mul(z, x) // Compute `z * x`.\n                        let zxRound := add(zx, half) // Round to the nearest number.\n                        // If `z * x` overflowed or `zx + half` overflowed:\n                        if or(xor(div(zx, x), z), lt(zxRound, zx)) {\n                            // Revert if `x` is non-zero.\n                            if x {\n                                mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                                revert(0x1c, 0x04)\n                            }\n                        }\n                        z := div(zxRound, b) // Return properly scaled `zxRound`.\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the square root of `x`, rounded down.\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // Let `y = x / 2**r`. We check `y >= 2**(k + 8)`\n            // but shift right by `k` bits to ensure that if `x >= 256`, then `y >= 256`.\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\n            z := shl(shr(1, r), z)\n\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\n\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\n\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\n\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\n            // Then we can estimate `sqrt(y)` using\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\n\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If `x+1` is a perfect square, the Babylonian method cycles between\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, rounded down.\n    /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:\n    /// https://github.com/pcaversaccio/snekmate/blob/main/src/snekmate/utils/math.vy\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // Makeshift lookup table to nudge the approximate log2 result.\n            z := div(shl(div(r, 3), shl(lt(0xf, shr(r, x)), 0xf)), xor(7, mod(r, 3)))\n            // Newton-Raphson's.\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            // Round down.\n            z := sub(z, lt(div(x, mul(z, z)), z))\n        }\n    }\n\n    /// @dev Returns the square root of `x`, denominated in `WAD`, rounded down.\n    function sqrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 18) return sqrt(x * 10 ** 18);\n            z = (1 + sqrt(x)) * 10 ** 9;\n            z = (fullMulDivUnchecked(x, 10 ** 18, z) + z) >> 1;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sub(z, gt(999999999999999999, sub(mulmod(z, z, x), 1))) // Round down.\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, denominated in `WAD`, rounded down.\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 36) return cbrt(x * 10 ** 36);\n            z = (1 + cbrt(x)) * 10 ** 12;\n            z = (fullMulDivUnchecked(x, 10 ** 36, z * z) + z + z) / 3;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let p := x\n            for {} 1 {} {\n                if iszero(shr(229, p)) {\n                    if iszero(shr(199, p)) {\n                        p := mul(p, 100000000000000000) // 10 ** 17.\n                        break\n                    }\n                    p := mul(p, 100000000) // 10 ** 8.\n                    break\n                }\n                if iszero(shr(249, p)) { p := mul(p, 100) }\n                break\n            }\n            let t := mulmod(mul(z, z), z, p)\n            z := sub(z, gt(lt(t, shr(1, p)), iszero(t))) // Round down.\n        }\n    }\n\n    /// @dev Returns the factorial of `x`.\n    function factorial(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := 1\n            if iszero(lt(x, 58)) {\n                mstore(0x00, 0xaba0f2a2) // `FactorialOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            for {} x { x := sub(x, 1) } { z := mul(z, x) }\n        }\n    }\n\n    /// @dev Returns the log2 of `x`.\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\n    /// Returns 0 if `x` is zero.\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020504060203020504030106050205030304010505030400000000))\n        }\n    }\n\n    /// @dev Returns the log2 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\n        r = log2(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(r, 1), x))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log10(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, 100000000000000000000000000000000000000)) {\n                x := div(x, 100000000000000000000000000000000000000)\n                r := 38\n            }\n            if iszero(lt(x, 100000000000000000000)) {\n                x := div(x, 100000000000000000000)\n                r := add(r, 20)\n            }\n            if iszero(lt(x, 10000000000)) {\n                x := div(x, 10000000000)\n                r := add(r, 10)\n            }\n            if iszero(lt(x, 100000)) {\n                x := div(x, 100000)\n                r := add(r, 5)\n            }\n            r := add(r, add(gt(x, 9), add(gt(x, 99), add(gt(x, 999), gt(x, 9999)))))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log10Up(uint256 x) internal pure returns (uint256 r) {\n        r = log10(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(exp(10, r), x))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(shr(3, r), lt(0xff, shr(r, x)))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log256Up(uint256 x) internal pure returns (uint256 r) {\n        r = log256(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(shl(3, r), 1), x))\n        }\n    }\n\n    /// @dev Returns the scientific notation format `mantissa * 10 ** exponent` of `x`.\n    /// Useful for compressing prices (e.g. using 25 bit mantissa and 7 bit exponent).\n    function sci(uint256 x) internal pure returns (uint256 mantissa, uint256 exponent) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mantissa := x\n            if mantissa {\n                if iszero(mod(mantissa, 1000000000000000000000000000000000)) {\n                    mantissa := div(mantissa, 1000000000000000000000000000000000)\n                    exponent := 33\n                }\n                if iszero(mod(mantissa, 10000000000000000000)) {\n                    mantissa := div(mantissa, 10000000000000000000)\n                    exponent := add(exponent, 19)\n                }\n                if iszero(mod(mantissa, 1000000000000)) {\n                    mantissa := div(mantissa, 1000000000000)\n                    exponent := add(exponent, 12)\n                }\n                if iszero(mod(mantissa, 1000000)) {\n                    mantissa := div(mantissa, 1000000)\n                    exponent := add(exponent, 6)\n                }\n                if iszero(mod(mantissa, 10000)) {\n                    mantissa := div(mantissa, 10000)\n                    exponent := add(exponent, 4)\n                }\n                if iszero(mod(mantissa, 100)) {\n                    mantissa := div(mantissa, 100)\n                    exponent := add(exponent, 2)\n                }\n                if iszero(mod(mantissa, 10)) {\n                    mantissa := div(mantissa, 10)\n                    exponent := add(exponent, 1)\n                }\n            }\n        }\n    }\n\n    /// @dev Convenience function for packing `x` into a smaller number using `sci`.\n    /// The `mantissa` will be in bits [7..255] (the upper 249 bits).\n    /// The `exponent` will be in bits [0..6] (the lower 7 bits).\n    /// Use `SafeCastLib` to safely ensure that the `packed` number is small\n    /// enough to fit in the desired unsigned integer type:\n    /// ```\n    ///     uint32 packed = SafeCastLib.toUint32(FixedPointMathLib.packSci(777 ether));\n    /// ```\n    function packSci(uint256 x) internal pure returns (uint256 packed) {\n        (x, packed) = sci(x); // Reuse for `mantissa` and `exponent`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            if shr(249, x) {\n                mstore(0x00, 0xce30380c) // `MantissaOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            packed := or(shl(7, x), packed)\n        }\n    }\n\n    /// @dev Convenience function for unpacking a packed number from `packSci`.\n    function unpackSci(uint256 packed) internal pure returns (uint256 unpacked) {\n        unchecked {\n            unpacked = (packed >> 7) * 10 ** (packed & 0x7f);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards zero.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = (x & y) + ((x ^ y) >> 1);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards negative infinity.\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @dev Returns the absolute value of `x`.\n    function abs(int256 x) internal pure returns (uint256 z) {\n        unchecked {\n            z = (uint256(x) + uint256(x >> 255)) ^ uint256(x >> 255);\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, gt(x, y)), sub(y, x)), gt(x, y))\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, sgt(x, y)), sub(y, x)), sgt(x, y))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), lt(y, x)))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), slt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), gt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), gt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), lt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), sgt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), slt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns greatest common divisor of `x` and `y`.\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { z := x } y {} {\n                let t := y\n                y := mod(z, y)\n                z := t\n            }\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`,\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(uint256 a, uint256 b, uint256 t, uint256 begin, uint256 end)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        unchecked {\n            if (b >= a) return a + fullMulDiv(b - a, t - begin, end - begin);\n            return a - fullMulDiv(a - b, t - begin, end - begin);\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`.\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(int256 a, int256 b, int256 t, int256 begin, int256 end)\n        internal\n        pure\n        returns (int256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        // forgefmt: disable-next-item\n        unchecked {\n            if (b >= a) return int256(uint256(a) + fullMulDiv(uint256(b - a),\n                uint256(t - begin), uint256(end - begin)));\n            return int256(uint256(a) - fullMulDiv(uint256(a - b),\n                uint256(t - begin), uint256(end - begin)));\n        }\n    }\n\n    /// @dev Returns if `x` is an even number. Some people may need this.\n    function isEven(uint256 x) internal pure returns (bool) {\n        return x & uint256(1) == uint256(0);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   RAW NUMBER OPERATIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(x, y)\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mod(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := smod(x, y)\n        }\n    }\n\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := addmod(x, y, d)\n        }\n    }\n\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mulmod(x, y, d)\n        }\n    }\n}\n"
      },
      "/Users/williamcory/cavalre-contracts/libraries/FloatLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.26;\n\nimport {FixedPointMathLib} from \"/Users/williamcory/cavalre-contracts/node_modules/solady/src/utils/FixedPointMathLib.sol\";\n\ntype Float is int256;\n\nlibrary FloatLib {\n    using FloatLib for Float;\n    using FixedPointMathLib for uint256;\n    using FixedPointMathLib for int256;\n\n    // Errors\n    error NoSolution();\n\n    //===============\n    //   Constants\n    //===============\n    uint256 constant SIGNIFICANT_DIGITS = 21;\n    uint256 constant NORMALIZED_MANTISSA_MAX = 10 ** SIGNIFICANT_DIGITS - 1;\n    uint256 constant NORMALIZED_MANTISSA_MIN = 10 ** (SIGNIFICANT_DIGITS - 1);\n    uint256 constant MANTISSA_BITS = 72;\n    uint256 constant MANTISSA_MASK = (uint256(1) << MANTISSA_BITS) - 1;\n\n    int256 constant ONE_MANTISSA = int256(10 ** (SIGNIFICANT_DIGITS - 1));\n    int256 constant ONE_EXPONENT = -int256(SIGNIFICANT_DIGITS - 1);\n\n    Float constant PI = Float.wrap((int256(-1) << MANTISSA_BITS) | 314159265358979323846);\n\n    int256 constant LOG10_WAD = 2302585092994045684;\n    Float constant LOG10 = Float.wrap((int256(-18) << MANTISSA_BITS) | LOG10_WAD);\n\n    Float constant ZERO = Float.wrap(0);\n    Float constant ONE = Float.wrap((ONE_EXPONENT << MANTISSA_BITS) | ONE_MANTISSA);\n    Float constant TWO = Float.wrap((ONE_EXPONENT << MANTISSA_BITS) | (2 * ONE_MANTISSA));\n    Float constant THREE = Float.wrap((ONE_EXPONENT << MANTISSA_BITS) | (3 * ONE_MANTISSA));\n    Float constant FOUR = Float.wrap((ONE_EXPONENT << MANTISSA_BITS) | (4 * ONE_MANTISSA));\n    Float constant FIVE = Float.wrap((ONE_EXPONENT << MANTISSA_BITS) | (5 * ONE_MANTISSA));\n    Float constant SIX = Float.wrap((ONE_EXPONENT << MANTISSA_BITS) | (6 * ONE_MANTISSA));\n    Float constant SEVEN = Float.wrap((ONE_EXPONENT << MANTISSA_BITS) | (7 * ONE_MANTISSA));\n    Float constant EIGHT = Float.wrap((ONE_EXPONENT << MANTISSA_BITS) | (8 * ONE_MANTISSA));\n    Float constant NINE = Float.wrap((ONE_EXPONENT << MANTISSA_BITS) | (9 * ONE_MANTISSA));\n    Float constant TEN = Float.wrap(((ONE_EXPONENT + 1) << MANTISSA_BITS) | ONE_MANTISSA);\n    Float constant HALF = Float.wrap(((ONE_EXPONENT - 1) << MANTISSA_BITS) | (5 * ONE_MANTISSA));\n    //=================\n    //   Conversions\n    //=================\n\n    //-----------\n    //   toInt\n    //-----------\n    // Needed for exponential function\n    function toInt(Float a_, uint8 decimals_) internal pure returns (int256) {\n        (int256 _m, int256 _e) = components(a_);\n        _e += int256(uint256(decimals_));\n        if (_e >= 0) {\n            return _m * int256(10 ** uint256(_e));\n        } else {\n            return _m / int256(10 ** uint256(-_e));\n        }\n    }\n\n    function toInt(Float a_) internal pure returns (int256) {\n        return toInt(a_, 18);\n    }\n\n    //------------\n    //   toUInt\n    //------------\n    function toUInt(Float a_, uint8 decimals_) internal pure returns (uint256) {\n        (int256 _m, int256 _e) = components(a_);\n        require(_m >= 0, \"Value must be non-negative\");\n        _e += int256(uint256(decimals_));\n        if (_e >= 0) {\n            return uint256(_m) * 10 ** uint256(_e);\n        } else {\n            return uint256(_m) / 10 ** uint256(-_e);\n        }\n    }\n\n    function toUInt(Float a_) internal pure returns (uint256) {\n        return toUInt(a_, 18);\n    }\n\n    //--------------\n    //   toFloat\n    //--------------\n    function toFloat(uint256 a_, uint8 decimals_) internal pure returns (Float) {\n        return normalize(int256(a_), -int256(uint256(decimals_)));\n    }\n\n    function toFloat(uint256 a_) internal pure returns (Float) {\n        return toFloat(a_, 18);\n    }\n\n    //-------------------\n    //   toFloatArray\n    //-------------------\n\n    // function toFloatArray(int256[] memory a_, uint8[] memory decimals_) internal pure returns (Float[] memory) {\n    //     Float[] memory _result = new Float[](a_.length);\n    //     for (uint256 _i = 0; _i < a_.length; _i++) {\n    //         _result[_i] = toFloat(a_[_i], decimals_[_i]);\n    //     }\n    //     return _result;\n    // }\n\n    // function toFloatArray(int256[] memory a_) internal pure returns (Float[] memory) {\n    //     Float[] memory _result = new Float[](a_.length);\n    //     for (uint256 _i = 0; _i < a_.length; _i++) {\n    //         _result[_i] = toFloat(a_[_i]);\n    //     }\n    //     return _result;\n    // }\n\n    //=================\n    //   Comparisons\n    //=================\n    //----------\n    //   isEQ\n    //----------\n    function isEQ(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) == mantissa(_alignedB);\n    }\n\n    function isGT(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) > mantissa(_alignedB);\n    }\n\n    function isGEQ(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) >= mantissa(_alignedB);\n    }\n\n    function isLT(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) < mantissa(_alignedB);\n    }\n\n    function isLEQ(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) <= mantissa(_alignedB);\n    }\n\n    function isZero(Float a_) internal pure returns (bool) {\n        return mantissa(a_) == 0;\n    }\n\n    //=====================\n    //   Transformations\n    //=====================\n    function abs(Float a_) internal pure returns (Float) {\n        (int256 _m, int256 _e) = components(a_);\n        if (_m >= 0) return a_;\n        return from(-_m, _e);\n    }\n\n    //-----------\n    //   Shift\n    //-----------\n    function shift(Float a_, int256 i_) internal pure returns (Float) {\n        int256 _mantissa = mantissa(a_);\n        if (i_ == 0 || _mantissa == 0) return a_;\n\n        int256 _shift = i_;\n        int256 _m = _mantissa;\n        int256 _e = exponent(a_) + i_;\n\n        if (_shift > 0) {\n            while (_shift >= 16) {\n                _m /= 1e16;\n                _shift -= 16;\n            }\n            if (_shift >= 8) {\n                _m /= 1e8;\n                _shift -= 8;\n            }\n            if (_shift >= 4) {\n                _m /= 1e4;\n                _shift -= 4;\n            }\n            if (_shift >= 2) {\n                _m /= 1e2;\n                _shift -= 2;\n            }\n            if (_shift >= 1) {\n                _m /= 10;\n                _shift -= 1;\n            }\n        } else {\n            _shift = -_shift;\n            require(_shift <= int256(SIGNIFICANT_DIGITS), \"shift: |i| too large\");\n            while (_shift >= 16) {\n                _m *= 1e16;\n                _shift -= 16;\n            }\n            if (_shift >= 8) {\n                _m *= 1e8;\n                _shift -= 8;\n            }\n            if (_shift >= 4) {\n                _m *= 1e4;\n                _shift -= 4;\n            }\n            if (_shift >= 2) {\n                _m *= 1e2;\n                _shift -= 2;\n            }\n            if (_shift >= 1) {\n                _m *= 10;\n                _shift -= 1;\n            }\n        }\n\n        return from(_m, _e);\n    }\n\n    //---------------\n    //   normalize\n    //---------------\n\n    // function normalize(int256 mantissa_, int256 exponent_) internal pure returns (Float) {\n    //     if (mantissa_ == 0) return ZERO;\n\n    //     int256 _mag = mantissa_ >= 0 ? mantissa_ : -mantissa_;\n\n    //     if (_mag > NORMALIZED_MANTISSA_MAX) {\n    //         while (_mag > NORMALIZED_MANTISSA_MAX) {\n    //             mantissa_ /= 10;\n    //             exponent_ += 1;\n    //             _mag /= 10;\n    //         }\n    //         return from(mantissa_, exponent_);\n    //     }\n\n    //     if (_mag < NORMALIZED_MANTISSA_MIN) {\n    //         while (_mag < NORMALIZED_MANTISSA_MIN) {\n    //             mantissa_ *= 10;\n    //             exponent_ -= 1;\n    //             _mag *= 10;\n    //         }\n    //         return from(mantissa_, exponent_);\n    //     }\n\n    //     return from(mantissa_, exponent_);\n    // }\n\n    function normalize(int256 mantissa_, int256 exponent_) internal pure returns (Float) {\n        if (mantissa_ == 0) return ZERO;\n\n        uint256 _mag = mantissa_ >= 0 ? uint256(mantissa_) : uint256(-mantissa_);\n\n        while (_mag > NORMALIZED_MANTISSA_MAX) {\n            mantissa_ /= 10;\n            exponent_ += 1;\n            _mag /= 10;\n        }\n\n        while (_mag < NORMALIZED_MANTISSA_MIN) {\n            mantissa_ *= 10;\n            exponent_ -= 1;\n            _mag *= 10;\n        }\n\n        return from(mantissa_, exponent_);\n    }\n\n    function normalize(Float a_) internal pure returns (Float) {\n        (int256 _mantissa, int256 _exponent) = components(a_);\n        return normalize(_mantissa, _exponent);\n    }\n\n    //-----------\n    //   align\n    //-----------\n    function align(Float a_, Float b_) internal pure returns (Float, Float) {\n        (int256 _aMantissa, int256 _aExponent) = components(a_);\n        (int256 _bMantissa, int256 _bExponent) = components(b_);\n        if (_aMantissa == 0 && _bMantissa == 0) {\n            return (ZERO, ZERO);\n        } else if (_aMantissa == 0) {\n            return (from(0, _bExponent), from(_bMantissa, _bExponent));\n        } else if (_bMantissa == 0) {\n            return (from(_aMantissa, _aExponent), from(0, _aExponent));\n        }\n\n        Float _normA = normalize(a_);\n        Float _normB = normalize(b_);\n        _aMantissa = mantissa(_normA);\n        _aExponent = exponent(_normA);\n        _bMantissa = mantissa(_normB);\n        _bExponent = exponent(_normB);\n\n        int256 _delta = _aExponent - _bExponent;\n        if (_delta >= 0) {\n            if (_delta > int256(SIGNIFICANT_DIGITS)) {\n                return (_normA, from(0, _aExponent));\n            }\n            return (_normA, shift(_normB, _delta));\n        } else {\n            if (-_delta > int256(SIGNIFICANT_DIGITS)) {\n                return (from(0, _bExponent), _normB);\n            }\n            return (shift(_normA, -_delta), _normB);\n        }\n    }\n\n    //================\n    //   Arithmetic\n    //================\n    function plus(Float a_, Float b_) internal pure returns (Float) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return normalize(mantissa(_alignedA) + mantissa(_alignedB), exponent(_alignedA));\n    }\n\n    function minus(Float a_) internal pure returns (Float) {\n        return from(-mantissa(a_), exponent(a_));\n    }\n\n    function minus(Float a_, Float b_) internal pure returns (Float) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return normalize(mantissa(_alignedA) - mantissa(_alignedB), exponent(_alignedA));\n    }\n\n    function times(Float a_, Float b_) internal pure returns (Float) {\n        Float _normA = normalize(a_);\n        Float _normB = normalize(b_);\n        int256 _ma = mantissa(_normA);\n        int256 _mb = mantissa(_normB);\n        return normalize(\n            (_ma * _mb) / int256(10 ** SIGNIFICANT_DIGITS),\n            int256(SIGNIFICANT_DIGITS) + exponent(_normA) + exponent(_normB)\n        );\n    }\n\n    function divide(Float a_, Float b_) internal pure returns (Float) {\n        Float _normA = normalize(a_);\n        Float _normB = normalize(b_);\n        int256 _ma = mantissa(_normA);\n        int256 _mb = mantissa(_normB);\n        return normalize(\n            (_ma * int256(10 ** SIGNIFICANT_DIGITS)) / _mb,\n            exponent(_normA) - exponent(_normB) - int256(SIGNIFICANT_DIGITS)\n        );\n    }\n\n    //=======================\n    //   Special functions\n    //=======================\n    function round(Float a_, uint256 digits_) internal pure returns (Float) {\n        if (mantissa(a_) == 0) return ZERO;\n        if (digits_ >= SIGNIFICANT_DIGITS) return normalize(a_);\n        Float _norm = normalize(a_);\n        int256 _factor = int256(10 ** (SIGNIFICANT_DIGITS - digits_));\n        int256 _mant = int256(mantissa(_norm));\n        int256 _scaled = _mant / _factor;\n        int256 _remainder = _mant % _factor;\n        if (_remainder * 2 >= _factor) {\n            _scaled++;\n        }\n        if (_remainder * 2 <= -_factor) {\n            _scaled--;\n        }\n        int256 _resultMant = _scaled * _factor;\n        return from(_resultMant, exponent(_norm));\n    }\n\n    function parts(Float number_) internal pure returns (Float _integerPart, Float _fractionalPart) {\n        Float _norm = normalize(number_);\n        (int256 _m, int256 _e) = components(_norm);\n\n        if (_m == 0) return (ZERO, ZERO);\n        if (_e >= 0) return (_norm, ZERO);\n        if (int256(SIGNIFICANT_DIGITS) + _e < 0) return (ZERO, _norm); // too small, integer part is 0\n\n        int256 _div = int256(10 ** uint256(-_e)); // shift ≤ SIGNIFICANT_DIGITS\n        _integerPart = normalize(_m / _div, 0); // truncates toward zero\n        _fractionalPart = _norm.minus(_integerPart);\n    }\n\n    function exp(Float x_) internal pure returns (Float) {\n        Float _y = x_.divide(LOG10);\n        (Float _yInt, Float _yFrac) = _y.parts();\n        int256 _wad = _yFrac.times(LOG10).toInt(); // 18-decimal wad\n        int256 _m = _wad.expWad(); // still 18-decimal wad\n        int256 _e = _yInt.toInt(0) - 18; // adjust for wad scale\n        return normalize(_m, _e);\n    }\n\n    function log(Float x_) internal pure returns (Float) {\n        Float _x = normalize(x_);\n        (int256 _m, int256 _e) = components(_x);\n        require(_m > 0, \"log non-positive\");\n\n        int256 _lnWad = (_m * 1e18).lnWad() + _e * LOG10_WAD;\n\n        return normalize(_lnWad, -18);\n    }\n\n    //-------------\n    //   Pow\n    //-------------\n    // Exponentiation by squaring for integer exponents; faster and avoids the rounding stack-up of exp(log(x) * n).\n    function powUint(Float base_, uint256 e_) internal pure returns (Float result_) {\n        if (e_ == 0) return ONE;\n        Float _base = normalize(base_);\n        if (e_ == 1) return _base;\n        if (mantissa(_base) == 0) return ZERO;\n        if (_base.isEQ(ONE)) return ONE;\n\n        result_ = ONE;\n        uint256 _exp = e_;\n        while (_exp != 0) {\n            if (_exp & 1 == 1) {\n                result_ = result_.times(_base);\n            }\n            _exp >>= 1;\n            if (_exp != 0) {\n                _base = _base.times(_base);\n            }\n        }\n    }\n\n    function powInt(Float base_, int256 e_) internal pure returns (Float) {\n        Float _base = normalize(base_);\n        if (e_ >= 0) return powUint(_base, uint256(e_));\n        require(mantissa(_base) != 0, \"pow: zero base\");\n        require(e_ != type(int256).min, \"pow: exponent too small\");\n        Float _pos = powUint(_base, uint256(-e_));\n        return ONE.divide(_pos);\n    }\n\n    // Real-exponent power via exp(log(base) * exponent); base must be positive to keep log defined.\n    function pow(Float base_, Float e_) internal pure returns (Float) {\n        Float _base = normalize(base_);\n        if (mantissa(e_) == 0) return ONE;\n        if (_base.isEQ(ONE)) return ONE;\n        require(mantissa(_base) > 0, \"pow: base must be positive\");\n        return exp(log(_base).times(e_));\n    }\n\n    function sqrt(Float x_) internal pure returns (Float) {\n        return exp(log(x_).divide(TWO));\n    }\n\n    function fullMulDiv(Float a_, Float b_, Float c_) internal pure returns (Float) {\n        bool _isNegative = false;\n        if (mantissa(a_) < 0) {\n            a_ = minus(a_);\n            _isNegative = !_isNegative;\n        }\n        if (mantissa(b_) < 0) {\n            b_ = minus(b_);\n            _isNegative = !_isNegative;\n        }\n        if (mantissa(c_) < 0) {\n            c_ = minus(c_);\n            _isNegative = !_isNegative;\n        }\n        Float _normA = normalize(a_);\n        Float _normB = normalize(b_);\n        Float _normC = normalize(c_);\n        uint256 _ma = uint256(mantissa(_normA));\n        uint256 _mb = uint256(mantissa(_normB));\n        uint256 _mc = uint256(mantissa(_normC));\n        int256 _m = _isNegative ? -int256(_ma.fullMulDiv(_mb, _mc)) : int256(_ma.fullMulDiv(_mb, _mc));\n        int256 _e = exponent(_normA) + exponent(_normB) - exponent(_normC);\n        return normalize(_m, _e);\n    }\n\n    //====================\n    //   Helper methods\n    //====================\n    function from(int256 mantissa_, int256 exponent_) internal pure returns (Float) {\n        int256 _packed = (exponent_ << MANTISSA_BITS) | (mantissa_ & int256(MANTISSA_MASK));\n        return Float.wrap(_packed);\n    }\n\n    function components(Float a_) internal pure returns (int256 _mantissa, int256 _exponent) {\n        int256 _raw = Float.unwrap(a_);\n        _mantissa = int256(int72(_raw));\n        _exponent = _raw >> MANTISSA_BITS;\n    }\n\n    function mantissa(Float a_) internal pure returns (int256) {\n        return int256(int72(Float.unwrap(a_)));\n    }\n\n    function exponent(Float a_) internal pure returns (int256) {\n        return int256(Float.unwrap(a_) >> MANTISSA_BITS);\n    }\n}\n"
      }
    },
    "settings": {
      "outputSelection": {
        "*": {
          "*": [
            "abi",
            "userdoc",
            "evm.bytecode.object",
            "evm.deployedBytecode.object"
          ]
        }
      }
    }
  },
  "solcOutput": {
    "contracts": {
      "/Users/williamcory/cavalre-contracts/libraries/FloatLib.sol": {
        "FloatLib": {
          "abi": [
            {
              "inputs": [],
              "name": "NoSolution",
              "type": "error"
            }
          ],
          "evm": {
            "bytecode": {
              "object": "6055604b600b8282823980515f1a607314603f577f4e487b71000000000000000000000000000000000000000000000000000000005f525f60045260245ffd5b305f52607381538281f3fe730000000000000000000000000000000000000000301460806040525f5ffdfea26469706673582212203acc4c4068762cbcabcffd2a6a612badcd2e4489286cbaec816dfa4e3a59c93964736f6c634300081e0033"
            },
            "deployedBytecode": {
              "object": "730000000000000000000000000000000000000000301460806040525f5ffdfea26469706673582212203acc4c4068762cbcabcffd2a6a612badcd2e4489286cbaec816dfa4e3a59c93964736f6c634300081e0033"
            }
          },
          "userdoc": {
            "kind": "user",
            "methods": {},
            "version": 1
          }
        }
      },
      "/Users/williamcory/cavalre-contracts/libraries/FloatStrings.sol": {
        "FloatStrings": {
          "abi": [
            {
              "inputs": [
                {
                  "internalType": "uint256",
                  "name": "number_",
                  "type": "uint256"
                }
              ],
              "name": "digits",
              "outputs": [
                {
                  "internalType": "uint8",
                  "name": "",
                  "type": "uint8"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "bytes",
                  "name": "strBytes_",
                  "type": "bytes"
                },
                {
                  "internalType": "uint256",
                  "name": "numChars_",
                  "type": "uint256"
                }
              ],
              "name": "shiftStringBytesLeft",
              "outputs": [
                {
                  "internalType": "bytes",
                  "name": "",
                  "type": "bytes"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "bytes",
                  "name": "strBytes_",
                  "type": "bytes"
                },
                {
                  "internalType": "uint256",
                  "name": "numChars_",
                  "type": "uint256"
                }
              ],
              "name": "shiftStringBytesRight",
              "outputs": [
                {
                  "internalType": "bytes",
                  "name": "_result",
                  "type": "bytes"
                },
                {
                  "internalType": "bytes",
                  "name": "_remainder",
                  "type": "bytes"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "string",
                  "name": "str_",
                  "type": "string"
                },
                {
                  "internalType": "uint256",
                  "name": "numChars_",
                  "type": "uint256"
                }
              ],
              "name": "shiftStringLeft",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "string",
                  "name": "str_",
                  "type": "string"
                },
                {
                  "internalType": "uint256",
                  "name": "numChars_",
                  "type": "uint256"
                }
              ],
              "name": "shiftStringRight",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "_result",
                  "type": "string"
                },
                {
                  "internalType": "string",
                  "name": "_remainder",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "uint256",
                  "name": "value_",
                  "type": "uint256"
                }
              ],
              "name": "toString",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "value_",
                  "type": "int256"
                }
              ],
              "name": "toString",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "uint256",
                  "name": "value_",
                  "type": "uint256"
                }
              ],
              "name": "toStringBytes",
              "outputs": [
                {
                  "internalType": "bytes",
                  "name": "",
                  "type": "bytes"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "bytes",
                  "name": "strBytes_",
                  "type": "bytes"
                }
              ],
              "name": "trimStringBytesRight",
              "outputs": [
                {
                  "internalType": "bytes",
                  "name": "",
                  "type": "bytes"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "string",
                  "name": "str_",
                  "type": "string"
                }
              ],
              "name": "trimStringRight",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            }
          ],
          "evm": {
            "bytecode": {
              "object": "61122c61004d600b8282823980515f1a6073146041577f4e487b71000000000000000000000000000000000000000000000000000000005f525f60045260245ffd5b305f52607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100a7575f3560e01c80636f74acfc1161006f5780636f74acfc1461019b5780637b23c90d146101cc578063a322c40e146101fc578063f5d39bab1461022c578063fb85559f1461025d576100a7565b806304eaf90b146100ab5780630efc2a42146100db5780632ed038321461010b5780635a770e1d1461013b5780636900a3ae1461016b575b5f5ffd5b6100c560048036038101906100c09190610bca565b61028d565b6040516100d29190610c84565b60405180910390f35b6100f560048036038101906100f09190610d42565b6102a1565b6040516101029190610dee565b60405180910390f35b61012560048036038101906101209190610e0e565b6103f5565b6040516101329190610c84565b60405180910390f35b61015560048036038101906101509190610e55565b610407565b6040516101629190610dee565b60405180910390f35b61018560048036038101906101809190610e55565b61053f565b6040516101929190610c84565b60405180910390f35b6101b560048036038101906101b09190610bca565b610551565b6040516101c3929190610e80565b60405180910390f35b6101e660048036038101906101e19190610e55565b61057d565b6040516101f39190610ed0565b60405180910390f35b61021660048036038101906102119190610f1c565b6105c6565b6040516102239190610c84565b60405180910390f35b61024660048036038101906102419190610d42565b610652565b604051610254929190610f47565b60405180910390f35b61027760048036038101906102729190610f7c565b6108b0565b6040516102849190610dee565b60405180910390f35b606061029983836102a1565b905092915050565b60605f8284516102b19190610ff0565b67ffffffffffffffff8111156102ca576102c9610a73565b5b6040519080825280601f01601f1916602001820160405280156102fc5781602001600182028036833780820191505090505b5090505f5f90505b81518110156103ea57845181101561037a5784818151811061032957610328611023565b5b602001015160f81c60f81b82828151811061034757610346611023565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053506103dd565b7f30000000000000000000000000000000000000000000000000000000000000008282815181106103ae576103ad611023565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053505b8080600101915050610304565b508091505092915050565b6060610400826108b0565b9050919050565b60605f820361044d576040518060400160405280600181526020017f3000000000000000000000000000000000000000000000000000000000000000815250905061053a565b5f6104578361057d565b60ff1690505f8167ffffffffffffffff81111561047757610476610a73565b5b6040519080825280601f01601f1916602001820160405280156104a95781602001600182028036833780820191505090505b5090505b5f8414610534576001826104c19190611050565b9150600a846104d091906110b0565b60306104dc9190610ff0565b60f81b8183815181106104f2576104f1611023565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a905350600a8461052d91906110e0565b93506104ad565b80925050505b919050565b606061054a82610407565b9050919050565b6060805f8490506060806105658387610652565b80925081935050508194508093505050509250929050565b5f5f820361058e57600190506105c1565b5f5f90505b5f83146105bc5780806105a590611110565b915050600a836105b591906110e0565b9250610593565b809150505b919050565b60605f82126105e35760405180602001604052805f81525061061a565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b61062b61062684610a35565b610407565b60405160200161063c9291906111ac565b6040516020818303038152906040529050919050565b6060805f5f5f86518611156106c8575f92508651866106719190611050565b9050600167ffffffffffffffff81111561068e5761068d610a73565b5b6040519080825280601f01601f1916602001820160405280156106c05781602001600182028036833780820191505090505b509450610727565b8587516106d59190611050565b92508267ffffffffffffffff8111156106f1576106f0610a73565b5b6040519080825280601f01601f1916602001820160405280156107235781602001600182028036833780820191505090505b5094505b8591508167ffffffffffffffff81111561074457610743610a73565b5b6040519080825280601f01601f1916602001820160405280156107765781602001600182028036833780820191505090505b5093505f5f90505b87518110156108a557838110156107f3578781815181106107a2576107a1611023565b5b602001015160f81c60f81b8682815181106107c0576107bf611023565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a905350610898565b87818560018b516108049190611050565b61080e9190610ff0565b6108189190611050565b8151811061082957610828611023565b5b602001015160f81c60f81b8582866001876108449190611050565b61084e9190610ff0565b6108589190611050565b8151811061086957610868611023565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053505b808060010191505061077e565b505050509250929050565b60605f600183516108c19190611050565b90505b5f8111801561093157507f300000000000000000000000000000000000000000000000000000000000000083828151811061090257610901611023565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b15610949578080610941906111cf565b9150506108c4565b5f6001826109579190610ff0565b67ffffffffffffffff8111156109705761096f610a73565b5b6040519080825280601f01601f1916602001820160405280156109a25781602001600182028036833780820191505090505b5090505f5f90505b6001836109b79190610ff0565b811015610a2a578481815181106109d1576109d0611023565b5b602001015160f81c60f81b8282815181106109ef576109ee611023565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a90535080806001019150506109aa565b508092505050919050565b5f60ff82901d60ff83901d8301189050919050565b5f604051905090565b5f5ffd5b5f5ffd5b5f5ffd5b5f5ffd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b610aa982610a63565b810181811067ffffffffffffffff82111715610ac857610ac7610a73565b5b80604052505050565b5f610ada610a4a565b9050610ae68282610aa0565b919050565b5f67ffffffffffffffff821115610b0557610b04610a73565b5b610b0e82610a63565b9050602081019050919050565b828183375f83830152505050565b5f610b3b610b3684610aeb565b610ad1565b905082815260208101848484011115610b5757610b56610a5f565b5b610b62848285610b1b565b509392505050565b5f82601f830112610b7e57610b7d610a5b565b5b8135610b8e848260208601610b29565b91505092915050565b5f819050919050565b610ba981610b97565b8114610bb3575f5ffd5b50565b5f81359050610bc481610ba0565b92915050565b5f5f60408385031215610be057610bdf610a53565b5b5f83013567ffffffffffffffff811115610bfd57610bfc610a57565b5b610c0985828601610b6a565b9250506020610c1a85828601610bb6565b9150509250929050565b5f81519050919050565b5f82825260208201905092915050565b8281835e5f83830152505050565b5f610c5682610c24565b610c608185610c2e565b9350610c70818560208601610c3e565b610c7981610a63565b840191505092915050565b5f6020820190508181035f830152610c9c8184610c4c565b905092915050565b5f67ffffffffffffffff821115610cbe57610cbd610a73565b5b610cc782610a63565b9050602081019050919050565b5f610ce6610ce184610ca4565b610ad1565b905082815260208101848484011115610d0257610d01610a5f565b5b610d0d848285610b1b565b509392505050565b5f82601f830112610d2957610d28610a5b565b5b8135610d39848260208601610cd4565b91505092915050565b5f5f60408385031215610d5857610d57610a53565b5b5f83013567ffffffffffffffff811115610d7557610d74610a57565b5b610d8185828601610d15565b9250506020610d9285828601610bb6565b9150509250929050565b5f81519050919050565b5f82825260208201905092915050565b5f610dc082610d9c565b610dca8185610da6565b9350610dda818560208601610c3e565b610de381610a63565b840191505092915050565b5f6020820190508181035f830152610e068184610db6565b905092915050565b5f60208284031215610e2357610e22610a53565b5b5f82013567ffffffffffffffff811115610e4057610e3f610a57565b5b610e4c84828501610b6a565b91505092915050565b5f60208284031215610e6a57610e69610a53565b5b5f610e7784828501610bb6565b91505092915050565b5f6040820190508181035f830152610e988185610c4c565b90508181036020830152610eac8184610c4c565b90509392505050565b5f60ff82169050919050565b610eca81610eb5565b82525050565b5f602082019050610ee35f830184610ec1565b92915050565b5f819050919050565b610efb81610ee9565b8114610f05575f5ffd5b50565b5f81359050610f1681610ef2565b92915050565b5f60208284031215610f3157610f30610a53565b5b5f610f3e84828501610f08565b91505092915050565b5f6040820190508181035f830152610f5f8185610db6565b90508181036020830152610f738184610db6565b90509392505050565b5f60208284031215610f9157610f90610a53565b5b5f82013567ffffffffffffffff811115610fae57610fad610a57565b5b610fba84828501610d15565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f610ffa82610b97565b915061100583610b97565b925082820190508082111561101d5761101c610fc3565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f61105a82610b97565b915061106583610b97565b925082820390508181111561107d5761107c610fc3565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f6110ba82610b97565b91506110c583610b97565b9250826110d5576110d4611083565b5b828206905092915050565b5f6110ea82610b97565b91506110f583610b97565b92508261110557611104611083565b5b828204905092915050565b5f61111a82610eb5565b915060ff820361112d5761112c610fc3565b5b600182019050919050565b5f81905092915050565b5f61114c82610c24565b6111568185611138565b9350611166818560208601610c3e565b80840191505092915050565b5f81905092915050565b5f61118682610d9c565b6111908185611172565b93506111a0818560208601610c3e565b80840191505092915050565b5f6111b78285611142565b91506111c3828461117c565b91508190509392505050565b5f6111d982610b97565b91505f82036111eb576111ea610fc3565b5b60018203905091905056fea2646970667358221220be54b249ea0da5fc13ea107ed5100c0e7c1436995c891f647cbe8be4e9579f0f64736f6c634300081e0033"
            },
            "deployedBytecode": {
              "object": "73000000000000000000000000000000000000000030146080604052600436106100a7575f3560e01c80636f74acfc1161006f5780636f74acfc1461019b5780637b23c90d146101cc578063a322c40e146101fc578063f5d39bab1461022c578063fb85559f1461025d576100a7565b806304eaf90b146100ab5780630efc2a42146100db5780632ed038321461010b5780635a770e1d1461013b5780636900a3ae1461016b575b5f5ffd5b6100c560048036038101906100c09190610bca565b61028d565b6040516100d29190610c84565b60405180910390f35b6100f560048036038101906100f09190610d42565b6102a1565b6040516101029190610dee565b60405180910390f35b61012560048036038101906101209190610e0e565b6103f5565b6040516101329190610c84565b60405180910390f35b61015560048036038101906101509190610e55565b610407565b6040516101629190610dee565b60405180910390f35b61018560048036038101906101809190610e55565b61053f565b6040516101929190610c84565b60405180910390f35b6101b560048036038101906101b09190610bca565b610551565b6040516101c3929190610e80565b60405180910390f35b6101e660048036038101906101e19190610e55565b61057d565b6040516101f39190610ed0565b60405180910390f35b61021660048036038101906102119190610f1c565b6105c6565b6040516102239190610c84565b60405180910390f35b61024660048036038101906102419190610d42565b610652565b604051610254929190610f47565b60405180910390f35b61027760048036038101906102729190610f7c565b6108b0565b6040516102849190610dee565b60405180910390f35b606061029983836102a1565b905092915050565b60605f8284516102b19190610ff0565b67ffffffffffffffff8111156102ca576102c9610a73565b5b6040519080825280601f01601f1916602001820160405280156102fc5781602001600182028036833780820191505090505b5090505f5f90505b81518110156103ea57845181101561037a5784818151811061032957610328611023565b5b602001015160f81c60f81b82828151811061034757610346611023565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053506103dd565b7f30000000000000000000000000000000000000000000000000000000000000008282815181106103ae576103ad611023565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053505b8080600101915050610304565b508091505092915050565b6060610400826108b0565b9050919050565b60605f820361044d576040518060400160405280600181526020017f3000000000000000000000000000000000000000000000000000000000000000815250905061053a565b5f6104578361057d565b60ff1690505f8167ffffffffffffffff81111561047757610476610a73565b5b6040519080825280601f01601f1916602001820160405280156104a95781602001600182028036833780820191505090505b5090505b5f8414610534576001826104c19190611050565b9150600a846104d091906110b0565b60306104dc9190610ff0565b60f81b8183815181106104f2576104f1611023565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a905350600a8461052d91906110e0565b93506104ad565b80925050505b919050565b606061054a82610407565b9050919050565b6060805f8490506060806105658387610652565b80925081935050508194508093505050509250929050565b5f5f820361058e57600190506105c1565b5f5f90505b5f83146105bc5780806105a590611110565b915050600a836105b591906110e0565b9250610593565b809150505b919050565b60605f82126105e35760405180602001604052805f81525061061a565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b61062b61062684610a35565b610407565b60405160200161063c9291906111ac565b6040516020818303038152906040529050919050565b6060805f5f5f86518611156106c8575f92508651866106719190611050565b9050600167ffffffffffffffff81111561068e5761068d610a73565b5b6040519080825280601f01601f1916602001820160405280156106c05781602001600182028036833780820191505090505b509450610727565b8587516106d59190611050565b92508267ffffffffffffffff8111156106f1576106f0610a73565b5b6040519080825280601f01601f1916602001820160405280156107235781602001600182028036833780820191505090505b5094505b8591508167ffffffffffffffff81111561074457610743610a73565b5b6040519080825280601f01601f1916602001820160405280156107765781602001600182028036833780820191505090505b5093505f5f90505b87518110156108a557838110156107f3578781815181106107a2576107a1611023565b5b602001015160f81c60f81b8682815181106107c0576107bf611023565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a905350610898565b87818560018b516108049190611050565b61080e9190610ff0565b6108189190611050565b8151811061082957610828611023565b5b602001015160f81c60f81b8582866001876108449190611050565b61084e9190610ff0565b6108589190611050565b8151811061086957610868611023565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053505b808060010191505061077e565b505050509250929050565b60605f600183516108c19190611050565b90505b5f8111801561093157507f300000000000000000000000000000000000000000000000000000000000000083828151811061090257610901611023565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b15610949578080610941906111cf565b9150506108c4565b5f6001826109579190610ff0565b67ffffffffffffffff8111156109705761096f610a73565b5b6040519080825280601f01601f1916602001820160405280156109a25781602001600182028036833780820191505090505b5090505f5f90505b6001836109b79190610ff0565b811015610a2a578481815181106109d1576109d0611023565b5b602001015160f81c60f81b8282815181106109ef576109ee611023565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a90535080806001019150506109aa565b508092505050919050565b5f60ff82901d60ff83901d8301189050919050565b5f604051905090565b5f5ffd5b5f5ffd5b5f5ffd5b5f5ffd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b610aa982610a63565b810181811067ffffffffffffffff82111715610ac857610ac7610a73565b5b80604052505050565b5f610ada610a4a565b9050610ae68282610aa0565b919050565b5f67ffffffffffffffff821115610b0557610b04610a73565b5b610b0e82610a63565b9050602081019050919050565b828183375f83830152505050565b5f610b3b610b3684610aeb565b610ad1565b905082815260208101848484011115610b5757610b56610a5f565b5b610b62848285610b1b565b509392505050565b5f82601f830112610b7e57610b7d610a5b565b5b8135610b8e848260208601610b29565b91505092915050565b5f819050919050565b610ba981610b97565b8114610bb3575f5ffd5b50565b5f81359050610bc481610ba0565b92915050565b5f5f60408385031215610be057610bdf610a53565b5b5f83013567ffffffffffffffff811115610bfd57610bfc610a57565b5b610c0985828601610b6a565b9250506020610c1a85828601610bb6565b9150509250929050565b5f81519050919050565b5f82825260208201905092915050565b8281835e5f83830152505050565b5f610c5682610c24565b610c608185610c2e565b9350610c70818560208601610c3e565b610c7981610a63565b840191505092915050565b5f6020820190508181035f830152610c9c8184610c4c565b905092915050565b5f67ffffffffffffffff821115610cbe57610cbd610a73565b5b610cc782610a63565b9050602081019050919050565b5f610ce6610ce184610ca4565b610ad1565b905082815260208101848484011115610d0257610d01610a5f565b5b610d0d848285610b1b565b509392505050565b5f82601f830112610d2957610d28610a5b565b5b8135610d39848260208601610cd4565b91505092915050565b5f5f60408385031215610d5857610d57610a53565b5b5f83013567ffffffffffffffff811115610d7557610d74610a57565b5b610d8185828601610d15565b9250506020610d9285828601610bb6565b9150509250929050565b5f81519050919050565b5f82825260208201905092915050565b5f610dc082610d9c565b610dca8185610da6565b9350610dda818560208601610c3e565b610de381610a63565b840191505092915050565b5f6020820190508181035f830152610e068184610db6565b905092915050565b5f60208284031215610e2357610e22610a53565b5b5f82013567ffffffffffffffff811115610e4057610e3f610a57565b5b610e4c84828501610b6a565b91505092915050565b5f60208284031215610e6a57610e69610a53565b5b5f610e7784828501610bb6565b91505092915050565b5f6040820190508181035f830152610e988185610c4c565b90508181036020830152610eac8184610c4c565b90509392505050565b5f60ff82169050919050565b610eca81610eb5565b82525050565b5f602082019050610ee35f830184610ec1565b92915050565b5f819050919050565b610efb81610ee9565b8114610f05575f5ffd5b50565b5f81359050610f1681610ef2565b92915050565b5f60208284031215610f3157610f30610a53565b5b5f610f3e84828501610f08565b91505092915050565b5f6040820190508181035f830152610f5f8185610db6565b90508181036020830152610f738184610db6565b90509392505050565b5f60208284031215610f9157610f90610a53565b5b5f82013567ffffffffffffffff811115610fae57610fad610a57565b5b610fba84828501610d15565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f610ffa82610b97565b915061100583610b97565b925082820190508082111561101d5761101c610fc3565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f61105a82610b97565b915061106583610b97565b925082820390508181111561107d5761107c610fc3565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f6110ba82610b97565b91506110c583610b97565b9250826110d5576110d4611083565b5b828206905092915050565b5f6110ea82610b97565b91506110f583610b97565b92508261110557611104611083565b5b828204905092915050565b5f61111a82610eb5565b915060ff820361112d5761112c610fc3565b5b600182019050919050565b5f81905092915050565b5f61114c82610c24565b6111568185611138565b9350611166818560208601610c3e565b80840191505092915050565b5f81905092915050565b5f61118682610d9c565b6111908185611172565b93506111a0818560208601610c3e565b80840191505092915050565b5f6111b78285611142565b91506111c3828461117c565b91508190509392505050565b5f6111d982610b97565b91505f82036111eb576111ea610fc3565b5b60018203905091905056fea2646970667358221220be54b249ea0da5fc13ea107ed5100c0e7c1436995c891f647cbe8be4e9579f0f64736f6c634300081e0033"
            }
          },
          "userdoc": {
            "kind": "user",
            "methods": {},
            "version": 1
          }
        }
      },
      "/Users/williamcory/cavalre-contracts/node_modules/solady/src/utils/FixedPointMathLib.sol": {
        "FixedPointMathLib": {
          "abi": [
            {
              "inputs": [],
              "name": "DivFailed",
              "type": "error"
            },
            {
              "inputs": [],
              "name": "DivWadFailed",
              "type": "error"
            },
            {
              "inputs": [],
              "name": "ExpOverflow",
              "type": "error"
            },
            {
              "inputs": [],
              "name": "FactorialOverflow",
              "type": "error"
            },
            {
              "inputs": [],
              "name": "FullMulDivFailed",
              "type": "error"
            },
            {
              "inputs": [],
              "name": "LnWadUndefined",
              "type": "error"
            },
            {
              "inputs": [],
              "name": "MantissaOverflow",
              "type": "error"
            },
            {
              "inputs": [],
              "name": "MulDivFailed",
              "type": "error"
            },
            {
              "inputs": [],
              "name": "MulWadFailed",
              "type": "error"
            },
            {
              "inputs": [],
              "name": "OutOfDomain",
              "type": "error"
            },
            {
              "inputs": [],
              "name": "RPowOverflow",
              "type": "error"
            },
            {
              "inputs": [],
              "name": "SDivWadFailed",
              "type": "error"
            },
            {
              "inputs": [],
              "name": "SMulWadFailed",
              "type": "error"
            }
          ],
          "evm": {
            "bytecode": {
              "object": "6055604b600b8282823980515f1a607314603f577f4e487b71000000000000000000000000000000000000000000000000000000005f525f60045260245ffd5b305f52607381538281f3fe730000000000000000000000000000000000000000301460806040525f5ffdfea26469706673582212202e82c4c5997c7d7334d9b44cc375aba74c312f286db81566a8dacbf37ff3968864736f6c634300081e0033"
            },
            "deployedBytecode": {
              "object": "730000000000000000000000000000000000000000301460806040525f5ffdfea26469706673582212202e82c4c5997c7d7334d9b44cc375aba74c312f286db81566a8dacbf37ff3968864736f6c634300081e0033"
            }
          },
          "userdoc": {
            "kind": "user",
            "methods": {},
            "notice": "Arithmetic library with operations for fixed-point numbers.",
            "version": 1
          }
        }
      },
      "/Users/williamcory/cavalre-contracts/playground/contracts/FloatCalculator.s.sol": {
        "FloatCalculator": {
          "abi": [
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "uint8",
                  "name": "decimals",
                  "type": "uint8"
                }
              ],
              "name": "absoluteValue",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "b",
                  "type": "int256"
                },
                {
                  "internalType": "uint8",
                  "name": "decimals",
                  "type": "uint8"
                }
              ],
              "name": "add",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "b",
                  "type": "int256"
                },
                {
                  "internalType": "uint8",
                  "name": "decimals",
                  "type": "uint8"
                }
              ],
              "name": "divide",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "uint8",
                  "name": "decimals",
                  "type": "uint8"
                }
              ],
              "name": "exponential",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "mantissa",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "exponent",
                  "type": "int256"
                }
              ],
              "name": "fromComponents",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "b",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "c",
                  "type": "int256"
                },
                {
                  "internalType": "uint8",
                  "name": "decimals",
                  "type": "uint8"
                }
              ],
              "name": "fullMulDiv",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "value",
                  "type": "int256"
                },
                {
                  "internalType": "uint8",
                  "name": "decimals",
                  "type": "uint8"
                }
              ],
              "name": "getComponents",
              "outputs": [
                {
                  "internalType": "int256",
                  "name": "mantissa",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "exponent",
                  "type": "int256"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "uint8",
                  "name": "decimals",
                  "type": "uint8"
                }
              ],
              "name": "getParts",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "intPart",
                  "type": "string"
                },
                {
                  "internalType": "string",
                  "name": "fracPart",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "b",
                  "type": "int256"
                },
                {
                  "internalType": "uint8",
                  "name": "decimals",
                  "type": "uint8"
                }
              ],
              "name": "isEqual",
              "outputs": [
                {
                  "internalType": "bool",
                  "name": "",
                  "type": "bool"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "b",
                  "type": "int256"
                },
                {
                  "internalType": "uint8",
                  "name": "decimals",
                  "type": "uint8"
                }
              ],
              "name": "isGreaterOrEqual",
              "outputs": [
                {
                  "internalType": "bool",
                  "name": "",
                  "type": "bool"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "b",
                  "type": "int256"
                },
                {
                  "internalType": "uint8",
                  "name": "decimals",
                  "type": "uint8"
                }
              ],
              "name": "isGreaterThan",
              "outputs": [
                {
                  "internalType": "bool",
                  "name": "",
                  "type": "bool"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "b",
                  "type": "int256"
                },
                {
                  "internalType": "uint8",
                  "name": "decimals",
                  "type": "uint8"
                }
              ],
              "name": "isLessOrEqual",
              "outputs": [
                {
                  "internalType": "bool",
                  "name": "",
                  "type": "bool"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "b",
                  "type": "int256"
                },
                {
                  "internalType": "uint8",
                  "name": "decimals",
                  "type": "uint8"
                }
              ],
              "name": "isLessThan",
              "outputs": [
                {
                  "internalType": "bool",
                  "name": "",
                  "type": "bool"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "uint8",
                  "name": "decimals",
                  "type": "uint8"
                }
              ],
              "name": "isZero",
              "outputs": [
                {
                  "internalType": "bool",
                  "name": "",
                  "type": "bool"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "b",
                  "type": "int256"
                },
                {
                  "internalType": "uint8",
                  "name": "decimals",
                  "type": "uint8"
                }
              ],
              "name": "multiply",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "uint8",
                  "name": "decimals",
                  "type": "uint8"
                }
              ],
              "name": "naturalLog",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "uint8",
                  "name": "decimals",
                  "type": "uint8"
                }
              ],
              "name": "negate",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "mantissa",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "exponent",
                  "type": "int256"
                }
              ],
              "name": "normalize",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [],
              "name": "one",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [],
              "name": "pi",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "base",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "exp",
                  "type": "int256"
                },
                {
                  "internalType": "uint8",
                  "name": "decimals",
                  "type": "uint8"
                }
              ],
              "name": "power",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "uint8",
                  "name": "decimals",
                  "type": "uint8"
                },
                {
                  "internalType": "uint256",
                  "name": "digits",
                  "type": "uint256"
                }
              ],
              "name": "roundTo",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "uint8",
                  "name": "decimals",
                  "type": "uint8"
                },
                {
                  "internalType": "int256",
                  "name": "places",
                  "type": "int256"
                }
              ],
              "name": "shift",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "uint8",
                  "name": "decimals",
                  "type": "uint8"
                }
              ],
              "name": "squareRoot",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "b",
                  "type": "int256"
                },
                {
                  "internalType": "uint8",
                  "name": "decimals",
                  "type": "uint8"
                }
              ],
              "name": "subtract",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [],
              "name": "ten",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "value",
                  "type": "int256"
                },
                {
                  "internalType": "uint8",
                  "name": "decimals",
                  "type": "uint8"
                }
              ],
              "name": "toFloatString",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [],
              "name": "two",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [],
              "name": "zero",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            }
          ],
          "evm": {
            "bytecode": {
              "object": "6080604052348015600e575f5ffd5b506137c38061001c5f395ff3fe608060405234801561000f575f5ffd5b50600436106101cc575f3560e01c8063643ceff911610102578063a2f295c5116100a0578063bc1b392d1161006f578063bc1b392d1461063a578063c753cb3514610658578063df65245d14610688578063f81f8936146106b8576101cc565b8063a2f295c514610579578063a7bfcd0d146105a9578063ba93bc3f146105d9578063bbbd0d3214610609576101cc565b80638cf45091116100dc5780638cf45091146104cb578063901717d1146104fb57806392c1eb9e1461051957806394fd4ee714610549576101cc565b8063643ceff91461044d578063799f54461461046b5780638535829a1461049b576101cc565b80632dd9868d1161016f5780635a260d7f116101495780635a260d7f1461039f5780635caea0ac146103cf5780635d6e8d1c146103ff5780635fdf05d71461042f576101cc565b80632dd9868d1461032157806348f5294c1461033f5780634acc886a1461036f576101cc565b80631b1e7001116101ab5780631b1e7001146102615780631e18b7b214610291578063250ef6e8146102c157806328a4d194146102f1576101cc565b80621f35f5146101d05780630552e844146102005780630a08167214610230575b5f5ffd5b6101ea60048036038101906101e59190612b13565b6106e8565b6040516101f79190612bd3565b60405180910390f35b61021a60048036038101906102159190612bf3565b61072a565b6040516102279190612c4b565b60405180910390f35b61024a60048036038101906102459190612bf3565b61074a565b604051610258929190612c64565b60405180910390f35b61027b60048036038101906102769190612bf3565b610789565b6040516102889190612bd3565b60405180910390f35b6102ab60048036038101906102a69190612c99565b6107a5565b6040516102b89190612bd3565b60405180910390f35b6102db60048036038101906102d69190612bf3565b6107c1565b6040516102e89190612bd3565b60405180910390f35b61030b60048036038101906103069190612cd7565b6107ea565b6040516103189190612bd3565b60405180910390f35b610329610833565b6040516103369190612bd3565b60405180910390f35b61035960048036038101906103549190612bf3565b610872565b6040516103669190612bd3565b60405180910390f35b61038960048036038101906103849190612b13565b61089b565b6040516103969190612c4b565b60405180910390f35b6103b960048036038101906103b49190612b13565b6108d4565b6040516103c69190612bd3565b60405180910390f35b6103e960048036038101906103e49190612b13565b610916565b6040516103f69190612c4b565b60405180910390f35b61041960048036038101906104149190612b13565b61094f565b6040516104269190612bd3565b60405180910390f35b610437610991565b6040516104449190612bd3565b60405180910390f35b6104556109e2565b6040516104629190612bd3565b60405180910390f35b61048560048036038101906104809190612b13565b610a32565b6040516104929190612bd3565b60405180910390f35b6104b560048036038101906104b09190612b13565b610a74565b6040516104c29190612bd3565b60405180910390f35b6104e560048036038101906104e09190612bf3565b610ab6565b6040516104f29190612bd3565b60405180910390f35b610503610adf565b6040516105109190612bd3565b60405180910390f35b610533600480360381019061052e9190612c99565b610b24565b6040516105409190612bd3565b60405180910390f35b610563600480360381019061055e9190612b13565b610b40565b6040516105709190612c4b565b60405180910390f35b610593600480360381019061058e9190612d3b565b610b79565b6040516105a09190612bd3565b60405180910390f35b6105c360048036038101906105be9190612bf3565b610bad565b6040516105d09190612bd3565b60405180910390f35b6105f360048036038101906105ee9190612b13565b610bd6565b6040516106009190612c4b565b60405180910390f35b610623600480360381019061061e9190612bf3565b610c0f565b604051610631929190612d9a565b60405180910390f35b610642610c33565b60405161064f9190612bd3565b60405180910390f35b610672600480360381019061066d9190612b13565b610c43565b60405161067f9190612c4b565b60405180910390f35b6106a2600480360381019061069d9190612bf3565b610c7c565b6040516106af9190612bd3565b60405180910390f35b6106d260048036038101906106cd9190612df4565b610ca5565b6040516106df9190612bd3565b60405180910390f35b60605f6106f58584610cd9565b90505f6107028585610cd9565b905061071f61071a8284610d2890919063ffffffff16565b610d70565b925050509392505050565b5f5f6107368484610cd9565b905061074181610f5f565b91505092915050565b6060805f6107588585610cd9565b90505f5f61076583610f72565b9150915061077282610d70565b61077b82610d70565b945094505050509250929050565b606061079d6107988484610cd9565b610d70565b905092915050565b60606107b96107b4848461102a565b610d70565b905092915050565b60605f6107ce8484610cd9565b90506107e16107dc82611112565b610d70565b91505092915050565b60605f6107f78684610cd9565b90505f6108048685610cd9565b90505f6108118686610cd9565b90506108266108218484846111f7565b610d70565b9350505050949350505050565b606061086d681107d5eb5b5ba4d7c660487fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff901b17610d70565b905090565b60605f61087f8484610cd9565b905061089261088d82611333565b610d70565b91505092915050565b5f5f6108a78584610cd9565b90505f6108b48585610cd9565b90506108c9818361139f90919063ffffffff16565b925050509392505050565b60605f6108e18584610cd9565b90505f6108ee8585610cd9565b905061090b61090682846113cd90919063ffffffff16565b610d70565b925050509392505050565b5f5f6109228584610cd9565b90505f61092f8585610cd9565b9050610944818361141590919063ffffffff16565b925050509392505050565b60605f61095c8584610cd9565b90505f6109698585610cd9565b9050610986610981828461144490919063ffffffff16565b610d70565b925050509392505050565b60606109dd600160156109a49190612e71565b600a6109b09190612fd3565b60026109bc919061301d565b6048600160156109cc9190612e71565b6109d590613093565b901b17610d70565b905090565b6060610a2d600160156109f59190612e71565b600a610a019190612fd3565b60486001806015610a129190612e71565b610a1b90613093565b610a2591906130d9565b901b17610d70565b905090565b60605f610a3f8584610cd9565b90505f610a4c8585610cd9565b9050610a69610a6482846115a090919063ffffffff16565b610d70565b925050509392505050565b60605f610a818584610cd9565b90505f610a8e8585610cd9565b9050610aab610aa6828461163190919063ffffffff16565b610d70565b925050509392505050565b60605f610ac38484610cd9565b9050610ad6610ad1826116c2565b610d70565b91505092915050565b6060610b1f60016015610af29190612e71565b600a610afe9190612fd3565b604860016015610b0e9190612e71565b610b1790613093565b901b17610d70565b905090565b6060610b38610b338484611792565b610d70565b905092915050565b5f5f610b4c8584610cd9565b90505f610b598585610cd9565b9050610b6e81836117ba90919063ffffffff16565b925050509392505050565b60605f610b868585610cd9565b9050610ba3610b9e84836117e890919063ffffffff16565b610d70565b9150509392505050565b60605f610bba8484610cd9565b9050610bcd610bc882611a48565b610d70565b91505092915050565b5f5f610be28584610cd9565b90505f610bef8585610cd9565b9050610c048183611a7390919063ffffffff16565b925050509392505050565b5f5f5f610c1c8585610cd9565b9050610c2781611aa1565b92509250509250929050565b6060610c3e5f610d70565b905090565b5f5f610c4f8584610cd9565b90505f610c5c8585610cd9565b9050610c718183611aba90919063ffffffff16565b925050509392505050565b60605f610c898484610cd9565b9050610c9c610c9782611ae9565b610d70565b91505092915050565b60605f610cb28585610cd9565b9050610ccf610cca8483611b2790919063ffffffff16565b610d70565b9150509392505050565b5f5f8312610cfb57610cf48284611c2690919063ffffffff16565b9050610d22565b610d1f610d1a8385610d0c90613093565b611c2690919063ffffffff16565b611a48565b90505b92915050565b5f5f5f610d358585611c45565b91509150610d66610d4582611dc4565b610d4e84611dc4565b610d5891906130d9565b610d6184611dd0565b61102a565b9250505092915050565b6060806060610d7e84611ddd565b93505f610da460016015600a610d949190612fd3565b610d9e9190612e71565b5f61102a565b90505f60016015610db5919061311a565b90505f8190505f5f610dc689611aa1565b91509150610de585610dd78b611ae9565b611a7390919063ffffffff16565b8015610dfa575082610df690613093565b8112155b15610e9b57610e0889611e00565b80975081985050505f8212610e2b5760405180602001604052805f815250610e62565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b87610e6c886120c4565b604051602001610e7e939291906131de565b604051602081830303815290604052975050505050505050610f5a565b610eb6610eb18385610eac90613093565b61102a565b611e00565b80975081985050505f8212610ed95760405180602001604052805f815250610f10565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b87610f1a886120c4565b610f2e8685610f2991906130d9565b612249565b604051602001610f419493929190613263565b6040516020818303038152906040529750505050505050505b919050565b5f5f610f6a83611dc4565b149050919050565b5f5f5f610f7e84611ddd565b90505f5f610f8b83611aa1565b915091505f8203610fa4575f5f94509450505050611025565b5f8112610fb957825f94509450505050611025565b5f816015610fc791906130d9565b1215610fdb575f8394509450505050611025565b5f81610fe690613093565b600a610ff29190612fd3565b9050611009818461100391906132e3565b5f61102a565b955061101e86856113cd90919063ffffffff16565b9450505050505b915091565b5f5f830361103a575f905061110c565b5f5f841215611052578361104d90613093565b611054565b835b90505b60016015600a6110679190612fd3565b6110719190612e71565b8111156110aa57600a8461108591906132e3565b935060018361109491906130d9565b9250600a816110a3919061334b565b9050611057565b5b600160156110b99190612e71565b600a6110c59190612fd3565b8110156110fe57600a846110d9919061301d565b93506001836110e8919061311a565b9250600a816110f7919061337b565b90506110ab565b6111088484611792565b9150505b92915050565b5f5f611155671ff46cf1450516f460487fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee901b17846115a090919063ffffffff16565b90505f5f61116283610f72565b915091505f6111b06111ab671ff46cf1450516f460487fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee901b178461163190919063ffffffff16565b6122d5565b90505f6111bc826122e8565b90505f60126111d45f876124d290919063ffffffff16565b6111de919061311a565b90506111ea828261102a565b9650505050505050919050565b5f5f5f90505f61120686611dc4565b121561121c5761121585611a48565b9450801590505b5f61122685611dc4565b121561123c5761123584611a48565b9350801590505b5f61124684611dc4565b121561125c5761125583611a48565b9250801590505b5f61126686611ddd565b90505f61127286611ddd565b90505f61127e86611ddd565b90505f61128a84611dc4565b90505f61129684611dc4565b90505f6112a284611dc4565b90505f876112c4576112bf8383866125479092919063ffffffff16565b6112e3565b6112d98383866125479092919063ffffffff16565b6112e290613093565b5b90505f6112ef86611dd0565b6112f888611dd0565b6113018a611dd0565b61130b91906130d9565b611315919061311a565b9050611321828261102a565b99505050505050505050509392505050565b5f611398611393600160156113489190612e71565b600a6113549190612fd3565b6002611360919061301d565b6048600160156113709190612e71565b61137990613093565b901b17611385856116c2565b6115a090919063ffffffff16565b611112565b9050919050565b5f5f5f6113ac8585611c45565b915091506113b981611dc4565b6113c283611dc4565b149250505092915050565b5f5f5f6113da8585611c45565b9150915061140b6113ea82611dc4565b6113f384611dc4565b6113fd919061311a565b61140684611dd0565b61102a565b9250505092915050565b5f5f5f6114228585611c45565b9150915061142f81611dc4565b61143883611dc4565b13159250505092915050565b5f5f61144f84611ddd565b90505f61145b84611dc4565b0361149e576001601561146e9190612e71565b600a61147a9190612fd3565b60486001601561148a9190612e71565b61149390613093565b901b1791505061159a565b6114e6600160156114af9190612e71565b600a6114bb9190612fd3565b6048600160156114cb9190612e71565b6114d490613093565b901b178261139f90919063ffffffff16565b1561152957600160156114f99190612e71565b600a6115059190612fd3565b6048600160156115159190612e71565b61151e90613093565b901b1791505061159a565b5f61153382611dc4565b13611573576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161156a90613406565b60405180910390fd5b61159661159184611583846116c2565b61163190919063ffffffff16565b611112565b9150505b92915050565b5f5f6115ab84611ddd565b90505f6115b784611ddd565b90505f6115c383611dc4565b90505f6115cf83611dc4565b9050611625816015600a6115e39190612fd3565b846115ee919061301d565b6115f891906132e3565b601561160386611dd0565b61160c88611dd0565b611616919061311a565b611620919061311a565b61102a565b94505050505092915050565b5f5f61163c84611ddd565b90505f61164884611ddd565b90505f61165483611dc4565b90505f61166083611dc4565b90506116b66015600a6116739190612fd3565b828461167f919061301d565b61168991906132e3565b61169285611dd0565b61169b87611dd0565b60156116a791906130d9565b6116b191906130d9565b61102a565b94505050505092915050565b5f5f6116cd83611ddd565b90505f5f6116da83611aa1565b915091505f8213611720576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016117179061346e565b60405180910390fd5b5f671ff46cf1450516f482611735919061301d565b611751670de0b6b3a76400008561174c919061301d565b6125ff565b61175b91906130d9565b9050611787817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee61102a565b945050505050919050565b5f5f600160486001901b6117a69190612e71565b8416604884901b1790508091505092915050565b5f5f5f6117c78585611c45565b915091506117d481611dc4565b6117dd83611dc4565b139250505092915050565b5f5f6117f384611dc4565b90505f83148061180257505f81145b156118105783915050611a42565b5f8390505f8290505f8561182388611dd0565b61182d91906130d9565b90505f83131561190e575b6010831261186957662386f26fc100008261185391906132e3565b9150601083611862919061311a565b9250611838565b60088312611893576305f5e1008261188191906132e3565b9150600883611890919061311a565b92505b600483126118bb57612710826118a991906132e3565b91506004836118b8919061311a565b92505b600283126118e2576064826118d091906132e3565b91506002836118df919061311a565b92505b6001831261190957600a826118f791906132e3565b9150600183611906919061311a565b92505b611a31565b8261191890613093565b9250601583131561195e576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611955906134d6565b60405180910390fd5b5b6010831261199057662386f26fc100008261197a919061301d565b9150601083611989919061311a565b925061195f565b600883126119ba576305f5e100826119a8919061301d565b91506008836119b7919061311a565b92505b600483126119e257612710826119d0919061301d565b91506004836119df919061311a565b92505b60028312611a09576064826119f7919061301d565b9150600283611a06919061311a565b92505b60018312611a3057600a82611a1e919061301d565b9150600183611a2d919061311a565b92505b5b611a3b8282611792565b9450505050505b92915050565b5f611a6c611a5583611dc4565b611a5e90613093565b611a6784611dd0565b611792565b9050919050565b5f5f5f611a808585611c45565b91509150611a8d81611dc4565b611a9683611dc4565b129250505092915050565b5f5f5f8390508060080b9250604881901d915050915091565b5f5f5f611ac78585611c45565b91509150611ad481611dc4565b611add83611dc4565b12159250505092915050565b5f5f5f611af584611aa1565b915091505f8212611b0a578392505050611b22565b611b1d82611b1790613093565b82611792565b925050505b919050565b5f5f611b3284611dc4565b03611b3f575f9050611c20565b60158210611b5757611b5083611ddd565b9050611c20565b5f611b6184611ddd565b90505f836015611b719190612e71565b600a611b7d9190612fd3565b90505f611b8983611dc4565b90505f8282611b9891906132e3565b90505f8383611ba791906134f4565b905083600282611bb7919061301d565b12611bcb578180611bc790613524565b9250505b83611bd590613093565b600282611be2919061301d565b13611bf6578180611bf29061356b565b9250505b5f8483611c03919061301d565b9050611c1781611c1288611dd0565b611792565b96505050505050505b92915050565b5f611c3d838360ff16611c3890613093565b61102a565b905092915050565b5f5f5f5f611c5286611aa1565b915091505f5f611c6187611aa1565b915091505f84148015611c7357505f82145b15611c87575f5f9550955050505050611dbd565b5f8403611caf57611c985f82611792565b611ca28383611792565b9550955050505050611dbd565b5f8203611cd757611cc08484611792565b611cca5f85611792565b9550955050505050611dbd565b5f611ce189611ddd565b90505f611ced89611ddd565b9050611cf882611dc4565b9550611d0382611dd0565b9450611d0e81611dc4565b9350611d1981611dd0565b92505f8386611d28919061311a565b90505f8112611d70576015811315611d555782611d455f88611792565b9850985050505050505050611dbd565b82611d6083836117e8565b9850985050505050505050611dbd565b601581611d7c90613093565b1315611d9d57611d8c5f85611792565b829850985050505050505050611dbd565b611db08382611dab90613093565b6117e8565b8298509850505050505050505b9250929050565b5f8160080b9050919050565b5f604882901d9050919050565b5f5f5f611de984611aa1565b91509150611df7828261102a565b92505050919050565b6060805f611e0d84611ddd565b90505f5f611e1a83610f72565b9150915060605f611e2a84611ae9565b90505f5f611e3783611aa1565b915091505f8203611e7f576040518060400160405280600181526020017f30000000000000000000000000000000000000000000000000000000000000008152509350611e99565b5f611e8a845f612858565b9050611e9581612910565b9450505b60605f611ea587611ae9565b90505f5f611eb283611aa1565b915091505f8203611efa576040518060400160405280600181526020017f300000000000000000000000000000000000000000000000000000000000000081525093506120ae565b5f611f1c5f841215611f155783611f1090613093565b611f17565b835b612910565b90505f82611f2990613093565b90508067ffffffffffffffff811115611f4557611f446135b2565b5b6040519080825280601f01601f191660200182016040528015611f775781602001600182028036833780820191505090505b5095505f5f90505b818110156120aa57825181101561202357828160018551611fa09190612e71565b611faa9190612e71565b81518110611fbb57611fba6135df565b5b602001015160f81c60f81b8782600185611fd59190612e71565b611fdf9190612e71565b81518110611ff057611fef6135df565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a90535061209d565b7f300000000000000000000000000000000000000000000000000000000000000087826001856120539190612e71565b61205d9190612e71565b8151811061206e5761206d6135df565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053505b8080600101915050611f7f565b5050505b87849c509c505050505050505050505050915091565b60605f600183516120d59190612e71565b90505b5f8111801561214557507f3000000000000000000000000000000000000000000000000000000000000000838281518110612116576121156135df565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b1561215d5780806121559061360c565b9150506120d8565b5f60018261216b9190613633565b67ffffffffffffffff811115612184576121836135b2565b5b6040519080825280601f01601f1916602001820160405280156121b65781602001600182028036833780820191505090505b5090505f5f90505b6001836121cb9190613633565b81101561223e578481815181106121e5576121e46135df565b5b602001015160f81c60f81b828281518110612203576122026135df565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a90535080806001019150506121be565b508092505050919050565b60605f82126122665760405180602001604052805f81525061229d565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b6122ae6122a984612a48565b612910565b6040516020016122bf9291906136aa565b6040516020818303038152906040529050919050565b5f6122e18260126124d2565b9050919050565b5f7ffffffffffffffffffffffffffffffffffffffffffffffffdc0d0570925a462d78213156124cd57680755bf798b4a1bf1e5821261232e5763a37bfec95f526004601cfd5b6503782dace9d9604e83901b81612348576123476132b6565b5b0591505f60606b8000000000000000000000006bb17217f7d1cf79abc9e3b398606086901b8161237b5761237a6132b6565b5b0501901d90506bb17217f7d1cf79abc9e3b3988102830392505f6c10fe68e7fd37d0007b713f7650840190506d02d16720577bd19bf614176fe9ea6060858302901d0190505f6d04a4fd9f2a8b96949216d2255a6c8583010390506e0587f503bb6ea29d25fcb7401964506060838302901d01905079d835ebba824c98fb31b83b2ca45c0000000000000000000000008582020190505f6c240c330e9fb2d9cbaf0fd5aafc860390506d0277594991cfc85f6e2461837cd96060878302901d0190506d1a521255e34f6a5061b25ef1c9c46060878302901d0390506db1bbb201f443cf962f1a1d3db4a56060878302901d0190506e02c72388d9f74f51a9331fed693f156060878302901d0390506e05180bb14799ab47a8a8cb2a527d576060878302901d01905080820594508360c30374029d9dc38563c32e5c2f6dc192ee70ef65f9978af38602901c9450505050505b919050565b5f5f5f6124de85611aa1565b915091508360ff16816124f191906130d9565b90505f811261251b5780600a6125079190612fd3565b82612512919061301d565b92505050612541565b8061252590613093565b600a6125319190612fd3565b8261253c91906132e3565b925050505b92915050565b5f82840290506001156125f857818385830414851517026125f2575f198385098181108201810383858709845f03851682861161258b5763ae47f7025f526004601cfd5b808604955085600302600218808702600203810290508087026002038102905080870260020381029050808702600203810290508087026002038102905080818802600203028284880304600184855f0304018886118703021702955050505050506125f8565b81810490505b9392505050565b5f816fffffffffffffffffffffffffffffffff1060071b905081811c67ffffffffffffffff1060061b8117905081811c63ffffffff1060051b8117905081811c61ffff1060041b8117905081811c60ff1060031b811790505f821361266b57631615e6385f526004601cfd5b7ff8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff6f8421084210842108cc6318c6db6d54be83831c1c601f161a8118905081811b609f1c91506c8c3f38e95a6b1ff2ab1c3b3437828384856c29508e458543d8aa4df2abee78010260601d6d0139601a2efabe717e604cbb4894010260601d6d02247f7a7b6594320649aa03aba1010260601d036d02384773bdf1ac5676facced609183820260601d0390506cb9a025d814b29c212b8b1a07ce83820260601d0390506c0a09507084cc699bb0e71ea86a60601b838202039050826c465772b2bbbb5f824b15207a300180840260601d6d0388eaa27412d5aca026815d636e01905080840260601d6d0df99ac502031bf953eff472fdcc01905080840260601d6d13cdffb29d51d99322bdff5f221101905080840260601d6d0a0f742023def783a307a986912e01905080840260601d6d01920d8043ca89b5239253284e4201905080840260601d6c0b7a86d7375468fac667a0a527019050808205915081711340daa0d5f769dba1915cef59f0815a55060291508183609f037d0267a36c0c95b3975ab3ee5b203a7614a3f75373f047d803ae7b6687f2b302019150817d57115e47018c7177eebf7cd370a3356a1b7863008a5ae8028c72b88642840191508160ae1d92505050919050565b5f5f5f61286485611aa1565b915091505f8212156128ab576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016128a290613717565b60405180910390fd5b8360ff16816128ba91906130d9565b90505f81126128e45780600a6128d09190612fd3565b826128db919061337b565b9250505061290a565b806128ee90613093565b600a6128fa9190612fd3565b82612905919061334b565b925050505b92915050565b60605f8203612956576040518060400160405280600181526020017f30000000000000000000000000000000000000000000000000000000000000008152509050612a43565b5f61296083612a5d565b60ff1690505f8167ffffffffffffffff8111156129805761297f6135b2565b5b6040519080825280601f01601f1916602001820160405280156129b25781602001600182028036833780820191505090505b5090505b5f8414612a3d576001826129ca9190612e71565b9150600a846129d99190613735565b60306129e59190613633565b60f81b8183815181106129fb576129fa6135df565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a905350600a84612a36919061334b565b93506129b6565b80925050505b919050565b5f60ff82901d60ff83901d8301189050919050565b5f5f8203612a6e5760019050612aa1565b5f5f90505b5f8314612a9c578080612a8590613765565b915050600a83612a95919061334b565b9250612a73565b809150505b919050565b5f5ffd5b5f819050919050565b612abc81612aaa565b8114612ac6575f5ffd5b50565b5f81359050612ad781612ab3565b92915050565b5f60ff82169050919050565b612af281612add565b8114612afc575f5ffd5b50565b5f81359050612b0d81612ae9565b92915050565b5f5f5f60608486031215612b2a57612b29612aa6565b5b5f612b3786828701612ac9565b9350506020612b4886828701612ac9565b9250506040612b5986828701612aff565b9150509250925092565b5f81519050919050565b5f82825260208201905092915050565b8281835e5f83830152505050565b5f601f19601f8301169050919050565b5f612ba582612b63565b612baf8185612b6d565b9350612bbf818560208601612b7d565b612bc881612b8b565b840191505092915050565b5f6020820190508181035f830152612beb8184612b9b565b905092915050565b5f5f60408385031215612c0957612c08612aa6565b5b5f612c1685828601612ac9565b9250506020612c2785828601612aff565b9150509250929050565b5f8115159050919050565b612c4581612c31565b82525050565b5f602082019050612c5e5f830184612c3c565b92915050565b5f6040820190508181035f830152612c7c8185612b9b565b90508181036020830152612c908184612b9b565b90509392505050565b5f5f60408385031215612caf57612cae612aa6565b5b5f612cbc85828601612ac9565b9250506020612ccd85828601612ac9565b9150509250929050565b5f5f5f5f60808587031215612cef57612cee612aa6565b5b5f612cfc87828801612ac9565b9450506020612d0d87828801612ac9565b9350506040612d1e87828801612ac9565b9250506060612d2f87828801612aff565b91505092959194509250565b5f5f5f60608486031215612d5257612d51612aa6565b5b5f612d5f86828701612ac9565b9350506020612d7086828701612aff565b9250506040612d8186828701612ac9565b9150509250925092565b612d9481612aaa565b82525050565b5f604082019050612dad5f830185612d8b565b612dba6020830184612d8b565b9392505050565b5f819050919050565b612dd381612dc1565b8114612ddd575f5ffd5b50565b5f81359050612dee81612dca565b92915050565b5f5f5f60608486031215612e0b57612e0a612aa6565b5b5f612e1886828701612ac9565b9350506020612e2986828701612aff565b9250506040612e3a86828701612de0565b9150509250925092565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f612e7b82612dc1565b9150612e8683612dc1565b9250828203905081811115612e9e57612e9d612e44565b5b92915050565b5f8160011c9050919050565b5f5f8291508390505b6001851115612ef957808604811115612ed557612ed4612e44565b5b6001851615612ee45780820291505b8081029050612ef285612ea4565b9450612eb9565b94509492505050565b5f82612f115760019050612fcc565b81612f1e575f9050612fcc565b8160018114612f345760028114612f3e57612f6d565b6001915050612fcc565b60ff841115612f5057612f4f612e44565b5b8360020a915084821115612f6757612f66612e44565b5b50612fcc565b5060208310610133831016604e8410600b8410161715612fa25782820a905083811115612f9d57612f9c612e44565b5b612fcc565b612faf8484846001612eb0565b92509050818404811115612fc657612fc5612e44565b5b81810290505b9392505050565b5f612fdd82612dc1565b9150612fe883612dc1565b92506130157fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8484612f02565b905092915050565b5f61302782612aaa565b915061303283612aaa565b925082820261304081612aaa565b91507f800000000000000000000000000000000000000000000000000000000000000084145f8412161561307757613076612e44565b5b828205841483151761308c5761308b612e44565b5b5092915050565b5f61309d82612aaa565b91507f800000000000000000000000000000000000000000000000000000000000000082036130cf576130ce612e44565b5b815f039050919050565b5f6130e382612aaa565b91506130ee83612aaa565b92508282019050828112155f8312168382125f84121516171561311457613113612e44565b5b92915050565b5f61312482612aaa565b915061312f83612aaa565b925082820390508181125f8412168282135f85121516171561315457613153612e44565b5b92915050565b5f81905092915050565b5f61316e82612b63565b613178818561315a565b9350613188818560208601612b7d565b80840191505092915050565b7f2e000000000000000000000000000000000000000000000000000000000000005f82015250565b5f6131c860018361315a565b91506131d382613194565b600182019050919050565b5f6131e98286613164565b91506131f58285613164565b9150613200826131bc565b915061320c8284613164565b9150819050949350505050565b7f65000000000000000000000000000000000000000000000000000000000000005f82015250565b5f61324d60018361315a565b915061325882613219565b600182019050919050565b5f61326e8287613164565b915061327a8286613164565b9150613285826131bc565b91506132918285613164565b915061329c82613241565b91506132a88284613164565b915081905095945050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f6132ed82612aaa565b91506132f883612aaa565b925082613308576133076132b6565b5b60015f0383147f8000000000000000000000000000000000000000000000000000000000000000831416156133405761333f612e44565b5b828205905092915050565b5f61335582612dc1565b915061336083612dc1565b9250826133705761336f6132b6565b5b828204905092915050565b5f61338582612dc1565b915061339083612dc1565b925082820261339e81612dc1565b915082820484148315176133b5576133b4612e44565b5b5092915050565b7f706f773a2062617365206d75737420626520706f7369746976650000000000005f82015250565b5f6133f0601a83612b6d565b91506133fb826133bc565b602082019050919050565b5f6020820190508181035f83015261341d816133e4565b9050919050565b7f6c6f67206e6f6e2d706f736974697665000000000000000000000000000000005f82015250565b5f613458601083612b6d565b915061346382613424565b602082019050919050565b5f6020820190508181035f8301526134858161344c565b9050919050565b7f73686966743a207c697c20746f6f206c617267650000000000000000000000005f82015250565b5f6134c0601483612b6d565b91506134cb8261348c565b602082019050919050565b5f6020820190508181035f8301526134ed816134b4565b9050919050565b5f6134fe82612aaa565b915061350983612aaa565b925082613519576135186132b6565b5b828207905092915050565b5f61352e82612aaa565b91507f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036135605761355f612e44565b5b600182019050919050565b5f61357582612aaa565b91507f800000000000000000000000000000000000000000000000000000000000000082036135a7576135a6612e44565b5b600182039050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f61361682612dc1565b91505f820361362857613627612e44565b5b600182039050919050565b5f61363d82612dc1565b915061364883612dc1565b92508282019050808211156136605761365f612e44565b5b92915050565b5f81519050919050565b5f81905092915050565b5f61368482613666565b61368e8185613670565b935061369e818560208601612b7d565b80840191505092915050565b5f6136b58285613164565b91506136c1828461367a565b91508190509392505050565b7f56616c7565206d757374206265206e6f6e2d6e656761746976650000000000005f82015250565b5f613701601a83612b6d565b915061370c826136cd565b602082019050919050565b5f6020820190508181035f83015261372e816136f5565b9050919050565b5f61373f82612dc1565b915061374a83612dc1565b92508261375a576137596132b6565b5b828206905092915050565b5f61376f82612add565b915060ff820361378257613781612e44565b5b60018201905091905056fea26469706673582212204ba42decee95608383642c31be3e9e18576c0b560566a2675f62e6912f6cdd6364736f6c634300081e0033"
            },
            "deployedBytecode": {
              "object": "608060405234801561000f575f5ffd5b50600436106101cc575f3560e01c8063643ceff911610102578063a2f295c5116100a0578063bc1b392d1161006f578063bc1b392d1461063a578063c753cb3514610658578063df65245d14610688578063f81f8936146106b8576101cc565b8063a2f295c514610579578063a7bfcd0d146105a9578063ba93bc3f146105d9578063bbbd0d3214610609576101cc565b80638cf45091116100dc5780638cf45091146104cb578063901717d1146104fb57806392c1eb9e1461051957806394fd4ee714610549576101cc565b8063643ceff91461044d578063799f54461461046b5780638535829a1461049b576101cc565b80632dd9868d1161016f5780635a260d7f116101495780635a260d7f1461039f5780635caea0ac146103cf5780635d6e8d1c146103ff5780635fdf05d71461042f576101cc565b80632dd9868d1461032157806348f5294c1461033f5780634acc886a1461036f576101cc565b80631b1e7001116101ab5780631b1e7001146102615780631e18b7b214610291578063250ef6e8146102c157806328a4d194146102f1576101cc565b80621f35f5146101d05780630552e844146102005780630a08167214610230575b5f5ffd5b6101ea60048036038101906101e59190612b13565b6106e8565b6040516101f79190612bd3565b60405180910390f35b61021a60048036038101906102159190612bf3565b61072a565b6040516102279190612c4b565b60405180910390f35b61024a60048036038101906102459190612bf3565b61074a565b604051610258929190612c64565b60405180910390f35b61027b60048036038101906102769190612bf3565b610789565b6040516102889190612bd3565b60405180910390f35b6102ab60048036038101906102a69190612c99565b6107a5565b6040516102b89190612bd3565b60405180910390f35b6102db60048036038101906102d69190612bf3565b6107c1565b6040516102e89190612bd3565b60405180910390f35b61030b60048036038101906103069190612cd7565b6107ea565b6040516103189190612bd3565b60405180910390f35b610329610833565b6040516103369190612bd3565b60405180910390f35b61035960048036038101906103549190612bf3565b610872565b6040516103669190612bd3565b60405180910390f35b61038960048036038101906103849190612b13565b61089b565b6040516103969190612c4b565b60405180910390f35b6103b960048036038101906103b49190612b13565b6108d4565b6040516103c69190612bd3565b60405180910390f35b6103e960048036038101906103e49190612b13565b610916565b6040516103f69190612c4b565b60405180910390f35b61041960048036038101906104149190612b13565b61094f565b6040516104269190612bd3565b60405180910390f35b610437610991565b6040516104449190612bd3565b60405180910390f35b6104556109e2565b6040516104629190612bd3565b60405180910390f35b61048560048036038101906104809190612b13565b610a32565b6040516104929190612bd3565b60405180910390f35b6104b560048036038101906104b09190612b13565b610a74565b6040516104c29190612bd3565b60405180910390f35b6104e560048036038101906104e09190612bf3565b610ab6565b6040516104f29190612bd3565b60405180910390f35b610503610adf565b6040516105109190612bd3565b60405180910390f35b610533600480360381019061052e9190612c99565b610b24565b6040516105409190612bd3565b60405180910390f35b610563600480360381019061055e9190612b13565b610b40565b6040516105709190612c4b565b60405180910390f35b610593600480360381019061058e9190612d3b565b610b79565b6040516105a09190612bd3565b60405180910390f35b6105c360048036038101906105be9190612bf3565b610bad565b6040516105d09190612bd3565b60405180910390f35b6105f360048036038101906105ee9190612b13565b610bd6565b6040516106009190612c4b565b60405180910390f35b610623600480360381019061061e9190612bf3565b610c0f565b604051610631929190612d9a565b60405180910390f35b610642610c33565b60405161064f9190612bd3565b60405180910390f35b610672600480360381019061066d9190612b13565b610c43565b60405161067f9190612c4b565b60405180910390f35b6106a2600480360381019061069d9190612bf3565b610c7c565b6040516106af9190612bd3565b60405180910390f35b6106d260048036038101906106cd9190612df4565b610ca5565b6040516106df9190612bd3565b60405180910390f35b60605f6106f58584610cd9565b90505f6107028585610cd9565b905061071f61071a8284610d2890919063ffffffff16565b610d70565b925050509392505050565b5f5f6107368484610cd9565b905061074181610f5f565b91505092915050565b6060805f6107588585610cd9565b90505f5f61076583610f72565b9150915061077282610d70565b61077b82610d70565b945094505050509250929050565b606061079d6107988484610cd9565b610d70565b905092915050565b60606107b96107b4848461102a565b610d70565b905092915050565b60605f6107ce8484610cd9565b90506107e16107dc82611112565b610d70565b91505092915050565b60605f6107f78684610cd9565b90505f6108048685610cd9565b90505f6108118686610cd9565b90506108266108218484846111f7565b610d70565b9350505050949350505050565b606061086d681107d5eb5b5ba4d7c660487fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff901b17610d70565b905090565b60605f61087f8484610cd9565b905061089261088d82611333565b610d70565b91505092915050565b5f5f6108a78584610cd9565b90505f6108b48585610cd9565b90506108c9818361139f90919063ffffffff16565b925050509392505050565b60605f6108e18584610cd9565b90505f6108ee8585610cd9565b905061090b61090682846113cd90919063ffffffff16565b610d70565b925050509392505050565b5f5f6109228584610cd9565b90505f61092f8585610cd9565b9050610944818361141590919063ffffffff16565b925050509392505050565b60605f61095c8584610cd9565b90505f6109698585610cd9565b9050610986610981828461144490919063ffffffff16565b610d70565b925050509392505050565b60606109dd600160156109a49190612e71565b600a6109b09190612fd3565b60026109bc919061301d565b6048600160156109cc9190612e71565b6109d590613093565b901b17610d70565b905090565b6060610a2d600160156109f59190612e71565b600a610a019190612fd3565b60486001806015610a129190612e71565b610a1b90613093565b610a2591906130d9565b901b17610d70565b905090565b60605f610a3f8584610cd9565b90505f610a4c8585610cd9565b9050610a69610a6482846115a090919063ffffffff16565b610d70565b925050509392505050565b60605f610a818584610cd9565b90505f610a8e8585610cd9565b9050610aab610aa6828461163190919063ffffffff16565b610d70565b925050509392505050565b60605f610ac38484610cd9565b9050610ad6610ad1826116c2565b610d70565b91505092915050565b6060610b1f60016015610af29190612e71565b600a610afe9190612fd3565b604860016015610b0e9190612e71565b610b1790613093565b901b17610d70565b905090565b6060610b38610b338484611792565b610d70565b905092915050565b5f5f610b4c8584610cd9565b90505f610b598585610cd9565b9050610b6e81836117ba90919063ffffffff16565b925050509392505050565b60605f610b868585610cd9565b9050610ba3610b9e84836117e890919063ffffffff16565b610d70565b9150509392505050565b60605f610bba8484610cd9565b9050610bcd610bc882611a48565b610d70565b91505092915050565b5f5f610be28584610cd9565b90505f610bef8585610cd9565b9050610c048183611a7390919063ffffffff16565b925050509392505050565b5f5f5f610c1c8585610cd9565b9050610c2781611aa1565b92509250509250929050565b6060610c3e5f610d70565b905090565b5f5f610c4f8584610cd9565b90505f610c5c8585610cd9565b9050610c718183611aba90919063ffffffff16565b925050509392505050565b60605f610c898484610cd9565b9050610c9c610c9782611ae9565b610d70565b91505092915050565b60605f610cb28585610cd9565b9050610ccf610cca8483611b2790919063ffffffff16565b610d70565b9150509392505050565b5f5f8312610cfb57610cf48284611c2690919063ffffffff16565b9050610d22565b610d1f610d1a8385610d0c90613093565b611c2690919063ffffffff16565b611a48565b90505b92915050565b5f5f5f610d358585611c45565b91509150610d66610d4582611dc4565b610d4e84611dc4565b610d5891906130d9565b610d6184611dd0565b61102a565b9250505092915050565b6060806060610d7e84611ddd565b93505f610da460016015600a610d949190612fd3565b610d9e9190612e71565b5f61102a565b90505f60016015610db5919061311a565b90505f8190505f5f610dc689611aa1565b91509150610de585610dd78b611ae9565b611a7390919063ffffffff16565b8015610dfa575082610df690613093565b8112155b15610e9b57610e0889611e00565b80975081985050505f8212610e2b5760405180602001604052805f815250610e62565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b87610e6c886120c4565b604051602001610e7e939291906131de565b604051602081830303815290604052975050505050505050610f5a565b610eb6610eb18385610eac90613093565b61102a565b611e00565b80975081985050505f8212610ed95760405180602001604052805f815250610f10565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b87610f1a886120c4565b610f2e8685610f2991906130d9565b612249565b604051602001610f419493929190613263565b6040516020818303038152906040529750505050505050505b919050565b5f5f610f6a83611dc4565b149050919050565b5f5f5f610f7e84611ddd565b90505f5f610f8b83611aa1565b915091505f8203610fa4575f5f94509450505050611025565b5f8112610fb957825f94509450505050611025565b5f816015610fc791906130d9565b1215610fdb575f8394509450505050611025565b5f81610fe690613093565b600a610ff29190612fd3565b9050611009818461100391906132e3565b5f61102a565b955061101e86856113cd90919063ffffffff16565b9450505050505b915091565b5f5f830361103a575f905061110c565b5f5f841215611052578361104d90613093565b611054565b835b90505b60016015600a6110679190612fd3565b6110719190612e71565b8111156110aa57600a8461108591906132e3565b935060018361109491906130d9565b9250600a816110a3919061334b565b9050611057565b5b600160156110b99190612e71565b600a6110c59190612fd3565b8110156110fe57600a846110d9919061301d565b93506001836110e8919061311a565b9250600a816110f7919061337b565b90506110ab565b6111088484611792565b9150505b92915050565b5f5f611155671ff46cf1450516f460487fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee901b17846115a090919063ffffffff16565b90505f5f61116283610f72565b915091505f6111b06111ab671ff46cf1450516f460487fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee901b178461163190919063ffffffff16565b6122d5565b90505f6111bc826122e8565b90505f60126111d45f876124d290919063ffffffff16565b6111de919061311a565b90506111ea828261102a565b9650505050505050919050565b5f5f5f90505f61120686611dc4565b121561121c5761121585611a48565b9450801590505b5f61122685611dc4565b121561123c5761123584611a48565b9350801590505b5f61124684611dc4565b121561125c5761125583611a48565b9250801590505b5f61126686611ddd565b90505f61127286611ddd565b90505f61127e86611ddd565b90505f61128a84611dc4565b90505f61129684611dc4565b90505f6112a284611dc4565b90505f876112c4576112bf8383866125479092919063ffffffff16565b6112e3565b6112d98383866125479092919063ffffffff16565b6112e290613093565b5b90505f6112ef86611dd0565b6112f888611dd0565b6113018a611dd0565b61130b91906130d9565b611315919061311a565b9050611321828261102a565b99505050505050505050509392505050565b5f611398611393600160156113489190612e71565b600a6113549190612fd3565b6002611360919061301d565b6048600160156113709190612e71565b61137990613093565b901b17611385856116c2565b6115a090919063ffffffff16565b611112565b9050919050565b5f5f5f6113ac8585611c45565b915091506113b981611dc4565b6113c283611dc4565b149250505092915050565b5f5f5f6113da8585611c45565b9150915061140b6113ea82611dc4565b6113f384611dc4565b6113fd919061311a565b61140684611dd0565b61102a565b9250505092915050565b5f5f5f6114228585611c45565b9150915061142f81611dc4565b61143883611dc4565b13159250505092915050565b5f5f61144f84611ddd565b90505f61145b84611dc4565b0361149e576001601561146e9190612e71565b600a61147a9190612fd3565b60486001601561148a9190612e71565b61149390613093565b901b1791505061159a565b6114e6600160156114af9190612e71565b600a6114bb9190612fd3565b6048600160156114cb9190612e71565b6114d490613093565b901b178261139f90919063ffffffff16565b1561152957600160156114f99190612e71565b600a6115059190612fd3565b6048600160156115159190612e71565b61151e90613093565b901b1791505061159a565b5f61153382611dc4565b13611573576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161156a90613406565b60405180910390fd5b61159661159184611583846116c2565b61163190919063ffffffff16565b611112565b9150505b92915050565b5f5f6115ab84611ddd565b90505f6115b784611ddd565b90505f6115c383611dc4565b90505f6115cf83611dc4565b9050611625816015600a6115e39190612fd3565b846115ee919061301d565b6115f891906132e3565b601561160386611dd0565b61160c88611dd0565b611616919061311a565b611620919061311a565b61102a565b94505050505092915050565b5f5f61163c84611ddd565b90505f61164884611ddd565b90505f61165483611dc4565b90505f61166083611dc4565b90506116b66015600a6116739190612fd3565b828461167f919061301d565b61168991906132e3565b61169285611dd0565b61169b87611dd0565b60156116a791906130d9565b6116b191906130d9565b61102a565b94505050505092915050565b5f5f6116cd83611ddd565b90505f5f6116da83611aa1565b915091505f8213611720576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016117179061346e565b60405180910390fd5b5f671ff46cf1450516f482611735919061301d565b611751670de0b6b3a76400008561174c919061301d565b6125ff565b61175b91906130d9565b9050611787817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee61102a565b945050505050919050565b5f5f600160486001901b6117a69190612e71565b8416604884901b1790508091505092915050565b5f5f5f6117c78585611c45565b915091506117d481611dc4565b6117dd83611dc4565b139250505092915050565b5f5f6117f384611dc4565b90505f83148061180257505f81145b156118105783915050611a42565b5f8390505f8290505f8561182388611dd0565b61182d91906130d9565b90505f83131561190e575b6010831261186957662386f26fc100008261185391906132e3565b9150601083611862919061311a565b9250611838565b60088312611893576305f5e1008261188191906132e3565b9150600883611890919061311a565b92505b600483126118bb57612710826118a991906132e3565b91506004836118b8919061311a565b92505b600283126118e2576064826118d091906132e3565b91506002836118df919061311a565b92505b6001831261190957600a826118f791906132e3565b9150600183611906919061311a565b92505b611a31565b8261191890613093565b9250601583131561195e576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611955906134d6565b60405180910390fd5b5b6010831261199057662386f26fc100008261197a919061301d565b9150601083611989919061311a565b925061195f565b600883126119ba576305f5e100826119a8919061301d565b91506008836119b7919061311a565b92505b600483126119e257612710826119d0919061301d565b91506004836119df919061311a565b92505b60028312611a09576064826119f7919061301d565b9150600283611a06919061311a565b92505b60018312611a3057600a82611a1e919061301d565b9150600183611a2d919061311a565b92505b5b611a3b8282611792565b9450505050505b92915050565b5f611a6c611a5583611dc4565b611a5e90613093565b611a6784611dd0565b611792565b9050919050565b5f5f5f611a808585611c45565b91509150611a8d81611dc4565b611a9683611dc4565b129250505092915050565b5f5f5f8390508060080b9250604881901d915050915091565b5f5f5f611ac78585611c45565b91509150611ad481611dc4565b611add83611dc4565b12159250505092915050565b5f5f5f611af584611aa1565b915091505f8212611b0a578392505050611b22565b611b1d82611b1790613093565b82611792565b925050505b919050565b5f5f611b3284611dc4565b03611b3f575f9050611c20565b60158210611b5757611b5083611ddd565b9050611c20565b5f611b6184611ddd565b90505f836015611b719190612e71565b600a611b7d9190612fd3565b90505f611b8983611dc4565b90505f8282611b9891906132e3565b90505f8383611ba791906134f4565b905083600282611bb7919061301d565b12611bcb578180611bc790613524565b9250505b83611bd590613093565b600282611be2919061301d565b13611bf6578180611bf29061356b565b9250505b5f8483611c03919061301d565b9050611c1781611c1288611dd0565b611792565b96505050505050505b92915050565b5f611c3d838360ff16611c3890613093565b61102a565b905092915050565b5f5f5f5f611c5286611aa1565b915091505f5f611c6187611aa1565b915091505f84148015611c7357505f82145b15611c87575f5f9550955050505050611dbd565b5f8403611caf57611c985f82611792565b611ca28383611792565b9550955050505050611dbd565b5f8203611cd757611cc08484611792565b611cca5f85611792565b9550955050505050611dbd565b5f611ce189611ddd565b90505f611ced89611ddd565b9050611cf882611dc4565b9550611d0382611dd0565b9450611d0e81611dc4565b9350611d1981611dd0565b92505f8386611d28919061311a565b90505f8112611d70576015811315611d555782611d455f88611792565b9850985050505050505050611dbd565b82611d6083836117e8565b9850985050505050505050611dbd565b601581611d7c90613093565b1315611d9d57611d8c5f85611792565b829850985050505050505050611dbd565b611db08382611dab90613093565b6117e8565b8298509850505050505050505b9250929050565b5f8160080b9050919050565b5f604882901d9050919050565b5f5f5f611de984611aa1565b91509150611df7828261102a565b92505050919050565b6060805f611e0d84611ddd565b90505f5f611e1a83610f72565b9150915060605f611e2a84611ae9565b90505f5f611e3783611aa1565b915091505f8203611e7f576040518060400160405280600181526020017f30000000000000000000000000000000000000000000000000000000000000008152509350611e99565b5f611e8a845f612858565b9050611e9581612910565b9450505b60605f611ea587611ae9565b90505f5f611eb283611aa1565b915091505f8203611efa576040518060400160405280600181526020017f300000000000000000000000000000000000000000000000000000000000000081525093506120ae565b5f611f1c5f841215611f155783611f1090613093565b611f17565b835b612910565b90505f82611f2990613093565b90508067ffffffffffffffff811115611f4557611f446135b2565b5b6040519080825280601f01601f191660200182016040528015611f775781602001600182028036833780820191505090505b5095505f5f90505b818110156120aa57825181101561202357828160018551611fa09190612e71565b611faa9190612e71565b81518110611fbb57611fba6135df565b5b602001015160f81c60f81b8782600185611fd59190612e71565b611fdf9190612e71565b81518110611ff057611fef6135df565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a90535061209d565b7f300000000000000000000000000000000000000000000000000000000000000087826001856120539190612e71565b61205d9190612e71565b8151811061206e5761206d6135df565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053505b8080600101915050611f7f565b5050505b87849c509c505050505050505050505050915091565b60605f600183516120d59190612e71565b90505b5f8111801561214557507f3000000000000000000000000000000000000000000000000000000000000000838281518110612116576121156135df565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b1561215d5780806121559061360c565b9150506120d8565b5f60018261216b9190613633565b67ffffffffffffffff811115612184576121836135b2565b5b6040519080825280601f01601f1916602001820160405280156121b65781602001600182028036833780820191505090505b5090505f5f90505b6001836121cb9190613633565b81101561223e578481815181106121e5576121e46135df565b5b602001015160f81c60f81b828281518110612203576122026135df565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a90535080806001019150506121be565b508092505050919050565b60605f82126122665760405180602001604052805f81525061229d565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b6122ae6122a984612a48565b612910565b6040516020016122bf9291906136aa565b6040516020818303038152906040529050919050565b5f6122e18260126124d2565b9050919050565b5f7ffffffffffffffffffffffffffffffffffffffffffffffffdc0d0570925a462d78213156124cd57680755bf798b4a1bf1e5821261232e5763a37bfec95f526004601cfd5b6503782dace9d9604e83901b81612348576123476132b6565b5b0591505f60606b8000000000000000000000006bb17217f7d1cf79abc9e3b398606086901b8161237b5761237a6132b6565b5b0501901d90506bb17217f7d1cf79abc9e3b3988102830392505f6c10fe68e7fd37d0007b713f7650840190506d02d16720577bd19bf614176fe9ea6060858302901d0190505f6d04a4fd9f2a8b96949216d2255a6c8583010390506e0587f503bb6ea29d25fcb7401964506060838302901d01905079d835ebba824c98fb31b83b2ca45c0000000000000000000000008582020190505f6c240c330e9fb2d9cbaf0fd5aafc860390506d0277594991cfc85f6e2461837cd96060878302901d0190506d1a521255e34f6a5061b25ef1c9c46060878302901d0390506db1bbb201f443cf962f1a1d3db4a56060878302901d0190506e02c72388d9f74f51a9331fed693f156060878302901d0390506e05180bb14799ab47a8a8cb2a527d576060878302901d01905080820594508360c30374029d9dc38563c32e5c2f6dc192ee70ef65f9978af38602901c9450505050505b919050565b5f5f5f6124de85611aa1565b915091508360ff16816124f191906130d9565b90505f811261251b5780600a6125079190612fd3565b82612512919061301d565b92505050612541565b8061252590613093565b600a6125319190612fd3565b8261253c91906132e3565b925050505b92915050565b5f82840290506001156125f857818385830414851517026125f2575f198385098181108201810383858709845f03851682861161258b5763ae47f7025f526004601cfd5b808604955085600302600218808702600203810290508087026002038102905080870260020381029050808702600203810290508087026002038102905080818802600203028284880304600184855f0304018886118703021702955050505050506125f8565b81810490505b9392505050565b5f816fffffffffffffffffffffffffffffffff1060071b905081811c67ffffffffffffffff1060061b8117905081811c63ffffffff1060051b8117905081811c61ffff1060041b8117905081811c60ff1060031b811790505f821361266b57631615e6385f526004601cfd5b7ff8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff6f8421084210842108cc6318c6db6d54be83831c1c601f161a8118905081811b609f1c91506c8c3f38e95a6b1ff2ab1c3b3437828384856c29508e458543d8aa4df2abee78010260601d6d0139601a2efabe717e604cbb4894010260601d6d02247f7a7b6594320649aa03aba1010260601d036d02384773bdf1ac5676facced609183820260601d0390506cb9a025d814b29c212b8b1a07ce83820260601d0390506c0a09507084cc699bb0e71ea86a60601b838202039050826c465772b2bbbb5f824b15207a300180840260601d6d0388eaa27412d5aca026815d636e01905080840260601d6d0df99ac502031bf953eff472fdcc01905080840260601d6d13cdffb29d51d99322bdff5f221101905080840260601d6d0a0f742023def783a307a986912e01905080840260601d6d01920d8043ca89b5239253284e4201905080840260601d6c0b7a86d7375468fac667a0a527019050808205915081711340daa0d5f769dba1915cef59f0815a55060291508183609f037d0267a36c0c95b3975ab3ee5b203a7614a3f75373f047d803ae7b6687f2b302019150817d57115e47018c7177eebf7cd370a3356a1b7863008a5ae8028c72b88642840191508160ae1d92505050919050565b5f5f5f61286485611aa1565b915091505f8212156128ab576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016128a290613717565b60405180910390fd5b8360ff16816128ba91906130d9565b90505f81126128e45780600a6128d09190612fd3565b826128db919061337b565b9250505061290a565b806128ee90613093565b600a6128fa9190612fd3565b82612905919061334b565b925050505b92915050565b60605f8203612956576040518060400160405280600181526020017f30000000000000000000000000000000000000000000000000000000000000008152509050612a43565b5f61296083612a5d565b60ff1690505f8167ffffffffffffffff8111156129805761297f6135b2565b5b6040519080825280601f01601f1916602001820160405280156129b25781602001600182028036833780820191505090505b5090505b5f8414612a3d576001826129ca9190612e71565b9150600a846129d99190613735565b60306129e59190613633565b60f81b8183815181106129fb576129fa6135df565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a905350600a84612a36919061334b565b93506129b6565b80925050505b919050565b5f60ff82901d60ff83901d8301189050919050565b5f5f8203612a6e5760019050612aa1565b5f5f90505b5f8314612a9c578080612a8590613765565b915050600a83612a95919061334b565b9250612a73565b809150505b919050565b5f5ffd5b5f819050919050565b612abc81612aaa565b8114612ac6575f5ffd5b50565b5f81359050612ad781612ab3565b92915050565b5f60ff82169050919050565b612af281612add565b8114612afc575f5ffd5b50565b5f81359050612b0d81612ae9565b92915050565b5f5f5f60608486031215612b2a57612b29612aa6565b5b5f612b3786828701612ac9565b9350506020612b4886828701612ac9565b9250506040612b5986828701612aff565b9150509250925092565b5f81519050919050565b5f82825260208201905092915050565b8281835e5f83830152505050565b5f601f19601f8301169050919050565b5f612ba582612b63565b612baf8185612b6d565b9350612bbf818560208601612b7d565b612bc881612b8b565b840191505092915050565b5f6020820190508181035f830152612beb8184612b9b565b905092915050565b5f5f60408385031215612c0957612c08612aa6565b5b5f612c1685828601612ac9565b9250506020612c2785828601612aff565b9150509250929050565b5f8115159050919050565b612c4581612c31565b82525050565b5f602082019050612c5e5f830184612c3c565b92915050565b5f6040820190508181035f830152612c7c8185612b9b565b90508181036020830152612c908184612b9b565b90509392505050565b5f5f60408385031215612caf57612cae612aa6565b5b5f612cbc85828601612ac9565b9250506020612ccd85828601612ac9565b9150509250929050565b5f5f5f5f60808587031215612cef57612cee612aa6565b5b5f612cfc87828801612ac9565b9450506020612d0d87828801612ac9565b9350506040612d1e87828801612ac9565b9250506060612d2f87828801612aff565b91505092959194509250565b5f5f5f60608486031215612d5257612d51612aa6565b5b5f612d5f86828701612ac9565b9350506020612d7086828701612aff565b9250506040612d8186828701612ac9565b9150509250925092565b612d9481612aaa565b82525050565b5f604082019050612dad5f830185612d8b565b612dba6020830184612d8b565b9392505050565b5f819050919050565b612dd381612dc1565b8114612ddd575f5ffd5b50565b5f81359050612dee81612dca565b92915050565b5f5f5f60608486031215612e0b57612e0a612aa6565b5b5f612e1886828701612ac9565b9350506020612e2986828701612aff565b9250506040612e3a86828701612de0565b9150509250925092565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f612e7b82612dc1565b9150612e8683612dc1565b9250828203905081811115612e9e57612e9d612e44565b5b92915050565b5f8160011c9050919050565b5f5f8291508390505b6001851115612ef957808604811115612ed557612ed4612e44565b5b6001851615612ee45780820291505b8081029050612ef285612ea4565b9450612eb9565b94509492505050565b5f82612f115760019050612fcc565b81612f1e575f9050612fcc565b8160018114612f345760028114612f3e57612f6d565b6001915050612fcc565b60ff841115612f5057612f4f612e44565b5b8360020a915084821115612f6757612f66612e44565b5b50612fcc565b5060208310610133831016604e8410600b8410161715612fa25782820a905083811115612f9d57612f9c612e44565b5b612fcc565b612faf8484846001612eb0565b92509050818404811115612fc657612fc5612e44565b5b81810290505b9392505050565b5f612fdd82612dc1565b9150612fe883612dc1565b92506130157fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8484612f02565b905092915050565b5f61302782612aaa565b915061303283612aaa565b925082820261304081612aaa565b91507f800000000000000000000000000000000000000000000000000000000000000084145f8412161561307757613076612e44565b5b828205841483151761308c5761308b612e44565b5b5092915050565b5f61309d82612aaa565b91507f800000000000000000000000000000000000000000000000000000000000000082036130cf576130ce612e44565b5b815f039050919050565b5f6130e382612aaa565b91506130ee83612aaa565b92508282019050828112155f8312168382125f84121516171561311457613113612e44565b5b92915050565b5f61312482612aaa565b915061312f83612aaa565b925082820390508181125f8412168282135f85121516171561315457613153612e44565b5b92915050565b5f81905092915050565b5f61316e82612b63565b613178818561315a565b9350613188818560208601612b7d565b80840191505092915050565b7f2e000000000000000000000000000000000000000000000000000000000000005f82015250565b5f6131c860018361315a565b91506131d382613194565b600182019050919050565b5f6131e98286613164565b91506131f58285613164565b9150613200826131bc565b915061320c8284613164565b9150819050949350505050565b7f65000000000000000000000000000000000000000000000000000000000000005f82015250565b5f61324d60018361315a565b915061325882613219565b600182019050919050565b5f61326e8287613164565b915061327a8286613164565b9150613285826131bc565b91506132918285613164565b915061329c82613241565b91506132a88284613164565b915081905095945050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f6132ed82612aaa565b91506132f883612aaa565b925082613308576133076132b6565b5b60015f0383147f8000000000000000000000000000000000000000000000000000000000000000831416156133405761333f612e44565b5b828205905092915050565b5f61335582612dc1565b915061336083612dc1565b9250826133705761336f6132b6565b5b828204905092915050565b5f61338582612dc1565b915061339083612dc1565b925082820261339e81612dc1565b915082820484148315176133b5576133b4612e44565b5b5092915050565b7f706f773a2062617365206d75737420626520706f7369746976650000000000005f82015250565b5f6133f0601a83612b6d565b91506133fb826133bc565b602082019050919050565b5f6020820190508181035f83015261341d816133e4565b9050919050565b7f6c6f67206e6f6e2d706f736974697665000000000000000000000000000000005f82015250565b5f613458601083612b6d565b915061346382613424565b602082019050919050565b5f6020820190508181035f8301526134858161344c565b9050919050565b7f73686966743a207c697c20746f6f206c617267650000000000000000000000005f82015250565b5f6134c0601483612b6d565b91506134cb8261348c565b602082019050919050565b5f6020820190508181035f8301526134ed816134b4565b9050919050565b5f6134fe82612aaa565b915061350983612aaa565b925082613519576135186132b6565b5b828207905092915050565b5f61352e82612aaa565b91507f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036135605761355f612e44565b5b600182019050919050565b5f61357582612aaa565b91507f800000000000000000000000000000000000000000000000000000000000000082036135a7576135a6612e44565b5b600182039050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f61361682612dc1565b91505f820361362857613627612e44565b5b600182039050919050565b5f61363d82612dc1565b915061364883612dc1565b92508282019050808211156136605761365f612e44565b5b92915050565b5f81519050919050565b5f81905092915050565b5f61368482613666565b61368e8185613670565b935061369e818560208601612b7d565b80840191505092915050565b5f6136b58285613164565b91506136c1828461367a565b91508190509392505050565b7f56616c7565206d757374206265206e6f6e2d6e656761746976650000000000005f82015250565b5f613701601a83612b6d565b915061370c826136cd565b602082019050919050565b5f6020820190508181035f83015261372e816136f5565b9050919050565b5f61373f82612dc1565b915061374a83612dc1565b92508261375a576137596132b6565b5b828206905092915050565b5f61376f82612add565b915060ff820361378257613781612e44565b5b60018201905091905056fea26469706673582212204ba42decee95608383642c31be3e9e18576c0b560566a2675f62e6912f6cdd6364736f6c634300081e0033"
            }
          },
          "userdoc": {
            "kind": "user",
            "methods": {},
            "version": 1
          }
        }
      }
    },
    "errors": [
      {
        "component": "general",
        "errorCode": "2072",
        "formattedMessage": "Warning: Unused local variable.\n   --> /Users/williamcory/cavalre-contracts/libraries/FloatStrings.sol:110:31:\n    |\n110 |         (int256 _intMantissa, int256 _intExponent) = FloatLib.components(_absInt);\n    |                               ^^^^^^^^^^^^^^^^^^^\n\n",
        "message": "Unused local variable.",
        "severity": "warning",
        "sourceLocation": {
          "end": 3752,
          "file": "/Users/williamcory/cavalre-contracts/libraries/FloatStrings.sol",
          "start": 3733
        },
        "type": "Warning"
      }
    ],
    "sources": {
      "/Users/williamcory/cavalre-contracts/libraries/FloatLib.sol": {
        "id": 0
      },
      "/Users/williamcory/cavalre-contracts/libraries/FloatStrings.sol": {
        "id": 1
      },
      "/Users/williamcory/cavalre-contracts/node_modules/solady/src/utils/FixedPointMathLib.sol": {
        "id": 2
      },
      "/Users/williamcory/cavalre-contracts/playground/contracts/FloatCalculator.s.sol": {
        "id": 3
      }
    }
  },
  "artifacts": {
    "FloatCalculator": {
      "contractName": "FloatCalculator",
      "abi": [
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "uint8",
              "name": "decimals",
              "type": "uint8"
            }
          ],
          "name": "absoluteValue",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "b",
              "type": "int256"
            },
            {
              "internalType": "uint8",
              "name": "decimals",
              "type": "uint8"
            }
          ],
          "name": "add",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "b",
              "type": "int256"
            },
            {
              "internalType": "uint8",
              "name": "decimals",
              "type": "uint8"
            }
          ],
          "name": "divide",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "uint8",
              "name": "decimals",
              "type": "uint8"
            }
          ],
          "name": "exponential",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "mantissa",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "exponent",
              "type": "int256"
            }
          ],
          "name": "fromComponents",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "b",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "c",
              "type": "int256"
            },
            {
              "internalType": "uint8",
              "name": "decimals",
              "type": "uint8"
            }
          ],
          "name": "fullMulDiv",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "value",
              "type": "int256"
            },
            {
              "internalType": "uint8",
              "name": "decimals",
              "type": "uint8"
            }
          ],
          "name": "getComponents",
          "outputs": [
            {
              "internalType": "int256",
              "name": "mantissa",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "exponent",
              "type": "int256"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "uint8",
              "name": "decimals",
              "type": "uint8"
            }
          ],
          "name": "getParts",
          "outputs": [
            {
              "internalType": "string",
              "name": "intPart",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "fracPart",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "b",
              "type": "int256"
            },
            {
              "internalType": "uint8",
              "name": "decimals",
              "type": "uint8"
            }
          ],
          "name": "isEqual",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "b",
              "type": "int256"
            },
            {
              "internalType": "uint8",
              "name": "decimals",
              "type": "uint8"
            }
          ],
          "name": "isGreaterOrEqual",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "b",
              "type": "int256"
            },
            {
              "internalType": "uint8",
              "name": "decimals",
              "type": "uint8"
            }
          ],
          "name": "isGreaterThan",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "b",
              "type": "int256"
            },
            {
              "internalType": "uint8",
              "name": "decimals",
              "type": "uint8"
            }
          ],
          "name": "isLessOrEqual",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "b",
              "type": "int256"
            },
            {
              "internalType": "uint8",
              "name": "decimals",
              "type": "uint8"
            }
          ],
          "name": "isLessThan",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "uint8",
              "name": "decimals",
              "type": "uint8"
            }
          ],
          "name": "isZero",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "b",
              "type": "int256"
            },
            {
              "internalType": "uint8",
              "name": "decimals",
              "type": "uint8"
            }
          ],
          "name": "multiply",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "uint8",
              "name": "decimals",
              "type": "uint8"
            }
          ],
          "name": "naturalLog",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "uint8",
              "name": "decimals",
              "type": "uint8"
            }
          ],
          "name": "negate",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "mantissa",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "exponent",
              "type": "int256"
            }
          ],
          "name": "normalize",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "one",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "pi",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "base",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "exp",
              "type": "int256"
            },
            {
              "internalType": "uint8",
              "name": "decimals",
              "type": "uint8"
            }
          ],
          "name": "power",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "uint8",
              "name": "decimals",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "digits",
              "type": "uint256"
            }
          ],
          "name": "roundTo",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "uint8",
              "name": "decimals",
              "type": "uint8"
            },
            {
              "internalType": "int256",
              "name": "places",
              "type": "int256"
            }
          ],
          "name": "shift",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "uint8",
              "name": "decimals",
              "type": "uint8"
            }
          ],
          "name": "squareRoot",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "b",
              "type": "int256"
            },
            {
              "internalType": "uint8",
              "name": "decimals",
              "type": "uint8"
            }
          ],
          "name": "subtract",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "ten",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "value",
              "type": "int256"
            },
            {
              "internalType": "uint8",
              "name": "decimals",
              "type": "uint8"
            }
          ],
          "name": "toFloatString",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "two",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "zero",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        }
      ],
      "userdoc": {
        "kind": "user",
        "methods": {},
        "version": 1
      },
      "evm": {
        "bytecode": {
          "object": "6080604052348015600e575f5ffd5b506137c38061001c5f395ff3fe608060405234801561000f575f5ffd5b50600436106101cc575f3560e01c8063643ceff911610102578063a2f295c5116100a0578063bc1b392d1161006f578063bc1b392d1461063a578063c753cb3514610658578063df65245d14610688578063f81f8936146106b8576101cc565b8063a2f295c514610579578063a7bfcd0d146105a9578063ba93bc3f146105d9578063bbbd0d3214610609576101cc565b80638cf45091116100dc5780638cf45091146104cb578063901717d1146104fb57806392c1eb9e1461051957806394fd4ee714610549576101cc565b8063643ceff91461044d578063799f54461461046b5780638535829a1461049b576101cc565b80632dd9868d1161016f5780635a260d7f116101495780635a260d7f1461039f5780635caea0ac146103cf5780635d6e8d1c146103ff5780635fdf05d71461042f576101cc565b80632dd9868d1461032157806348f5294c1461033f5780634acc886a1461036f576101cc565b80631b1e7001116101ab5780631b1e7001146102615780631e18b7b214610291578063250ef6e8146102c157806328a4d194146102f1576101cc565b80621f35f5146101d05780630552e844146102005780630a08167214610230575b5f5ffd5b6101ea60048036038101906101e59190612b13565b6106e8565b6040516101f79190612bd3565b60405180910390f35b61021a60048036038101906102159190612bf3565b61072a565b6040516102279190612c4b565b60405180910390f35b61024a60048036038101906102459190612bf3565b61074a565b604051610258929190612c64565b60405180910390f35b61027b60048036038101906102769190612bf3565b610789565b6040516102889190612bd3565b60405180910390f35b6102ab60048036038101906102a69190612c99565b6107a5565b6040516102b89190612bd3565b60405180910390f35b6102db60048036038101906102d69190612bf3565b6107c1565b6040516102e89190612bd3565b60405180910390f35b61030b60048036038101906103069190612cd7565b6107ea565b6040516103189190612bd3565b60405180910390f35b610329610833565b6040516103369190612bd3565b60405180910390f35b61035960048036038101906103549190612bf3565b610872565b6040516103669190612bd3565b60405180910390f35b61038960048036038101906103849190612b13565b61089b565b6040516103969190612c4b565b60405180910390f35b6103b960048036038101906103b49190612b13565b6108d4565b6040516103c69190612bd3565b60405180910390f35b6103e960048036038101906103e49190612b13565b610916565b6040516103f69190612c4b565b60405180910390f35b61041960048036038101906104149190612b13565b61094f565b6040516104269190612bd3565b60405180910390f35b610437610991565b6040516104449190612bd3565b60405180910390f35b6104556109e2565b6040516104629190612bd3565b60405180910390f35b61048560048036038101906104809190612b13565b610a32565b6040516104929190612bd3565b60405180910390f35b6104b560048036038101906104b09190612b13565b610a74565b6040516104c29190612bd3565b60405180910390f35b6104e560048036038101906104e09190612bf3565b610ab6565b6040516104f29190612bd3565b60405180910390f35b610503610adf565b6040516105109190612bd3565b60405180910390f35b610533600480360381019061052e9190612c99565b610b24565b6040516105409190612bd3565b60405180910390f35b610563600480360381019061055e9190612b13565b610b40565b6040516105709190612c4b565b60405180910390f35b610593600480360381019061058e9190612d3b565b610b79565b6040516105a09190612bd3565b60405180910390f35b6105c360048036038101906105be9190612bf3565b610bad565b6040516105d09190612bd3565b60405180910390f35b6105f360048036038101906105ee9190612b13565b610bd6565b6040516106009190612c4b565b60405180910390f35b610623600480360381019061061e9190612bf3565b610c0f565b604051610631929190612d9a565b60405180910390f35b610642610c33565b60405161064f9190612bd3565b60405180910390f35b610672600480360381019061066d9190612b13565b610c43565b60405161067f9190612c4b565b60405180910390f35b6106a2600480360381019061069d9190612bf3565b610c7c565b6040516106af9190612bd3565b60405180910390f35b6106d260048036038101906106cd9190612df4565b610ca5565b6040516106df9190612bd3565b60405180910390f35b60605f6106f58584610cd9565b90505f6107028585610cd9565b905061071f61071a8284610d2890919063ffffffff16565b610d70565b925050509392505050565b5f5f6107368484610cd9565b905061074181610f5f565b91505092915050565b6060805f6107588585610cd9565b90505f5f61076583610f72565b9150915061077282610d70565b61077b82610d70565b945094505050509250929050565b606061079d6107988484610cd9565b610d70565b905092915050565b60606107b96107b4848461102a565b610d70565b905092915050565b60605f6107ce8484610cd9565b90506107e16107dc82611112565b610d70565b91505092915050565b60605f6107f78684610cd9565b90505f6108048685610cd9565b90505f6108118686610cd9565b90506108266108218484846111f7565b610d70565b9350505050949350505050565b606061086d681107d5eb5b5ba4d7c660487fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff901b17610d70565b905090565b60605f61087f8484610cd9565b905061089261088d82611333565b610d70565b91505092915050565b5f5f6108a78584610cd9565b90505f6108b48585610cd9565b90506108c9818361139f90919063ffffffff16565b925050509392505050565b60605f6108e18584610cd9565b90505f6108ee8585610cd9565b905061090b61090682846113cd90919063ffffffff16565b610d70565b925050509392505050565b5f5f6109228584610cd9565b90505f61092f8585610cd9565b9050610944818361141590919063ffffffff16565b925050509392505050565b60605f61095c8584610cd9565b90505f6109698585610cd9565b9050610986610981828461144490919063ffffffff16565b610d70565b925050509392505050565b60606109dd600160156109a49190612e71565b600a6109b09190612fd3565b60026109bc919061301d565b6048600160156109cc9190612e71565b6109d590613093565b901b17610d70565b905090565b6060610a2d600160156109f59190612e71565b600a610a019190612fd3565b60486001806015610a129190612e71565b610a1b90613093565b610a2591906130d9565b901b17610d70565b905090565b60605f610a3f8584610cd9565b90505f610a4c8585610cd9565b9050610a69610a6482846115a090919063ffffffff16565b610d70565b925050509392505050565b60605f610a818584610cd9565b90505f610a8e8585610cd9565b9050610aab610aa6828461163190919063ffffffff16565b610d70565b925050509392505050565b60605f610ac38484610cd9565b9050610ad6610ad1826116c2565b610d70565b91505092915050565b6060610b1f60016015610af29190612e71565b600a610afe9190612fd3565b604860016015610b0e9190612e71565b610b1790613093565b901b17610d70565b905090565b6060610b38610b338484611792565b610d70565b905092915050565b5f5f610b4c8584610cd9565b90505f610b598585610cd9565b9050610b6e81836117ba90919063ffffffff16565b925050509392505050565b60605f610b868585610cd9565b9050610ba3610b9e84836117e890919063ffffffff16565b610d70565b9150509392505050565b60605f610bba8484610cd9565b9050610bcd610bc882611a48565b610d70565b91505092915050565b5f5f610be28584610cd9565b90505f610bef8585610cd9565b9050610c048183611a7390919063ffffffff16565b925050509392505050565b5f5f5f610c1c8585610cd9565b9050610c2781611aa1565b92509250509250929050565b6060610c3e5f610d70565b905090565b5f5f610c4f8584610cd9565b90505f610c5c8585610cd9565b9050610c718183611aba90919063ffffffff16565b925050509392505050565b60605f610c898484610cd9565b9050610c9c610c9782611ae9565b610d70565b91505092915050565b60605f610cb28585610cd9565b9050610ccf610cca8483611b2790919063ffffffff16565b610d70565b9150509392505050565b5f5f8312610cfb57610cf48284611c2690919063ffffffff16565b9050610d22565b610d1f610d1a8385610d0c90613093565b611c2690919063ffffffff16565b611a48565b90505b92915050565b5f5f5f610d358585611c45565b91509150610d66610d4582611dc4565b610d4e84611dc4565b610d5891906130d9565b610d6184611dd0565b61102a565b9250505092915050565b6060806060610d7e84611ddd565b93505f610da460016015600a610d949190612fd3565b610d9e9190612e71565b5f61102a565b90505f60016015610db5919061311a565b90505f8190505f5f610dc689611aa1565b91509150610de585610dd78b611ae9565b611a7390919063ffffffff16565b8015610dfa575082610df690613093565b8112155b15610e9b57610e0889611e00565b80975081985050505f8212610e2b5760405180602001604052805f815250610e62565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b87610e6c886120c4565b604051602001610e7e939291906131de565b604051602081830303815290604052975050505050505050610f5a565b610eb6610eb18385610eac90613093565b61102a565b611e00565b80975081985050505f8212610ed95760405180602001604052805f815250610f10565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b87610f1a886120c4565b610f2e8685610f2991906130d9565b612249565b604051602001610f419493929190613263565b6040516020818303038152906040529750505050505050505b919050565b5f5f610f6a83611dc4565b149050919050565b5f5f5f610f7e84611ddd565b90505f5f610f8b83611aa1565b915091505f8203610fa4575f5f94509450505050611025565b5f8112610fb957825f94509450505050611025565b5f816015610fc791906130d9565b1215610fdb575f8394509450505050611025565b5f81610fe690613093565b600a610ff29190612fd3565b9050611009818461100391906132e3565b5f61102a565b955061101e86856113cd90919063ffffffff16565b9450505050505b915091565b5f5f830361103a575f905061110c565b5f5f841215611052578361104d90613093565b611054565b835b90505b60016015600a6110679190612fd3565b6110719190612e71565b8111156110aa57600a8461108591906132e3565b935060018361109491906130d9565b9250600a816110a3919061334b565b9050611057565b5b600160156110b99190612e71565b600a6110c59190612fd3565b8110156110fe57600a846110d9919061301d565b93506001836110e8919061311a565b9250600a816110f7919061337b565b90506110ab565b6111088484611792565b9150505b92915050565b5f5f611155671ff46cf1450516f460487fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee901b17846115a090919063ffffffff16565b90505f5f61116283610f72565b915091505f6111b06111ab671ff46cf1450516f460487fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee901b178461163190919063ffffffff16565b6122d5565b90505f6111bc826122e8565b90505f60126111d45f876124d290919063ffffffff16565b6111de919061311a565b90506111ea828261102a565b9650505050505050919050565b5f5f5f90505f61120686611dc4565b121561121c5761121585611a48565b9450801590505b5f61122685611dc4565b121561123c5761123584611a48565b9350801590505b5f61124684611dc4565b121561125c5761125583611a48565b9250801590505b5f61126686611ddd565b90505f61127286611ddd565b90505f61127e86611ddd565b90505f61128a84611dc4565b90505f61129684611dc4565b90505f6112a284611dc4565b90505f876112c4576112bf8383866125479092919063ffffffff16565b6112e3565b6112d98383866125479092919063ffffffff16565b6112e290613093565b5b90505f6112ef86611dd0565b6112f888611dd0565b6113018a611dd0565b61130b91906130d9565b611315919061311a565b9050611321828261102a565b99505050505050505050509392505050565b5f611398611393600160156113489190612e71565b600a6113549190612fd3565b6002611360919061301d565b6048600160156113709190612e71565b61137990613093565b901b17611385856116c2565b6115a090919063ffffffff16565b611112565b9050919050565b5f5f5f6113ac8585611c45565b915091506113b981611dc4565b6113c283611dc4565b149250505092915050565b5f5f5f6113da8585611c45565b9150915061140b6113ea82611dc4565b6113f384611dc4565b6113fd919061311a565b61140684611dd0565b61102a565b9250505092915050565b5f5f5f6114228585611c45565b9150915061142f81611dc4565b61143883611dc4565b13159250505092915050565b5f5f61144f84611ddd565b90505f61145b84611dc4565b0361149e576001601561146e9190612e71565b600a61147a9190612fd3565b60486001601561148a9190612e71565b61149390613093565b901b1791505061159a565b6114e6600160156114af9190612e71565b600a6114bb9190612fd3565b6048600160156114cb9190612e71565b6114d490613093565b901b178261139f90919063ffffffff16565b1561152957600160156114f99190612e71565b600a6115059190612fd3565b6048600160156115159190612e71565b61151e90613093565b901b1791505061159a565b5f61153382611dc4565b13611573576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161156a90613406565b60405180910390fd5b61159661159184611583846116c2565b61163190919063ffffffff16565b611112565b9150505b92915050565b5f5f6115ab84611ddd565b90505f6115b784611ddd565b90505f6115c383611dc4565b90505f6115cf83611dc4565b9050611625816015600a6115e39190612fd3565b846115ee919061301d565b6115f891906132e3565b601561160386611dd0565b61160c88611dd0565b611616919061311a565b611620919061311a565b61102a565b94505050505092915050565b5f5f61163c84611ddd565b90505f61164884611ddd565b90505f61165483611dc4565b90505f61166083611dc4565b90506116b66015600a6116739190612fd3565b828461167f919061301d565b61168991906132e3565b61169285611dd0565b61169b87611dd0565b60156116a791906130d9565b6116b191906130d9565b61102a565b94505050505092915050565b5f5f6116cd83611ddd565b90505f5f6116da83611aa1565b915091505f8213611720576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016117179061346e565b60405180910390fd5b5f671ff46cf1450516f482611735919061301d565b611751670de0b6b3a76400008561174c919061301d565b6125ff565b61175b91906130d9565b9050611787817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee61102a565b945050505050919050565b5f5f600160486001901b6117a69190612e71565b8416604884901b1790508091505092915050565b5f5f5f6117c78585611c45565b915091506117d481611dc4565b6117dd83611dc4565b139250505092915050565b5f5f6117f384611dc4565b90505f83148061180257505f81145b156118105783915050611a42565b5f8390505f8290505f8561182388611dd0565b61182d91906130d9565b90505f83131561190e575b6010831261186957662386f26fc100008261185391906132e3565b9150601083611862919061311a565b9250611838565b60088312611893576305f5e1008261188191906132e3565b9150600883611890919061311a565b92505b600483126118bb57612710826118a991906132e3565b91506004836118b8919061311a565b92505b600283126118e2576064826118d091906132e3565b91506002836118df919061311a565b92505b6001831261190957600a826118f791906132e3565b9150600183611906919061311a565b92505b611a31565b8261191890613093565b9250601583131561195e576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611955906134d6565b60405180910390fd5b5b6010831261199057662386f26fc100008261197a919061301d565b9150601083611989919061311a565b925061195f565b600883126119ba576305f5e100826119a8919061301d565b91506008836119b7919061311a565b92505b600483126119e257612710826119d0919061301d565b91506004836119df919061311a565b92505b60028312611a09576064826119f7919061301d565b9150600283611a06919061311a565b92505b60018312611a3057600a82611a1e919061301d565b9150600183611a2d919061311a565b92505b5b611a3b8282611792565b9450505050505b92915050565b5f611a6c611a5583611dc4565b611a5e90613093565b611a6784611dd0565b611792565b9050919050565b5f5f5f611a808585611c45565b91509150611a8d81611dc4565b611a9683611dc4565b129250505092915050565b5f5f5f8390508060080b9250604881901d915050915091565b5f5f5f611ac78585611c45565b91509150611ad481611dc4565b611add83611dc4565b12159250505092915050565b5f5f5f611af584611aa1565b915091505f8212611b0a578392505050611b22565b611b1d82611b1790613093565b82611792565b925050505b919050565b5f5f611b3284611dc4565b03611b3f575f9050611c20565b60158210611b5757611b5083611ddd565b9050611c20565b5f611b6184611ddd565b90505f836015611b719190612e71565b600a611b7d9190612fd3565b90505f611b8983611dc4565b90505f8282611b9891906132e3565b90505f8383611ba791906134f4565b905083600282611bb7919061301d565b12611bcb578180611bc790613524565b9250505b83611bd590613093565b600282611be2919061301d565b13611bf6578180611bf29061356b565b9250505b5f8483611c03919061301d565b9050611c1781611c1288611dd0565b611792565b96505050505050505b92915050565b5f611c3d838360ff16611c3890613093565b61102a565b905092915050565b5f5f5f5f611c5286611aa1565b915091505f5f611c6187611aa1565b915091505f84148015611c7357505f82145b15611c87575f5f9550955050505050611dbd565b5f8403611caf57611c985f82611792565b611ca28383611792565b9550955050505050611dbd565b5f8203611cd757611cc08484611792565b611cca5f85611792565b9550955050505050611dbd565b5f611ce189611ddd565b90505f611ced89611ddd565b9050611cf882611dc4565b9550611d0382611dd0565b9450611d0e81611dc4565b9350611d1981611dd0565b92505f8386611d28919061311a565b90505f8112611d70576015811315611d555782611d455f88611792565b9850985050505050505050611dbd565b82611d6083836117e8565b9850985050505050505050611dbd565b601581611d7c90613093565b1315611d9d57611d8c5f85611792565b829850985050505050505050611dbd565b611db08382611dab90613093565b6117e8565b8298509850505050505050505b9250929050565b5f8160080b9050919050565b5f604882901d9050919050565b5f5f5f611de984611aa1565b91509150611df7828261102a565b92505050919050565b6060805f611e0d84611ddd565b90505f5f611e1a83610f72565b9150915060605f611e2a84611ae9565b90505f5f611e3783611aa1565b915091505f8203611e7f576040518060400160405280600181526020017f30000000000000000000000000000000000000000000000000000000000000008152509350611e99565b5f611e8a845f612858565b9050611e9581612910565b9450505b60605f611ea587611ae9565b90505f5f611eb283611aa1565b915091505f8203611efa576040518060400160405280600181526020017f300000000000000000000000000000000000000000000000000000000000000081525093506120ae565b5f611f1c5f841215611f155783611f1090613093565b611f17565b835b612910565b90505f82611f2990613093565b90508067ffffffffffffffff811115611f4557611f446135b2565b5b6040519080825280601f01601f191660200182016040528015611f775781602001600182028036833780820191505090505b5095505f5f90505b818110156120aa57825181101561202357828160018551611fa09190612e71565b611faa9190612e71565b81518110611fbb57611fba6135df565b5b602001015160f81c60f81b8782600185611fd59190612e71565b611fdf9190612e71565b81518110611ff057611fef6135df565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a90535061209d565b7f300000000000000000000000000000000000000000000000000000000000000087826001856120539190612e71565b61205d9190612e71565b8151811061206e5761206d6135df565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053505b8080600101915050611f7f565b5050505b87849c509c505050505050505050505050915091565b60605f600183516120d59190612e71565b90505b5f8111801561214557507f3000000000000000000000000000000000000000000000000000000000000000838281518110612116576121156135df565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b1561215d5780806121559061360c565b9150506120d8565b5f60018261216b9190613633565b67ffffffffffffffff811115612184576121836135b2565b5b6040519080825280601f01601f1916602001820160405280156121b65781602001600182028036833780820191505090505b5090505f5f90505b6001836121cb9190613633565b81101561223e578481815181106121e5576121e46135df565b5b602001015160f81c60f81b828281518110612203576122026135df565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a90535080806001019150506121be565b508092505050919050565b60605f82126122665760405180602001604052805f81525061229d565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b6122ae6122a984612a48565b612910565b6040516020016122bf9291906136aa565b6040516020818303038152906040529050919050565b5f6122e18260126124d2565b9050919050565b5f7ffffffffffffffffffffffffffffffffffffffffffffffffdc0d0570925a462d78213156124cd57680755bf798b4a1bf1e5821261232e5763a37bfec95f526004601cfd5b6503782dace9d9604e83901b81612348576123476132b6565b5b0591505f60606b8000000000000000000000006bb17217f7d1cf79abc9e3b398606086901b8161237b5761237a6132b6565b5b0501901d90506bb17217f7d1cf79abc9e3b3988102830392505f6c10fe68e7fd37d0007b713f7650840190506d02d16720577bd19bf614176fe9ea6060858302901d0190505f6d04a4fd9f2a8b96949216d2255a6c8583010390506e0587f503bb6ea29d25fcb7401964506060838302901d01905079d835ebba824c98fb31b83b2ca45c0000000000000000000000008582020190505f6c240c330e9fb2d9cbaf0fd5aafc860390506d0277594991cfc85f6e2461837cd96060878302901d0190506d1a521255e34f6a5061b25ef1c9c46060878302901d0390506db1bbb201f443cf962f1a1d3db4a56060878302901d0190506e02c72388d9f74f51a9331fed693f156060878302901d0390506e05180bb14799ab47a8a8cb2a527d576060878302901d01905080820594508360c30374029d9dc38563c32e5c2f6dc192ee70ef65f9978af38602901c9450505050505b919050565b5f5f5f6124de85611aa1565b915091508360ff16816124f191906130d9565b90505f811261251b5780600a6125079190612fd3565b82612512919061301d565b92505050612541565b8061252590613093565b600a6125319190612fd3565b8261253c91906132e3565b925050505b92915050565b5f82840290506001156125f857818385830414851517026125f2575f198385098181108201810383858709845f03851682861161258b5763ae47f7025f526004601cfd5b808604955085600302600218808702600203810290508087026002038102905080870260020381029050808702600203810290508087026002038102905080818802600203028284880304600184855f0304018886118703021702955050505050506125f8565b81810490505b9392505050565b5f816fffffffffffffffffffffffffffffffff1060071b905081811c67ffffffffffffffff1060061b8117905081811c63ffffffff1060051b8117905081811c61ffff1060041b8117905081811c60ff1060031b811790505f821361266b57631615e6385f526004601cfd5b7ff8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff6f8421084210842108cc6318c6db6d54be83831c1c601f161a8118905081811b609f1c91506c8c3f38e95a6b1ff2ab1c3b3437828384856c29508e458543d8aa4df2abee78010260601d6d0139601a2efabe717e604cbb4894010260601d6d02247f7a7b6594320649aa03aba1010260601d036d02384773bdf1ac5676facced609183820260601d0390506cb9a025d814b29c212b8b1a07ce83820260601d0390506c0a09507084cc699bb0e71ea86a60601b838202039050826c465772b2bbbb5f824b15207a300180840260601d6d0388eaa27412d5aca026815d636e01905080840260601d6d0df99ac502031bf953eff472fdcc01905080840260601d6d13cdffb29d51d99322bdff5f221101905080840260601d6d0a0f742023def783a307a986912e01905080840260601d6d01920d8043ca89b5239253284e4201905080840260601d6c0b7a86d7375468fac667a0a527019050808205915081711340daa0d5f769dba1915cef59f0815a55060291508183609f037d0267a36c0c95b3975ab3ee5b203a7614a3f75373f047d803ae7b6687f2b302019150817d57115e47018c7177eebf7cd370a3356a1b7863008a5ae8028c72b88642840191508160ae1d92505050919050565b5f5f5f61286485611aa1565b915091505f8212156128ab576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016128a290613717565b60405180910390fd5b8360ff16816128ba91906130d9565b90505f81126128e45780600a6128d09190612fd3565b826128db919061337b565b9250505061290a565b806128ee90613093565b600a6128fa9190612fd3565b82612905919061334b565b925050505b92915050565b60605f8203612956576040518060400160405280600181526020017f30000000000000000000000000000000000000000000000000000000000000008152509050612a43565b5f61296083612a5d565b60ff1690505f8167ffffffffffffffff8111156129805761297f6135b2565b5b6040519080825280601f01601f1916602001820160405280156129b25781602001600182028036833780820191505090505b5090505b5f8414612a3d576001826129ca9190612e71565b9150600a846129d99190613735565b60306129e59190613633565b60f81b8183815181106129fb576129fa6135df565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a905350600a84612a36919061334b565b93506129b6565b80925050505b919050565b5f60ff82901d60ff83901d8301189050919050565b5f5f8203612a6e5760019050612aa1565b5f5f90505b5f8314612a9c578080612a8590613765565b915050600a83612a95919061334b565b9250612a73565b809150505b919050565b5f5ffd5b5f819050919050565b612abc81612aaa565b8114612ac6575f5ffd5b50565b5f81359050612ad781612ab3565b92915050565b5f60ff82169050919050565b612af281612add565b8114612afc575f5ffd5b50565b5f81359050612b0d81612ae9565b92915050565b5f5f5f60608486031215612b2a57612b29612aa6565b5b5f612b3786828701612ac9565b9350506020612b4886828701612ac9565b9250506040612b5986828701612aff565b9150509250925092565b5f81519050919050565b5f82825260208201905092915050565b8281835e5f83830152505050565b5f601f19601f8301169050919050565b5f612ba582612b63565b612baf8185612b6d565b9350612bbf818560208601612b7d565b612bc881612b8b565b840191505092915050565b5f6020820190508181035f830152612beb8184612b9b565b905092915050565b5f5f60408385031215612c0957612c08612aa6565b5b5f612c1685828601612ac9565b9250506020612c2785828601612aff565b9150509250929050565b5f8115159050919050565b612c4581612c31565b82525050565b5f602082019050612c5e5f830184612c3c565b92915050565b5f6040820190508181035f830152612c7c8185612b9b565b90508181036020830152612c908184612b9b565b90509392505050565b5f5f60408385031215612caf57612cae612aa6565b5b5f612cbc85828601612ac9565b9250506020612ccd85828601612ac9565b9150509250929050565b5f5f5f5f60808587031215612cef57612cee612aa6565b5b5f612cfc87828801612ac9565b9450506020612d0d87828801612ac9565b9350506040612d1e87828801612ac9565b9250506060612d2f87828801612aff565b91505092959194509250565b5f5f5f60608486031215612d5257612d51612aa6565b5b5f612d5f86828701612ac9565b9350506020612d7086828701612aff565b9250506040612d8186828701612ac9565b9150509250925092565b612d9481612aaa565b82525050565b5f604082019050612dad5f830185612d8b565b612dba6020830184612d8b565b9392505050565b5f819050919050565b612dd381612dc1565b8114612ddd575f5ffd5b50565b5f81359050612dee81612dca565b92915050565b5f5f5f60608486031215612e0b57612e0a612aa6565b5b5f612e1886828701612ac9565b9350506020612e2986828701612aff565b9250506040612e3a86828701612de0565b9150509250925092565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f612e7b82612dc1565b9150612e8683612dc1565b9250828203905081811115612e9e57612e9d612e44565b5b92915050565b5f8160011c9050919050565b5f5f8291508390505b6001851115612ef957808604811115612ed557612ed4612e44565b5b6001851615612ee45780820291505b8081029050612ef285612ea4565b9450612eb9565b94509492505050565b5f82612f115760019050612fcc565b81612f1e575f9050612fcc565b8160018114612f345760028114612f3e57612f6d565b6001915050612fcc565b60ff841115612f5057612f4f612e44565b5b8360020a915084821115612f6757612f66612e44565b5b50612fcc565b5060208310610133831016604e8410600b8410161715612fa25782820a905083811115612f9d57612f9c612e44565b5b612fcc565b612faf8484846001612eb0565b92509050818404811115612fc657612fc5612e44565b5b81810290505b9392505050565b5f612fdd82612dc1565b9150612fe883612dc1565b92506130157fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8484612f02565b905092915050565b5f61302782612aaa565b915061303283612aaa565b925082820261304081612aaa565b91507f800000000000000000000000000000000000000000000000000000000000000084145f8412161561307757613076612e44565b5b828205841483151761308c5761308b612e44565b5b5092915050565b5f61309d82612aaa565b91507f800000000000000000000000000000000000000000000000000000000000000082036130cf576130ce612e44565b5b815f039050919050565b5f6130e382612aaa565b91506130ee83612aaa565b92508282019050828112155f8312168382125f84121516171561311457613113612e44565b5b92915050565b5f61312482612aaa565b915061312f83612aaa565b925082820390508181125f8412168282135f85121516171561315457613153612e44565b5b92915050565b5f81905092915050565b5f61316e82612b63565b613178818561315a565b9350613188818560208601612b7d565b80840191505092915050565b7f2e000000000000000000000000000000000000000000000000000000000000005f82015250565b5f6131c860018361315a565b91506131d382613194565b600182019050919050565b5f6131e98286613164565b91506131f58285613164565b9150613200826131bc565b915061320c8284613164565b9150819050949350505050565b7f65000000000000000000000000000000000000000000000000000000000000005f82015250565b5f61324d60018361315a565b915061325882613219565b600182019050919050565b5f61326e8287613164565b915061327a8286613164565b9150613285826131bc565b91506132918285613164565b915061329c82613241565b91506132a88284613164565b915081905095945050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f6132ed82612aaa565b91506132f883612aaa565b925082613308576133076132b6565b5b60015f0383147f8000000000000000000000000000000000000000000000000000000000000000831416156133405761333f612e44565b5b828205905092915050565b5f61335582612dc1565b915061336083612dc1565b9250826133705761336f6132b6565b5b828204905092915050565b5f61338582612dc1565b915061339083612dc1565b925082820261339e81612dc1565b915082820484148315176133b5576133b4612e44565b5b5092915050565b7f706f773a2062617365206d75737420626520706f7369746976650000000000005f82015250565b5f6133f0601a83612b6d565b91506133fb826133bc565b602082019050919050565b5f6020820190508181035f83015261341d816133e4565b9050919050565b7f6c6f67206e6f6e2d706f736974697665000000000000000000000000000000005f82015250565b5f613458601083612b6d565b915061346382613424565b602082019050919050565b5f6020820190508181035f8301526134858161344c565b9050919050565b7f73686966743a207c697c20746f6f206c617267650000000000000000000000005f82015250565b5f6134c0601483612b6d565b91506134cb8261348c565b602082019050919050565b5f6020820190508181035f8301526134ed816134b4565b9050919050565b5f6134fe82612aaa565b915061350983612aaa565b925082613519576135186132b6565b5b828207905092915050565b5f61352e82612aaa565b91507f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036135605761355f612e44565b5b600182019050919050565b5f61357582612aaa565b91507f800000000000000000000000000000000000000000000000000000000000000082036135a7576135a6612e44565b5b600182039050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f61361682612dc1565b91505f820361362857613627612e44565b5b600182039050919050565b5f61363d82612dc1565b915061364883612dc1565b92508282019050808211156136605761365f612e44565b5b92915050565b5f81519050919050565b5f81905092915050565b5f61368482613666565b61368e8185613670565b935061369e818560208601612b7d565b80840191505092915050565b5f6136b58285613164565b91506136c1828461367a565b91508190509392505050565b7f56616c7565206d757374206265206e6f6e2d6e656761746976650000000000005f82015250565b5f613701601a83612b6d565b915061370c826136cd565b602082019050919050565b5f6020820190508181035f83015261372e816136f5565b9050919050565b5f61373f82612dc1565b915061374a83612dc1565b92508261375a576137596132b6565b5b828206905092915050565b5f61376f82612add565b915060ff820361378257613781612e44565b5b60018201905091905056fea26469706673582212204ba42decee95608383642c31be3e9e18576c0b560566a2675f62e6912f6cdd6364736f6c634300081e0033"
        },
        "deployedBytecode": {
          "object": "608060405234801561000f575f5ffd5b50600436106101cc575f3560e01c8063643ceff911610102578063a2f295c5116100a0578063bc1b392d1161006f578063bc1b392d1461063a578063c753cb3514610658578063df65245d14610688578063f81f8936146106b8576101cc565b8063a2f295c514610579578063a7bfcd0d146105a9578063ba93bc3f146105d9578063bbbd0d3214610609576101cc565b80638cf45091116100dc5780638cf45091146104cb578063901717d1146104fb57806392c1eb9e1461051957806394fd4ee714610549576101cc565b8063643ceff91461044d578063799f54461461046b5780638535829a1461049b576101cc565b80632dd9868d1161016f5780635a260d7f116101495780635a260d7f1461039f5780635caea0ac146103cf5780635d6e8d1c146103ff5780635fdf05d71461042f576101cc565b80632dd9868d1461032157806348f5294c1461033f5780634acc886a1461036f576101cc565b80631b1e7001116101ab5780631b1e7001146102615780631e18b7b214610291578063250ef6e8146102c157806328a4d194146102f1576101cc565b80621f35f5146101d05780630552e844146102005780630a08167214610230575b5f5ffd5b6101ea60048036038101906101e59190612b13565b6106e8565b6040516101f79190612bd3565b60405180910390f35b61021a60048036038101906102159190612bf3565b61072a565b6040516102279190612c4b565b60405180910390f35b61024a60048036038101906102459190612bf3565b61074a565b604051610258929190612c64565b60405180910390f35b61027b60048036038101906102769190612bf3565b610789565b6040516102889190612bd3565b60405180910390f35b6102ab60048036038101906102a69190612c99565b6107a5565b6040516102b89190612bd3565b60405180910390f35b6102db60048036038101906102d69190612bf3565b6107c1565b6040516102e89190612bd3565b60405180910390f35b61030b60048036038101906103069190612cd7565b6107ea565b6040516103189190612bd3565b60405180910390f35b610329610833565b6040516103369190612bd3565b60405180910390f35b61035960048036038101906103549190612bf3565b610872565b6040516103669190612bd3565b60405180910390f35b61038960048036038101906103849190612b13565b61089b565b6040516103969190612c4b565b60405180910390f35b6103b960048036038101906103b49190612b13565b6108d4565b6040516103c69190612bd3565b60405180910390f35b6103e960048036038101906103e49190612b13565b610916565b6040516103f69190612c4b565b60405180910390f35b61041960048036038101906104149190612b13565b61094f565b6040516104269190612bd3565b60405180910390f35b610437610991565b6040516104449190612bd3565b60405180910390f35b6104556109e2565b6040516104629190612bd3565b60405180910390f35b61048560048036038101906104809190612b13565b610a32565b6040516104929190612bd3565b60405180910390f35b6104b560048036038101906104b09190612b13565b610a74565b6040516104c29190612bd3565b60405180910390f35b6104e560048036038101906104e09190612bf3565b610ab6565b6040516104f29190612bd3565b60405180910390f35b610503610adf565b6040516105109190612bd3565b60405180910390f35b610533600480360381019061052e9190612c99565b610b24565b6040516105409190612bd3565b60405180910390f35b610563600480360381019061055e9190612b13565b610b40565b6040516105709190612c4b565b60405180910390f35b610593600480360381019061058e9190612d3b565b610b79565b6040516105a09190612bd3565b60405180910390f35b6105c360048036038101906105be9190612bf3565b610bad565b6040516105d09190612bd3565b60405180910390f35b6105f360048036038101906105ee9190612b13565b610bd6565b6040516106009190612c4b565b60405180910390f35b610623600480360381019061061e9190612bf3565b610c0f565b604051610631929190612d9a565b60405180910390f35b610642610c33565b60405161064f9190612bd3565b60405180910390f35b610672600480360381019061066d9190612b13565b610c43565b60405161067f9190612c4b565b60405180910390f35b6106a2600480360381019061069d9190612bf3565b610c7c565b6040516106af9190612bd3565b60405180910390f35b6106d260048036038101906106cd9190612df4565b610ca5565b6040516106df9190612bd3565b60405180910390f35b60605f6106f58584610cd9565b90505f6107028585610cd9565b905061071f61071a8284610d2890919063ffffffff16565b610d70565b925050509392505050565b5f5f6107368484610cd9565b905061074181610f5f565b91505092915050565b6060805f6107588585610cd9565b90505f5f61076583610f72565b9150915061077282610d70565b61077b82610d70565b945094505050509250929050565b606061079d6107988484610cd9565b610d70565b905092915050565b60606107b96107b4848461102a565b610d70565b905092915050565b60605f6107ce8484610cd9565b90506107e16107dc82611112565b610d70565b91505092915050565b60605f6107f78684610cd9565b90505f6108048685610cd9565b90505f6108118686610cd9565b90506108266108218484846111f7565b610d70565b9350505050949350505050565b606061086d681107d5eb5b5ba4d7c660487fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff901b17610d70565b905090565b60605f61087f8484610cd9565b905061089261088d82611333565b610d70565b91505092915050565b5f5f6108a78584610cd9565b90505f6108b48585610cd9565b90506108c9818361139f90919063ffffffff16565b925050509392505050565b60605f6108e18584610cd9565b90505f6108ee8585610cd9565b905061090b61090682846113cd90919063ffffffff16565b610d70565b925050509392505050565b5f5f6109228584610cd9565b90505f61092f8585610cd9565b9050610944818361141590919063ffffffff16565b925050509392505050565b60605f61095c8584610cd9565b90505f6109698585610cd9565b9050610986610981828461144490919063ffffffff16565b610d70565b925050509392505050565b60606109dd600160156109a49190612e71565b600a6109b09190612fd3565b60026109bc919061301d565b6048600160156109cc9190612e71565b6109d590613093565b901b17610d70565b905090565b6060610a2d600160156109f59190612e71565b600a610a019190612fd3565b60486001806015610a129190612e71565b610a1b90613093565b610a2591906130d9565b901b17610d70565b905090565b60605f610a3f8584610cd9565b90505f610a4c8585610cd9565b9050610a69610a6482846115a090919063ffffffff16565b610d70565b925050509392505050565b60605f610a818584610cd9565b90505f610a8e8585610cd9565b9050610aab610aa6828461163190919063ffffffff16565b610d70565b925050509392505050565b60605f610ac38484610cd9565b9050610ad6610ad1826116c2565b610d70565b91505092915050565b6060610b1f60016015610af29190612e71565b600a610afe9190612fd3565b604860016015610b0e9190612e71565b610b1790613093565b901b17610d70565b905090565b6060610b38610b338484611792565b610d70565b905092915050565b5f5f610b4c8584610cd9565b90505f610b598585610cd9565b9050610b6e81836117ba90919063ffffffff16565b925050509392505050565b60605f610b868585610cd9565b9050610ba3610b9e84836117e890919063ffffffff16565b610d70565b9150509392505050565b60605f610bba8484610cd9565b9050610bcd610bc882611a48565b610d70565b91505092915050565b5f5f610be28584610cd9565b90505f610bef8585610cd9565b9050610c048183611a7390919063ffffffff16565b925050509392505050565b5f5f5f610c1c8585610cd9565b9050610c2781611aa1565b92509250509250929050565b6060610c3e5f610d70565b905090565b5f5f610c4f8584610cd9565b90505f610c5c8585610cd9565b9050610c718183611aba90919063ffffffff16565b925050509392505050565b60605f610c898484610cd9565b9050610c9c610c9782611ae9565b610d70565b91505092915050565b60605f610cb28585610cd9565b9050610ccf610cca8483611b2790919063ffffffff16565b610d70565b9150509392505050565b5f5f8312610cfb57610cf48284611c2690919063ffffffff16565b9050610d22565b610d1f610d1a8385610d0c90613093565b611c2690919063ffffffff16565b611a48565b90505b92915050565b5f5f5f610d358585611c45565b91509150610d66610d4582611dc4565b610d4e84611dc4565b610d5891906130d9565b610d6184611dd0565b61102a565b9250505092915050565b6060806060610d7e84611ddd565b93505f610da460016015600a610d949190612fd3565b610d9e9190612e71565b5f61102a565b90505f60016015610db5919061311a565b90505f8190505f5f610dc689611aa1565b91509150610de585610dd78b611ae9565b611a7390919063ffffffff16565b8015610dfa575082610df690613093565b8112155b15610e9b57610e0889611e00565b80975081985050505f8212610e2b5760405180602001604052805f815250610e62565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b87610e6c886120c4565b604051602001610e7e939291906131de565b604051602081830303815290604052975050505050505050610f5a565b610eb6610eb18385610eac90613093565b61102a565b611e00565b80975081985050505f8212610ed95760405180602001604052805f815250610f10565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b87610f1a886120c4565b610f2e8685610f2991906130d9565b612249565b604051602001610f419493929190613263565b6040516020818303038152906040529750505050505050505b919050565b5f5f610f6a83611dc4565b149050919050565b5f5f5f610f7e84611ddd565b90505f5f610f8b83611aa1565b915091505f8203610fa4575f5f94509450505050611025565b5f8112610fb957825f94509450505050611025565b5f816015610fc791906130d9565b1215610fdb575f8394509450505050611025565b5f81610fe690613093565b600a610ff29190612fd3565b9050611009818461100391906132e3565b5f61102a565b955061101e86856113cd90919063ffffffff16565b9450505050505b915091565b5f5f830361103a575f905061110c565b5f5f841215611052578361104d90613093565b611054565b835b90505b60016015600a6110679190612fd3565b6110719190612e71565b8111156110aa57600a8461108591906132e3565b935060018361109491906130d9565b9250600a816110a3919061334b565b9050611057565b5b600160156110b99190612e71565b600a6110c59190612fd3565b8110156110fe57600a846110d9919061301d565b93506001836110e8919061311a565b9250600a816110f7919061337b565b90506110ab565b6111088484611792565b9150505b92915050565b5f5f611155671ff46cf1450516f460487fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee901b17846115a090919063ffffffff16565b90505f5f61116283610f72565b915091505f6111b06111ab671ff46cf1450516f460487fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee901b178461163190919063ffffffff16565b6122d5565b90505f6111bc826122e8565b90505f60126111d45f876124d290919063ffffffff16565b6111de919061311a565b90506111ea828261102a565b9650505050505050919050565b5f5f5f90505f61120686611dc4565b121561121c5761121585611a48565b9450801590505b5f61122685611dc4565b121561123c5761123584611a48565b9350801590505b5f61124684611dc4565b121561125c5761125583611a48565b9250801590505b5f61126686611ddd565b90505f61127286611ddd565b90505f61127e86611ddd565b90505f61128a84611dc4565b90505f61129684611dc4565b90505f6112a284611dc4565b90505f876112c4576112bf8383866125479092919063ffffffff16565b6112e3565b6112d98383866125479092919063ffffffff16565b6112e290613093565b5b90505f6112ef86611dd0565b6112f888611dd0565b6113018a611dd0565b61130b91906130d9565b611315919061311a565b9050611321828261102a565b99505050505050505050509392505050565b5f611398611393600160156113489190612e71565b600a6113549190612fd3565b6002611360919061301d565b6048600160156113709190612e71565b61137990613093565b901b17611385856116c2565b6115a090919063ffffffff16565b611112565b9050919050565b5f5f5f6113ac8585611c45565b915091506113b981611dc4565b6113c283611dc4565b149250505092915050565b5f5f5f6113da8585611c45565b9150915061140b6113ea82611dc4565b6113f384611dc4565b6113fd919061311a565b61140684611dd0565b61102a565b9250505092915050565b5f5f5f6114228585611c45565b9150915061142f81611dc4565b61143883611dc4565b13159250505092915050565b5f5f61144f84611ddd565b90505f61145b84611dc4565b0361149e576001601561146e9190612e71565b600a61147a9190612fd3565b60486001601561148a9190612e71565b61149390613093565b901b1791505061159a565b6114e6600160156114af9190612e71565b600a6114bb9190612fd3565b6048600160156114cb9190612e71565b6114d490613093565b901b178261139f90919063ffffffff16565b1561152957600160156114f99190612e71565b600a6115059190612fd3565b6048600160156115159190612e71565b61151e90613093565b901b1791505061159a565b5f61153382611dc4565b13611573576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161156a90613406565b60405180910390fd5b61159661159184611583846116c2565b61163190919063ffffffff16565b611112565b9150505b92915050565b5f5f6115ab84611ddd565b90505f6115b784611ddd565b90505f6115c383611dc4565b90505f6115cf83611dc4565b9050611625816015600a6115e39190612fd3565b846115ee919061301d565b6115f891906132e3565b601561160386611dd0565b61160c88611dd0565b611616919061311a565b611620919061311a565b61102a565b94505050505092915050565b5f5f61163c84611ddd565b90505f61164884611ddd565b90505f61165483611dc4565b90505f61166083611dc4565b90506116b66015600a6116739190612fd3565b828461167f919061301d565b61168991906132e3565b61169285611dd0565b61169b87611dd0565b60156116a791906130d9565b6116b191906130d9565b61102a565b94505050505092915050565b5f5f6116cd83611ddd565b90505f5f6116da83611aa1565b915091505f8213611720576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016117179061346e565b60405180910390fd5b5f671ff46cf1450516f482611735919061301d565b611751670de0b6b3a76400008561174c919061301d565b6125ff565b61175b91906130d9565b9050611787817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee61102a565b945050505050919050565b5f5f600160486001901b6117a69190612e71565b8416604884901b1790508091505092915050565b5f5f5f6117c78585611c45565b915091506117d481611dc4565b6117dd83611dc4565b139250505092915050565b5f5f6117f384611dc4565b90505f83148061180257505f81145b156118105783915050611a42565b5f8390505f8290505f8561182388611dd0565b61182d91906130d9565b90505f83131561190e575b6010831261186957662386f26fc100008261185391906132e3565b9150601083611862919061311a565b9250611838565b60088312611893576305f5e1008261188191906132e3565b9150600883611890919061311a565b92505b600483126118bb57612710826118a991906132e3565b91506004836118b8919061311a565b92505b600283126118e2576064826118d091906132e3565b91506002836118df919061311a565b92505b6001831261190957600a826118f791906132e3565b9150600183611906919061311a565b92505b611a31565b8261191890613093565b9250601583131561195e576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611955906134d6565b60405180910390fd5b5b6010831261199057662386f26fc100008261197a919061301d565b9150601083611989919061311a565b925061195f565b600883126119ba576305f5e100826119a8919061301d565b91506008836119b7919061311a565b92505b600483126119e257612710826119d0919061301d565b91506004836119df919061311a565b92505b60028312611a09576064826119f7919061301d565b9150600283611a06919061311a565b92505b60018312611a3057600a82611a1e919061301d565b9150600183611a2d919061311a565b92505b5b611a3b8282611792565b9450505050505b92915050565b5f611a6c611a5583611dc4565b611a5e90613093565b611a6784611dd0565b611792565b9050919050565b5f5f5f611a808585611c45565b91509150611a8d81611dc4565b611a9683611dc4565b129250505092915050565b5f5f5f8390508060080b9250604881901d915050915091565b5f5f5f611ac78585611c45565b91509150611ad481611dc4565b611add83611dc4565b12159250505092915050565b5f5f5f611af584611aa1565b915091505f8212611b0a578392505050611b22565b611b1d82611b1790613093565b82611792565b925050505b919050565b5f5f611b3284611dc4565b03611b3f575f9050611c20565b60158210611b5757611b5083611ddd565b9050611c20565b5f611b6184611ddd565b90505f836015611b719190612e71565b600a611b7d9190612fd3565b90505f611b8983611dc4565b90505f8282611b9891906132e3565b90505f8383611ba791906134f4565b905083600282611bb7919061301d565b12611bcb578180611bc790613524565b9250505b83611bd590613093565b600282611be2919061301d565b13611bf6578180611bf29061356b565b9250505b5f8483611c03919061301d565b9050611c1781611c1288611dd0565b611792565b96505050505050505b92915050565b5f611c3d838360ff16611c3890613093565b61102a565b905092915050565b5f5f5f5f611c5286611aa1565b915091505f5f611c6187611aa1565b915091505f84148015611c7357505f82145b15611c87575f5f9550955050505050611dbd565b5f8403611caf57611c985f82611792565b611ca28383611792565b9550955050505050611dbd565b5f8203611cd757611cc08484611792565b611cca5f85611792565b9550955050505050611dbd565b5f611ce189611ddd565b90505f611ced89611ddd565b9050611cf882611dc4565b9550611d0382611dd0565b9450611d0e81611dc4565b9350611d1981611dd0565b92505f8386611d28919061311a565b90505f8112611d70576015811315611d555782611d455f88611792565b9850985050505050505050611dbd565b82611d6083836117e8565b9850985050505050505050611dbd565b601581611d7c90613093565b1315611d9d57611d8c5f85611792565b829850985050505050505050611dbd565b611db08382611dab90613093565b6117e8565b8298509850505050505050505b9250929050565b5f8160080b9050919050565b5f604882901d9050919050565b5f5f5f611de984611aa1565b91509150611df7828261102a565b92505050919050565b6060805f611e0d84611ddd565b90505f5f611e1a83610f72565b9150915060605f611e2a84611ae9565b90505f5f611e3783611aa1565b915091505f8203611e7f576040518060400160405280600181526020017f30000000000000000000000000000000000000000000000000000000000000008152509350611e99565b5f611e8a845f612858565b9050611e9581612910565b9450505b60605f611ea587611ae9565b90505f5f611eb283611aa1565b915091505f8203611efa576040518060400160405280600181526020017f300000000000000000000000000000000000000000000000000000000000000081525093506120ae565b5f611f1c5f841215611f155783611f1090613093565b611f17565b835b612910565b90505f82611f2990613093565b90508067ffffffffffffffff811115611f4557611f446135b2565b5b6040519080825280601f01601f191660200182016040528015611f775781602001600182028036833780820191505090505b5095505f5f90505b818110156120aa57825181101561202357828160018551611fa09190612e71565b611faa9190612e71565b81518110611fbb57611fba6135df565b5b602001015160f81c60f81b8782600185611fd59190612e71565b611fdf9190612e71565b81518110611ff057611fef6135df565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a90535061209d565b7f300000000000000000000000000000000000000000000000000000000000000087826001856120539190612e71565b61205d9190612e71565b8151811061206e5761206d6135df565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053505b8080600101915050611f7f565b5050505b87849c509c505050505050505050505050915091565b60605f600183516120d59190612e71565b90505b5f8111801561214557507f3000000000000000000000000000000000000000000000000000000000000000838281518110612116576121156135df565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b1561215d5780806121559061360c565b9150506120d8565b5f60018261216b9190613633565b67ffffffffffffffff811115612184576121836135b2565b5b6040519080825280601f01601f1916602001820160405280156121b65781602001600182028036833780820191505090505b5090505f5f90505b6001836121cb9190613633565b81101561223e578481815181106121e5576121e46135df565b5b602001015160f81c60f81b828281518110612203576122026135df565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a90535080806001019150506121be565b508092505050919050565b60605f82126122665760405180602001604052805f81525061229d565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b6122ae6122a984612a48565b612910565b6040516020016122bf9291906136aa565b6040516020818303038152906040529050919050565b5f6122e18260126124d2565b9050919050565b5f7ffffffffffffffffffffffffffffffffffffffffffffffffdc0d0570925a462d78213156124cd57680755bf798b4a1bf1e5821261232e5763a37bfec95f526004601cfd5b6503782dace9d9604e83901b81612348576123476132b6565b5b0591505f60606b8000000000000000000000006bb17217f7d1cf79abc9e3b398606086901b8161237b5761237a6132b6565b5b0501901d90506bb17217f7d1cf79abc9e3b3988102830392505f6c10fe68e7fd37d0007b713f7650840190506d02d16720577bd19bf614176fe9ea6060858302901d0190505f6d04a4fd9f2a8b96949216d2255a6c8583010390506e0587f503bb6ea29d25fcb7401964506060838302901d01905079d835ebba824c98fb31b83b2ca45c0000000000000000000000008582020190505f6c240c330e9fb2d9cbaf0fd5aafc860390506d0277594991cfc85f6e2461837cd96060878302901d0190506d1a521255e34f6a5061b25ef1c9c46060878302901d0390506db1bbb201f443cf962f1a1d3db4a56060878302901d0190506e02c72388d9f74f51a9331fed693f156060878302901d0390506e05180bb14799ab47a8a8cb2a527d576060878302901d01905080820594508360c30374029d9dc38563c32e5c2f6dc192ee70ef65f9978af38602901c9450505050505b919050565b5f5f5f6124de85611aa1565b915091508360ff16816124f191906130d9565b90505f811261251b5780600a6125079190612fd3565b82612512919061301d565b92505050612541565b8061252590613093565b600a6125319190612fd3565b8261253c91906132e3565b925050505b92915050565b5f82840290506001156125f857818385830414851517026125f2575f198385098181108201810383858709845f03851682861161258b5763ae47f7025f526004601cfd5b808604955085600302600218808702600203810290508087026002038102905080870260020381029050808702600203810290508087026002038102905080818802600203028284880304600184855f0304018886118703021702955050505050506125f8565b81810490505b9392505050565b5f816fffffffffffffffffffffffffffffffff1060071b905081811c67ffffffffffffffff1060061b8117905081811c63ffffffff1060051b8117905081811c61ffff1060041b8117905081811c60ff1060031b811790505f821361266b57631615e6385f526004601cfd5b7ff8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff6f8421084210842108cc6318c6db6d54be83831c1c601f161a8118905081811b609f1c91506c8c3f38e95a6b1ff2ab1c3b3437828384856c29508e458543d8aa4df2abee78010260601d6d0139601a2efabe717e604cbb4894010260601d6d02247f7a7b6594320649aa03aba1010260601d036d02384773bdf1ac5676facced609183820260601d0390506cb9a025d814b29c212b8b1a07ce83820260601d0390506c0a09507084cc699bb0e71ea86a60601b838202039050826c465772b2bbbb5f824b15207a300180840260601d6d0388eaa27412d5aca026815d636e01905080840260601d6d0df99ac502031bf953eff472fdcc01905080840260601d6d13cdffb29d51d99322bdff5f221101905080840260601d6d0a0f742023def783a307a986912e01905080840260601d6d01920d8043ca89b5239253284e4201905080840260601d6c0b7a86d7375468fac667a0a527019050808205915081711340daa0d5f769dba1915cef59f0815a55060291508183609f037d0267a36c0c95b3975ab3ee5b203a7614a3f75373f047d803ae7b6687f2b302019150817d57115e47018c7177eebf7cd370a3356a1b7863008a5ae8028c72b88642840191508160ae1d92505050919050565b5f5f5f61286485611aa1565b915091505f8212156128ab576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016128a290613717565b60405180910390fd5b8360ff16816128ba91906130d9565b90505f81126128e45780600a6128d09190612fd3565b826128db919061337b565b9250505061290a565b806128ee90613093565b600a6128fa9190612fd3565b82612905919061334b565b925050505b92915050565b60605f8203612956576040518060400160405280600181526020017f30000000000000000000000000000000000000000000000000000000000000008152509050612a43565b5f61296083612a5d565b60ff1690505f8167ffffffffffffffff8111156129805761297f6135b2565b5b6040519080825280601f01601f1916602001820160405280156129b25781602001600182028036833780820191505090505b5090505b5f8414612a3d576001826129ca9190612e71565b9150600a846129d99190613735565b60306129e59190613633565b60f81b8183815181106129fb576129fa6135df565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a905350600a84612a36919061334b565b93506129b6565b80925050505b919050565b5f60ff82901d60ff83901d8301189050919050565b5f5f8203612a6e5760019050612aa1565b5f5f90505b5f8314612a9c578080612a8590613765565b915050600a83612a95919061334b565b9250612a73565b809150505b919050565b5f5ffd5b5f819050919050565b612abc81612aaa565b8114612ac6575f5ffd5b50565b5f81359050612ad781612ab3565b92915050565b5f60ff82169050919050565b612af281612add565b8114612afc575f5ffd5b50565b5f81359050612b0d81612ae9565b92915050565b5f5f5f60608486031215612b2a57612b29612aa6565b5b5f612b3786828701612ac9565b9350506020612b4886828701612ac9565b9250506040612b5986828701612aff565b9150509250925092565b5f81519050919050565b5f82825260208201905092915050565b8281835e5f83830152505050565b5f601f19601f8301169050919050565b5f612ba582612b63565b612baf8185612b6d565b9350612bbf818560208601612b7d565b612bc881612b8b565b840191505092915050565b5f6020820190508181035f830152612beb8184612b9b565b905092915050565b5f5f60408385031215612c0957612c08612aa6565b5b5f612c1685828601612ac9565b9250506020612c2785828601612aff565b9150509250929050565b5f8115159050919050565b612c4581612c31565b82525050565b5f602082019050612c5e5f830184612c3c565b92915050565b5f6040820190508181035f830152612c7c8185612b9b565b90508181036020830152612c908184612b9b565b90509392505050565b5f5f60408385031215612caf57612cae612aa6565b5b5f612cbc85828601612ac9565b9250506020612ccd85828601612ac9565b9150509250929050565b5f5f5f5f60808587031215612cef57612cee612aa6565b5b5f612cfc87828801612ac9565b9450506020612d0d87828801612ac9565b9350506040612d1e87828801612ac9565b9250506060612d2f87828801612aff565b91505092959194509250565b5f5f5f60608486031215612d5257612d51612aa6565b5b5f612d5f86828701612ac9565b9350506020612d7086828701612aff565b9250506040612d8186828701612ac9565b9150509250925092565b612d9481612aaa565b82525050565b5f604082019050612dad5f830185612d8b565b612dba6020830184612d8b565b9392505050565b5f819050919050565b612dd381612dc1565b8114612ddd575f5ffd5b50565b5f81359050612dee81612dca565b92915050565b5f5f5f60608486031215612e0b57612e0a612aa6565b5b5f612e1886828701612ac9565b9350506020612e2986828701612aff565b9250506040612e3a86828701612de0565b9150509250925092565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f612e7b82612dc1565b9150612e8683612dc1565b9250828203905081811115612e9e57612e9d612e44565b5b92915050565b5f8160011c9050919050565b5f5f8291508390505b6001851115612ef957808604811115612ed557612ed4612e44565b5b6001851615612ee45780820291505b8081029050612ef285612ea4565b9450612eb9565b94509492505050565b5f82612f115760019050612fcc565b81612f1e575f9050612fcc565b8160018114612f345760028114612f3e57612f6d565b6001915050612fcc565b60ff841115612f5057612f4f612e44565b5b8360020a915084821115612f6757612f66612e44565b5b50612fcc565b5060208310610133831016604e8410600b8410161715612fa25782820a905083811115612f9d57612f9c612e44565b5b612fcc565b612faf8484846001612eb0565b92509050818404811115612fc657612fc5612e44565b5b81810290505b9392505050565b5f612fdd82612dc1565b9150612fe883612dc1565b92506130157fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8484612f02565b905092915050565b5f61302782612aaa565b915061303283612aaa565b925082820261304081612aaa565b91507f800000000000000000000000000000000000000000000000000000000000000084145f8412161561307757613076612e44565b5b828205841483151761308c5761308b612e44565b5b5092915050565b5f61309d82612aaa565b91507f800000000000000000000000000000000000000000000000000000000000000082036130cf576130ce612e44565b5b815f039050919050565b5f6130e382612aaa565b91506130ee83612aaa565b92508282019050828112155f8312168382125f84121516171561311457613113612e44565b5b92915050565b5f61312482612aaa565b915061312f83612aaa565b925082820390508181125f8412168282135f85121516171561315457613153612e44565b5b92915050565b5f81905092915050565b5f61316e82612b63565b613178818561315a565b9350613188818560208601612b7d565b80840191505092915050565b7f2e000000000000000000000000000000000000000000000000000000000000005f82015250565b5f6131c860018361315a565b91506131d382613194565b600182019050919050565b5f6131e98286613164565b91506131f58285613164565b9150613200826131bc565b915061320c8284613164565b9150819050949350505050565b7f65000000000000000000000000000000000000000000000000000000000000005f82015250565b5f61324d60018361315a565b915061325882613219565b600182019050919050565b5f61326e8287613164565b915061327a8286613164565b9150613285826131bc565b91506132918285613164565b915061329c82613241565b91506132a88284613164565b915081905095945050505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f6132ed82612aaa565b91506132f883612aaa565b925082613308576133076132b6565b5b60015f0383147f8000000000000000000000000000000000000000000000000000000000000000831416156133405761333f612e44565b5b828205905092915050565b5f61335582612dc1565b915061336083612dc1565b9250826133705761336f6132b6565b5b828204905092915050565b5f61338582612dc1565b915061339083612dc1565b925082820261339e81612dc1565b915082820484148315176133b5576133b4612e44565b5b5092915050565b7f706f773a2062617365206d75737420626520706f7369746976650000000000005f82015250565b5f6133f0601a83612b6d565b91506133fb826133bc565b602082019050919050565b5f6020820190508181035f83015261341d816133e4565b9050919050565b7f6c6f67206e6f6e2d706f736974697665000000000000000000000000000000005f82015250565b5f613458601083612b6d565b915061346382613424565b602082019050919050565b5f6020820190508181035f8301526134858161344c565b9050919050565b7f73686966743a207c697c20746f6f206c617267650000000000000000000000005f82015250565b5f6134c0601483612b6d565b91506134cb8261348c565b602082019050919050565b5f6020820190508181035f8301526134ed816134b4565b9050919050565b5f6134fe82612aaa565b915061350983612aaa565b925082613519576135186132b6565b5b828207905092915050565b5f61352e82612aaa565b91507f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036135605761355f612e44565b5b600182019050919050565b5f61357582612aaa565b91507f800000000000000000000000000000000000000000000000000000000000000082036135a7576135a6612e44565b5b600182039050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f61361682612dc1565b91505f820361362857613627612e44565b5b600182039050919050565b5f61363d82612dc1565b915061364883612dc1565b92508282019050808211156136605761365f612e44565b5b92915050565b5f81519050919050565b5f81905092915050565b5f61368482613666565b61368e8185613670565b935061369e818560208601612b7d565b80840191505092915050565b5f6136b58285613164565b91506136c1828461367a565b91508190509392505050565b7f56616c7565206d757374206265206e6f6e2d6e656761746976650000000000005f82015250565b5f613701601a83612b6d565b915061370c826136cd565b602082019050919050565b5f6020820190508181035f83015261372e816136f5565b9050919050565b5f61373f82612dc1565b915061374a83612dc1565b92508261375a576137596132b6565b5b828206905092915050565b5f61376f82612add565b915060ff820361378257613781612e44565b5b60018201905091905056fea26469706673582212204ba42decee95608383642c31be3e9e18576c0b560566a2675f62e6912f6cdd6364736f6c634300081e0033"
        }
      }
    }
  },
  "modules": {
    "/Users/williamcory/cavalre-contracts/playground/contracts/FloatCalculator.s.sol": {
      "id": "/Users/williamcory/cavalre-contracts/playground/contracts/FloatCalculator.s.sol",
      "rawCode": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {Float, FloatLib} from \"../../libraries/FloatLib.sol\";\nimport {FloatStrings} from \"../../libraries/FloatStrings.sol\";\n\ncontract FloatCalculator {\n    using FloatLib for Float;\n    using FloatLib for uint256;\n    using FloatStrings for Float;\n\n    // Helper to convert signed value to Float\n    function _toFloat(int256 a, uint8 decimals) internal pure returns (Float) {\n        if (a >= 0) {\n            return uint256(a).toFloat(decimals);\n        } else {\n            return uint256(-a).toFloat(decimals).minus();\n        }\n    }\n\n    // ==================\n    //     Arithmetic\n    // ==================\n\n    function add(int256 a, int256 b, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        return fa.plus(fb).toString();\n    }\n\n    function subtract(int256 a, int256 b, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        return fa.minus(fb).toString();\n    }\n\n    function multiply(int256 a, int256 b, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        return fa.times(fb).toString();\n    }\n\n    function divide(int256 a, int256 b, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        return fa.divide(fb).toString();\n    }\n\n    function negate(int256 a, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        return fa.minus().toString();\n    }\n\n    // ==================\n    //    Comparisons\n    // ==================\n\n    function isEqual(int256 a, int256 b, uint8 decimals) external pure returns (bool) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        return fa.isEQ(fb);\n    }\n\n    function isGreaterThan(int256 a, int256 b, uint8 decimals) external pure returns (bool) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        return fa.isGT(fb);\n    }\n\n    function isLessThan(int256 a, int256 b, uint8 decimals) external pure returns (bool) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        return fa.isLT(fb);\n    }\n\n    function isGreaterOrEqual(int256 a, int256 b, uint8 decimals) external pure returns (bool) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        return fa.isGEQ(fb);\n    }\n\n    function isLessOrEqual(int256 a, int256 b, uint8 decimals) external pure returns (bool) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        return fa.isLEQ(fb);\n    }\n\n    function isZero(int256 a, uint8 decimals) external pure returns (bool) {\n        Float fa = _toFloat(a, decimals);\n        return fa.isZero();\n    }\n\n    // ==================\n    //  Transformations\n    // ==================\n\n    function absoluteValue(int256 a, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        return fa.abs().toString();\n    }\n\n    function getParts(int256 a, uint8 decimals) external pure returns (string memory intPart, string memory fracPart) {\n        Float fa = _toFloat(a, decimals);\n        (Float intFloat, Float fracFloat) = fa.parts();\n        return (intFloat.toString(), fracFloat.toString());\n    }\n\n    function shift(int256 a, uint8 decimals, int256 places) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        return fa.shift(places).toString();\n    }\n\n    function roundTo(int256 a, uint8 decimals, uint256 digits) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        return fa.round(digits).toString();\n    }\n\n    // ==================\n    //  Special Functions\n    // ==================\n\n    function exponential(int256 a, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        return fa.exp().toString();\n    }\n\n    function naturalLog(int256 a, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        return fa.log().toString();\n    }\n\n    function power(int256 base, int256 exp, uint8 decimals) external pure returns (string memory) {\n        Float fb = _toFloat(base, decimals);\n        Float fe = _toFloat(exp, decimals);\n        return fb.pow(fe).toString();\n    }\n\n    function squareRoot(int256 a, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        return fa.sqrt().toString();\n    }\n\n    function fullMulDiv(int256 a, int256 b, int256 c, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        Float fc = _toFloat(c, decimals);\n        return FloatLib.fullMulDiv(fa, fb, fc).toString();\n    }\n\n    // ==================\n    //     Utilities\n    // ==================\n\n    function toFloatString(int256 value, uint8 decimals) external pure returns (string memory) {\n        return _toFloat(value, decimals).toString();\n    }\n\n    function getComponents(int256 value, uint8 decimals) external pure returns (int256 mantissa, int256 exponent) {\n        Float f = _toFloat(value, decimals);\n        return FloatLib.components(f);\n    }\n\n    function fromComponents(int256 mantissa, int256 exponent) external pure returns (string memory) {\n        return FloatLib.from(mantissa, exponent).toString();\n    }\n\n    function normalize(int256 mantissa, int256 exponent) external pure returns (string memory) {\n        return FloatLib.normalize(mantissa, exponent).toString();\n    }\n\n    // ==================\n    //     Constants\n    // ==================\n\n    function zero() external pure returns (string memory) {\n        return FloatLib.ZERO.toString();\n    }\n\n    function one() external pure returns (string memory) {\n        return FloatLib.ONE.toString();\n    }\n\n    function two() external pure returns (string memory) {\n        return FloatLib.TWO.toString();\n    }\n\n    function ten() external pure returns (string memory) {\n        return FloatLib.TEN.toString();\n    }\n\n    function pi() external pure returns (string memory) {\n        return FloatLib.PI.toString();\n    }\n}\n",
      "importedIds": [
        "/Users/williamcory/cavalre-contracts/libraries/FloatLib.sol",
        "/Users/williamcory/cavalre-contracts/libraries/FloatStrings.sol"
      ],
      "code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.26;\n\nimport {Float, FloatLib} from \"/Users/williamcory/cavalre-contracts/libraries/FloatLib.sol\";\nimport {FloatStrings} from \"/Users/williamcory/cavalre-contracts/libraries/FloatStrings.sol\";\n\ncontract FloatCalculator {\n    using FloatLib for Float;\n    using FloatLib for uint256;\n    using FloatStrings for Float;\n\n    // Helper to convert signed value to Float\n    function _toFloat(int256 a, uint8 decimals) internal pure returns (Float) {\n        if (a >= 0) {\n            return uint256(a).toFloat(decimals);\n        } else {\n            return uint256(-a).toFloat(decimals).minus();\n        }\n    }\n\n    // ==================\n    //     Arithmetic\n    // ==================\n\n    function add(int256 a, int256 b, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        return fa.plus(fb).toString();\n    }\n\n    function subtract(int256 a, int256 b, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        return fa.minus(fb).toString();\n    }\n\n    function multiply(int256 a, int256 b, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        return fa.times(fb).toString();\n    }\n\n    function divide(int256 a, int256 b, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        return fa.divide(fb).toString();\n    }\n\n    function negate(int256 a, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        return fa.minus().toString();\n    }\n\n    // ==================\n    //    Comparisons\n    // ==================\n\n    function isEqual(int256 a, int256 b, uint8 decimals) external pure returns (bool) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        return fa.isEQ(fb);\n    }\n\n    function isGreaterThan(int256 a, int256 b, uint8 decimals) external pure returns (bool) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        return fa.isGT(fb);\n    }\n\n    function isLessThan(int256 a, int256 b, uint8 decimals) external pure returns (bool) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        return fa.isLT(fb);\n    }\n\n    function isGreaterOrEqual(int256 a, int256 b, uint8 decimals) external pure returns (bool) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        return fa.isGEQ(fb);\n    }\n\n    function isLessOrEqual(int256 a, int256 b, uint8 decimals) external pure returns (bool) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        return fa.isLEQ(fb);\n    }\n\n    function isZero(int256 a, uint8 decimals) external pure returns (bool) {\n        Float fa = _toFloat(a, decimals);\n        return fa.isZero();\n    }\n\n    // ==================\n    //  Transformations\n    // ==================\n\n    function absoluteValue(int256 a, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        return fa.abs().toString();\n    }\n\n    function getParts(int256 a, uint8 decimals) external pure returns (string memory intPart, string memory fracPart) {\n        Float fa = _toFloat(a, decimals);\n        (Float intFloat, Float fracFloat) = fa.parts();\n        return (intFloat.toString(), fracFloat.toString());\n    }\n\n    function shift(int256 a, uint8 decimals, int256 places) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        return fa.shift(places).toString();\n    }\n\n    function roundTo(int256 a, uint8 decimals, uint256 digits) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        return fa.round(digits).toString();\n    }\n\n    // ==================\n    //  Special Functions\n    // ==================\n\n    function exponential(int256 a, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        return fa.exp().toString();\n    }\n\n    function naturalLog(int256 a, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        return fa.log().toString();\n    }\n\n    function power(int256 base, int256 exp, uint8 decimals) external pure returns (string memory) {\n        Float fb = _toFloat(base, decimals);\n        Float fe = _toFloat(exp, decimals);\n        return fb.pow(fe).toString();\n    }\n\n    function squareRoot(int256 a, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        return fa.sqrt().toString();\n    }\n\n    function fullMulDiv(int256 a, int256 b, int256 c, uint8 decimals) external pure returns (string memory) {\n        Float fa = _toFloat(a, decimals);\n        Float fb = _toFloat(b, decimals);\n        Float fc = _toFloat(c, decimals);\n        return FloatLib.fullMulDiv(fa, fb, fc).toString();\n    }\n\n    // ==================\n    //     Utilities\n    // ==================\n\n    function toFloatString(int256 value, uint8 decimals) external pure returns (string memory) {\n        return _toFloat(value, decimals).toString();\n    }\n\n    function getComponents(int256 value, uint8 decimals) external pure returns (int256 mantissa, int256 exponent) {\n        Float f = _toFloat(value, decimals);\n        return FloatLib.components(f);\n    }\n\n    function fromComponents(int256 mantissa, int256 exponent) external pure returns (string memory) {\n        return FloatLib.from(mantissa, exponent).toString();\n    }\n\n    function normalize(int256 mantissa, int256 exponent) external pure returns (string memory) {\n        return FloatLib.normalize(mantissa, exponent).toString();\n    }\n\n    // ==================\n    //     Constants\n    // ==================\n\n    function zero() external pure returns (string memory) {\n        return FloatLib.ZERO.toString();\n    }\n\n    function one() external pure returns (string memory) {\n        return FloatLib.ONE.toString();\n    }\n\n    function two() external pure returns (string memory) {\n        return FloatLib.TWO.toString();\n    }\n\n    function ten() external pure returns (string memory) {\n        return FloatLib.TEN.toString();\n    }\n\n    function pi() external pure returns (string memory) {\n        return FloatLib.PI.toString();\n    }\n}\n"
    },
    "/Users/williamcory/cavalre-contracts/libraries/FloatStrings.sol": {
      "id": "/Users/williamcory/cavalre-contracts/libraries/FloatStrings.sol",
      "rawCode": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {Float, FloatLib} from \"./FloatLib.sol\";\nimport {FixedPointMathLib} from \"solady/src/utils/FixedPointMathLib.sol\";\n\nlibrary FloatStrings {\n    using FixedPointMathLib for int256;\n    using FloatLib for Float;\n\n    // Most significant bit\n    function msb(int256 value_) internal pure returns (uint256) {\n        if (value_ == 0) {\n            return 0;\n        }\n\n        return toStringBytes(value_.abs()).length;\n    }\n\n    function shiftStringBytesLeft(bytes memory strBytes_, uint256 numChars_) public pure returns (bytes memory) {\n        bytes memory _result = new bytes(strBytes_.length + numChars_);\n\n        for (uint256 _i = 0; _i < _result.length; _i++) {\n            if (_i < strBytes_.length) {\n                _result[_i] = strBytes_[_i];\n            } else {\n                _result[_i] = \"0\";\n            }\n        }\n\n        return _result;\n    }\n\n    function shiftStringLeft(string memory str_, uint256 numChars_) public pure returns (string memory) {\n        return string(shiftStringBytesLeft(bytes(str_), numChars_));\n    }\n\n    function shiftStringBytesRight(bytes memory strBytes_, uint256 numChars_)\n        public\n        pure\n        returns (bytes memory _result, bytes memory _remainder)\n    {\n        uint256 _resultChars;\n        uint256 _remainderChars;\n        uint256 _excessChars;\n        if (numChars_ > strBytes_.length) {\n            _resultChars = 0;\n            _excessChars = numChars_ - strBytes_.length;\n            _result = new bytes(1);\n        } else {\n            _resultChars = strBytes_.length - numChars_;\n            _result = new bytes(_resultChars);\n        }\n        _remainderChars = numChars_;\n        _remainder = new bytes(_remainderChars);\n\n        for (uint256 _i = 0; _i < strBytes_.length; _i++) {\n            if (_i < _resultChars) {\n                _result[_i] = strBytes_[_i];\n            } else {\n                _remainder[_remainderChars - 1 + _resultChars - _i] =\n                    strBytes_[strBytes_.length - 1 + _resultChars - _i];\n            }\n        }\n\n        return (_result, _remainder);\n    }\n\n    function shiftStringRight(string memory str_, uint256 numChars_)\n        public\n        pure\n        returns (string memory _result, string memory _remainder)\n    {\n        bytes memory _strBytes = bytes(str_);\n        bytes memory _resultBytes;\n        bytes memory _remainderBytes;\n        (_resultBytes, _remainderBytes) = shiftStringBytesRight(_strBytes, numChars_);\n        _result = string(_resultBytes);\n        _remainder = string(_remainderBytes);\n    }\n\n    function toStringBytes(uint256 value_) public pure returns (bytes memory) {\n        // Handle the special case of zero.\n        if (value_ == 0) {\n            return bytes(\"0\");\n        }\n\n        // Determine the length of the decimal number.\n        uint256 _digits = digits(value_);\n\n        // Create a temporary byte array to fill with the digits of the number.\n        bytes memory _buffer = new bytes(_digits);\n        while (value_ != 0) {\n            _digits -= 1;\n            _buffer[_digits] = bytes1(uint8(48 + (value_ % 10)));\n            value_ /= 10;\n        }\n\n        // Convert the byte array to a string and return it.\n        return _buffer;\n    }\n\n    function toStringBytes(Float value_) internal pure returns (bytes memory, bytes memory) {\n        Float _norm = FloatLib.normalize(value_);\n        (Float _intPart, Float _fracPart) = FloatLib.parts(_norm);\n\n        // Integer part\n        bytes memory _integerPartBytes;\n        Float _absInt = FloatLib.abs(_intPart);\n        (int256 _intMantissa, int256 _intExponent) = FloatLib.components(_absInt);\n        if (_intMantissa == 0) {\n            _integerPartBytes = bytes(\"0\");\n        } else {\n            uint256 _intVal = FloatLib.toUInt(_absInt, 0);\n            _integerPartBytes = toStringBytes(_intVal);\n        }\n\n        // Fractional part\n        bytes memory _fractionalPartBytes;\n        Float _absFrac = FloatLib.abs(_fracPart);\n        (int256 _fracMantissa, int256 _fracExponent) = FloatLib.components(_absFrac);\n        if (_fracMantissa == 0) {\n            _fractionalPartBytes = bytes(\"0\");\n        } else {\n            bytes memory _mantBytes =\n                toStringBytes(uint256(int256(_fracMantissa >= 0 ? _fracMantissa : -_fracMantissa)));\n            uint256 _digits = uint256(-_fracExponent); // exponent is negative for fractional part\n            _fractionalPartBytes = new bytes(_digits);\n            for (uint256 _i = 0; _i < _digits; _i++) {\n                if (_i < _mantBytes.length) {\n                    _fractionalPartBytes[_digits - 1 - _i] = _mantBytes[_mantBytes.length - 1 - _i];\n                } else {\n                    _fractionalPartBytes[_digits - 1 - _i] = bytes1(\"0\");\n                }\n            }\n        }\n\n        return (_integerPartBytes, _fractionalPartBytes);\n    }\n\n    function toString(uint256 value_) public pure returns (string memory) {\n        return string(toStringBytes(value_));\n    }\n\n    function toString(int256 value_) public pure returns (string memory) {\n        return string(abi.encodePacked(value_ < 0 ? \"-\" : \"\", toStringBytes(value_.abs())));\n    }\n\n    function trimStringBytesRight(bytes memory strBytes_) public pure returns (bytes memory) {\n        uint256 _i = strBytes_.length - 1;\n        while (_i > 0 && strBytes_[_i] == \"0\") {\n            _i--;\n        }\n        bytes memory _result = new bytes(_i + 1);\n        for (uint256 _j = 0; _j < _i + 1; _j++) {\n            _result[_j] = strBytes_[_j];\n        }\n        return _result;\n    }\n\n    function trimStringRight(string memory str_) public pure returns (string memory) {\n        return string(trimStringBytesRight(bytes(str_)));\n    }\n\n    function toString(Float number_) internal pure returns (string memory) {\n        bytes memory _integerPartBytes;\n        bytes memory _fractionalPartBytes;\n\n        number_ = FloatLib.normalize(number_);\n\n        Float _max = FloatLib.normalize(int256(FloatLib.NORMALIZED_MANTISSA_MAX), 0);\n\n        int256 _ushift = int256(FloatLib.SIGNIFICANT_DIGITS) - 1;\n        int256 _ishift = _ushift;\n\n        (int256 _mantissa, int256 _exponent) = FloatLib.components(number_);\n        // int256 _mant = int256(_mantissa);\n        // int256 _exp = int256(_exponent);\n        if (FloatLib.abs(number_).isLT(_max) && _exponent >= -_ishift) {\n            (_integerPartBytes, _fractionalPartBytes) = toStringBytes(number_);\n            return string(\n                abi.encodePacked(\n                    _mantissa < 0 ? \"-\" : \"\",\n                    string(_integerPartBytes),\n                    \".\",\n                    string(trimStringBytesRight(_fractionalPartBytes))\n                )\n            );\n        } else {\n            (_integerPartBytes, _fractionalPartBytes) = toStringBytes(FloatLib.normalize(_mantissa, -_ishift));\n            return string(\n                abi.encodePacked(\n                    _mantissa < 0 ? \"-\" : \"\",\n                    string(_integerPartBytes),\n                    \".\",\n                    string(trimStringBytesRight(_fractionalPartBytes)),\n                    \"e\",\n                    toString(_exponent + _ishift)\n                )\n            );\n        }\n    }\n\n    function digits(uint256 number_) public pure returns (uint8) {\n        if (number_ == 0) {\n            return 1; // Zero has 1 significant digit\n        }\n\n        uint8 count = 0;\n        while (number_ != 0) {\n            count++;\n            number_ /= 10; // Remove the least significant digit\n        }\n        return count;\n    }\n}\n",
      "importedIds": [
        "/Users/williamcory/cavalre-contracts/libraries/FloatLib.sol",
        "/Users/williamcory/cavalre-contracts/node_modules/solady/src/utils/FixedPointMathLib.sol"
      ],
      "code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.26;\n\nimport {Float, FloatLib} from \"/Users/williamcory/cavalre-contracts/libraries/FloatLib.sol\";\nimport {FixedPointMathLib} from \"/Users/williamcory/cavalre-contracts/node_modules/solady/src/utils/FixedPointMathLib.sol\";\n\nlibrary FloatStrings {\n    using FixedPointMathLib for int256;\n    using FloatLib for Float;\n\n    // Most significant bit\n    function msb(int256 value_) internal pure returns (uint256) {\n        if (value_ == 0) {\n            return 0;\n        }\n\n        return toStringBytes(value_.abs()).length;\n    }\n\n    function shiftStringBytesLeft(bytes memory strBytes_, uint256 numChars_) public pure returns (bytes memory) {\n        bytes memory _result = new bytes(strBytes_.length + numChars_);\n\n        for (uint256 _i = 0; _i < _result.length; _i++) {\n            if (_i < strBytes_.length) {\n                _result[_i] = strBytes_[_i];\n            } else {\n                _result[_i] = \"0\";\n            }\n        }\n\n        return _result;\n    }\n\n    function shiftStringLeft(string memory str_, uint256 numChars_) public pure returns (string memory) {\n        return string(shiftStringBytesLeft(bytes(str_), numChars_));\n    }\n\n    function shiftStringBytesRight(bytes memory strBytes_, uint256 numChars_)\n        public\n        pure\n        returns (bytes memory _result, bytes memory _remainder)\n    {\n        uint256 _resultChars;\n        uint256 _remainderChars;\n        uint256 _excessChars;\n        if (numChars_ > strBytes_.length) {\n            _resultChars = 0;\n            _excessChars = numChars_ - strBytes_.length;\n            _result = new bytes(1);\n        } else {\n            _resultChars = strBytes_.length - numChars_;\n            _result = new bytes(_resultChars);\n        }\n        _remainderChars = numChars_;\n        _remainder = new bytes(_remainderChars);\n\n        for (uint256 _i = 0; _i < strBytes_.length; _i++) {\n            if (_i < _resultChars) {\n                _result[_i] = strBytes_[_i];\n            } else {\n                _remainder[_remainderChars - 1 + _resultChars - _i] =\n                    strBytes_[strBytes_.length - 1 + _resultChars - _i];\n            }\n        }\n\n        return (_result, _remainder);\n    }\n\n    function shiftStringRight(string memory str_, uint256 numChars_)\n        public\n        pure\n        returns (string memory _result, string memory _remainder)\n    {\n        bytes memory _strBytes = bytes(str_);\n        bytes memory _resultBytes;\n        bytes memory _remainderBytes;\n        (_resultBytes, _remainderBytes) = shiftStringBytesRight(_strBytes, numChars_);\n        _result = string(_resultBytes);\n        _remainder = string(_remainderBytes);\n    }\n\n    function toStringBytes(uint256 value_) public pure returns (bytes memory) {\n        // Handle the special case of zero.\n        if (value_ == 0) {\n            return bytes(\"0\");\n        }\n\n        // Determine the length of the decimal number.\n        uint256 _digits = digits(value_);\n\n        // Create a temporary byte array to fill with the digits of the number.\n        bytes memory _buffer = new bytes(_digits);\n        while (value_ != 0) {\n            _digits -= 1;\n            _buffer[_digits] = bytes1(uint8(48 + (value_ % 10)));\n            value_ /= 10;\n        }\n\n        // Convert the byte array to a string and return it.\n        return _buffer;\n    }\n\n    function toStringBytes(Float value_) internal pure returns (bytes memory, bytes memory) {\n        Float _norm = FloatLib.normalize(value_);\n        (Float _intPart, Float _fracPart) = FloatLib.parts(_norm);\n\n        // Integer part\n        bytes memory _integerPartBytes;\n        Float _absInt = FloatLib.abs(_intPart);\n        (int256 _intMantissa, int256 _intExponent) = FloatLib.components(_absInt);\n        if (_intMantissa == 0) {\n            _integerPartBytes = bytes(\"0\");\n        } else {\n            uint256 _intVal = FloatLib.toUInt(_absInt, 0);\n            _integerPartBytes = toStringBytes(_intVal);\n        }\n\n        // Fractional part\n        bytes memory _fractionalPartBytes;\n        Float _absFrac = FloatLib.abs(_fracPart);\n        (int256 _fracMantissa, int256 _fracExponent) = FloatLib.components(_absFrac);\n        if (_fracMantissa == 0) {\n            _fractionalPartBytes = bytes(\"0\");\n        } else {\n            bytes memory _mantBytes =\n                toStringBytes(uint256(int256(_fracMantissa >= 0 ? _fracMantissa : -_fracMantissa)));\n            uint256 _digits = uint256(-_fracExponent); // exponent is negative for fractional part\n            _fractionalPartBytes = new bytes(_digits);\n            for (uint256 _i = 0; _i < _digits; _i++) {\n                if (_i < _mantBytes.length) {\n                    _fractionalPartBytes[_digits - 1 - _i] = _mantBytes[_mantBytes.length - 1 - _i];\n                } else {\n                    _fractionalPartBytes[_digits - 1 - _i] = bytes1(\"0\");\n                }\n            }\n        }\n\n        return (_integerPartBytes, _fractionalPartBytes);\n    }\n\n    function toString(uint256 value_) public pure returns (string memory) {\n        return string(toStringBytes(value_));\n    }\n\n    function toString(int256 value_) public pure returns (string memory) {\n        return string(abi.encodePacked(value_ < 0 ? \"-\" : \"\", toStringBytes(value_.abs())));\n    }\n\n    function trimStringBytesRight(bytes memory strBytes_) public pure returns (bytes memory) {\n        uint256 _i = strBytes_.length - 1;\n        while (_i > 0 && strBytes_[_i] == \"0\") {\n            _i--;\n        }\n        bytes memory _result = new bytes(_i + 1);\n        for (uint256 _j = 0; _j < _i + 1; _j++) {\n            _result[_j] = strBytes_[_j];\n        }\n        return _result;\n    }\n\n    function trimStringRight(string memory str_) public pure returns (string memory) {\n        return string(trimStringBytesRight(bytes(str_)));\n    }\n\n    function toString(Float number_) internal pure returns (string memory) {\n        bytes memory _integerPartBytes;\n        bytes memory _fractionalPartBytes;\n\n        number_ = FloatLib.normalize(number_);\n\n        Float _max = FloatLib.normalize(int256(FloatLib.NORMALIZED_MANTISSA_MAX), 0);\n\n        int256 _ushift = int256(FloatLib.SIGNIFICANT_DIGITS) - 1;\n        int256 _ishift = _ushift;\n\n        (int256 _mantissa, int256 _exponent) = FloatLib.components(number_);\n        // int256 _mant = int256(_mantissa);\n        // int256 _exp = int256(_exponent);\n        if (FloatLib.abs(number_).isLT(_max) && _exponent >= -_ishift) {\n            (_integerPartBytes, _fractionalPartBytes) = toStringBytes(number_);\n            return string(\n                abi.encodePacked(\n                    _mantissa < 0 ? \"-\" : \"\",\n                    string(_integerPartBytes),\n                    \".\",\n                    string(trimStringBytesRight(_fractionalPartBytes))\n                )\n            );\n        } else {\n            (_integerPartBytes, _fractionalPartBytes) = toStringBytes(FloatLib.normalize(_mantissa, -_ishift));\n            return string(\n                abi.encodePacked(\n                    _mantissa < 0 ? \"-\" : \"\",\n                    string(_integerPartBytes),\n                    \".\",\n                    string(trimStringBytesRight(_fractionalPartBytes)),\n                    \"e\",\n                    toString(_exponent + _ishift)\n                )\n            );\n        }\n    }\n\n    function digits(uint256 number_) public pure returns (uint8) {\n        if (number_ == 0) {\n            return 1; // Zero has 1 significant digit\n        }\n\n        uint8 count = 0;\n        while (number_ != 0) {\n            count++;\n            number_ /= 10; // Remove the least significant digit\n        }\n        return count;\n    }\n}\n"
    },
    "/Users/williamcory/cavalre-contracts/node_modules/solady/src/utils/FixedPointMathLib.sol": {
      "id": "/Users/williamcory/cavalre-contracts/node_modules/solady/src/utils/FixedPointMathLib.sol",
      "rawCode": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error ExpOverflow();\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error FactorialOverflow();\n\n    /// @dev The operation failed, due to an overflow.\n    error RPowOverflow();\n\n    /// @dev The mantissa is too big to fit.\n    error MantissaOverflow();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error MulWadFailed();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error SMulWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error DivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error SDivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error MulDivFailed();\n\n    /// @dev The division failed, as the denominator is zero.\n    error DivFailed();\n\n    /// @dev The full precision multiply-divide operation failed, either due\n    /// to the result being larger than 256 bits, or a division by a zero.\n    error FullMulDivFailed();\n\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\n    error LnWadUndefined();\n\n    /// @dev The input outside the acceptable domain.\n    error OutOfDomain();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The scalar of ETH and most ERC20s.\n    uint256 internal constant WAD = 1e18;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if gt(x, div(not(0), y)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function sMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require((x == 0 || z / x == y) && !(x == -1 && y == type(int256).min))`.\n            if iszero(gt(or(iszero(x), eq(sdiv(z, x), y)), lt(not(x), eq(y, shl(255, 1))))) {\n                mstore(0x00, 0xedcd4dd4) // `SMulWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawMulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawSMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if iszero(eq(div(z, y), x)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := add(iszero(iszero(mod(z, WAD))), div(z, WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up, but without overflow checks.\n    function rawMulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function sDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, WAD)\n            // Equivalent to `require(y != 0 && ((x * WAD) / WAD == x))`.\n            if iszero(mul(y, eq(sdiv(z, WAD), x))) {\n                mstore(0x00, 0x5c43740d) // `SDivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawDivWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawSDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up, but without overflow and divide by zero checks.\n    function rawDivWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `x` to the power of `y`.\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\n    /// Note: This function is an approximation.\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Using `ln(x)` means `x` must be greater than 0.\n        return expWad((lnWad(x) * y) / int256(WAD));\n    }\n\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is less than 0.5 we return zero.\n            // This happens when `x <= (log(1e-18) * 1e18) ~ -4.15e19`.\n            if (x <= -41446531673892822313) return r;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // When the result is greater than `(2**255 - 1) / 1e18` we can not represent it as\n                // an int. This happens when `x >= floor(log((2**255 - 1) / 1e18) * 1e18) ≈ 135`.\n                if iszero(slt(x, 135305999368893231589)) {\n                    mstore(0x00, 0xa37bfec9) // `ExpOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            // `x` is now in the range `(-42, 136) * 1e18`. Convert to `(-42, 136) * 2**96`\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5 ** 18;\n\n            // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // `k` is in the range `[-61, 195]`.\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // `p` is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already `2**96` too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range `(0.09, 0.25) * 2**96`.\n\n            // We now need to multiply r by:\n            // - The scale factor `s ≈ 6.031367120`.\n            // - The `2**k` factor from the range reduction.\n            // - The `1e18 / 2**96` factor for base conversion.\n            // We do this all at once, with an intermediate result in `2**213`\n            // basis, so the final right shift is always by a positive amount.\n            r = int256(\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\n            );\n        }\n    }\n\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We want to convert `x` from `10**18` fixed point to `2**96` fixed point.\n            // We do this by multiplying by `2**96 / 10**18`. But since\n            // `ln(x * C) = ln(x) + ln(C)`, we can simply do nothing here\n            // and add `ln(2**96 / 10**18)` at the end.\n\n            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // We place the check here for more optimal stack operations.\n            if iszero(sgt(x, 0)) {\n                mstore(0x00, 0x1615e638) // `LnWadUndefined()`.\n                revert(0x1c, 0x04)\n            }\n            // forgefmt: disable-next-item\n            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            x := shr(159, shl(r, x))\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // `p` is made monic, we will multiply by a scale factor later.\n            // forgefmt: disable-next-item\n            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.\n                sar(96, mul(add(43456485725739037958740375743393,\n                sar(96, mul(add(24828157081833163892658089445524,\n                sar(96, mul(add(3273285459638523848632254066296,\n                    x), x))), x))), x)), 11111509109440967052023855526967)\n            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)\n            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)\n            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n\n            // `q` is monic by convention.\n            let q := add(5573035233440673466300451813936, x)\n            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))\n            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))\n            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))\n            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))\n            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))\n            q := add(909429971244387300277376558375, sar(96, mul(x, q)))\n\n            // `p / q` is in the range `(0, 0.125) * 2**96`.\n\n            // Finalization, we need to:\n            // - Multiply by the scale factor `s = 5.549…`.\n            // - Add `ln(2**96 / 10**18)`.\n            // - Add `k * ln(2)`.\n            // - Multiply by `10**18 / 2**96 = 5**18 >> 78`.\n\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already `2**96` too large.\n            p := sdiv(p, q)\n            // Multiply by the scaling factor: `s * 5**18 * 2**96`, base is now `5**18 * 2**192`.\n            p := mul(1677202110996718588342820967067443963516166, p)\n            // Add `ln(2) * k * 5**18 * 2**192`.\n            // forgefmt: disable-next-item\n            p := add(mul(16597577552685614221487285958193947469193820559219878177908093499208371, sub(159, r)), p)\n            // Add `ln(2**96 / 10**18) * 5**18 * 2**192`.\n            p := add(600920179829731861736702779321621459595472258049074101567377883020018308, p)\n            // Base conversion: mul `2**18 / 2**192`.\n            r := sar(174, p)\n        }\n    }\n\n    /// @dev Returns `W_0(x)`, denominated in `WAD`.\n    /// See: https://en.wikipedia.org/wiki/Lambert_W_function\n    /// a.k.a. Product log function. This is an approximation of the principal branch.\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lambertW0Wad(int256 x) internal pure returns (int256 w) {\n        // forgefmt: disable-next-item\n        unchecked {\n            if ((w = x) <= -367879441171442322) revert OutOfDomain(); // `x` less than `-1/e`.\n            (int256 wad, int256 p) = (int256(WAD), x);\n            uint256 c; // Whether we need to avoid catastrophic cancellation.\n            uint256 i = 4; // Number of iterations.\n            if (w <= 0x1ffffffffffff) {\n                if (-0x4000000000000 <= w) {\n                    i = 1; // Inputs near zero only take one step to converge.\n                } else if (w <= -0x3ffffffffffffff) {\n                    i = 32; // Inputs near `-1/e` take very long to converge.\n                }\n            } else if (uint256(w >> 63) == uint256(0)) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // Inline log2 for more performance, since the range is small.\n                    let v := shr(49, w)\n                    let l := shl(3, lt(0xff, v))\n                    l := add(or(l, byte(and(0x1f, shr(shr(l, v), 0x8421084210842108cc6318c6db6d54be)),\n                        0x0706060506020504060203020504030106050205030304010505030400000000)), 49)\n                    w := sdiv(shl(l, 7), byte(sub(l, 31), 0x0303030303030303040506080c13))\n                    c := gt(l, 60)\n                    i := add(2, add(gt(l, 53), c))\n                }\n            } else {\n                int256 ll = lnWad(w = lnWad(w));\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // `w = ln(x) - ln(ln(x)) + b * ln(ln(x)) / ln(x)`.\n                    w := add(sdiv(mul(ll, 1023715080943847266), w), sub(w, ll))\n                    i := add(3, iszero(shr(68, x)))\n                    c := iszero(shr(143, x))\n                }\n                if (c == uint256(0)) {\n                    do { // If `x` is big, use Newton's so that intermediate values won't overflow.\n                        int256 e = expWad(w);\n                        /// @solidity memory-safe-assembly\n                        assembly {\n                            let t := mul(w, div(e, wad))\n                            w := sub(w, sdiv(sub(t, x), div(add(e, t), wad)))\n                        }\n                        if (p <= w) break;\n                        p = w;\n                    } while (--i != uint256(0));\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        w := sub(w, sgt(w, 2))\n                    }\n                    return w;\n                }\n            }\n            do { // Otherwise, use Halley's for faster convergence.\n                int256 e = expWad(w);\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let t := add(w, wad)\n                    let s := sub(mul(w, e), mul(x, wad))\n                    w := sub(w, sdiv(mul(s, wad), sub(mul(e, t), sdiv(mul(add(t, wad), s), add(t, t)))))\n                }\n                if (p <= w) break;\n                p = w;\n            } while (--i != c);\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sub(w, sgt(w, 2))\n            }\n            // For certain ranges of `x`, we'll use the quadratic-rate recursive formula of\n            // R. Iacono and J.P. Boyd for the last iteration, to avoid catastrophic cancellation.\n            if (c == uint256(0)) return w;\n            int256 t = w | 1;\n            /// @solidity memory-safe-assembly\n            assembly {\n                x := sdiv(mul(x, wad), t)\n            }\n            x = (t * (wad + lnWad(x)));\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sdiv(x, add(wad, t))\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  GENERAL NUMBER UTILITIES                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `a * b == x * y`, with full precision.\n    function fullMulEq(uint256 a, uint256 b, uint256 x, uint256 y)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(mul(a, b), mul(x, y)), eq(mulmod(x, y, not(0)), mulmod(a, b, not(0))))\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/21/muldiv\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // 512-bit multiply `[p1 p0] = x * y`.\n            // Compute the product mod `2**256` and mod `2**256 - 1`\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that `product = p1 * 2**256 + p0`.\n\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`.\n            for {} 1 {} {\n                // If overflows.\n                if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n\n                    /*------------------- 512 by 256 division --------------------*/\n\n                    // Make division exact by subtracting the remainder from `[p1 p0]`.\n                    let r := mulmod(x, y, d) // Compute remainder using mulmod.\n                    let t := and(d, sub(0, d)) // The least significant bit of `d`. `t >= 1`.\n                    // Make sure `z` is less than `2**256`. Also prevents `d == 0`.\n                    // Placing the check here seems to give more optimal stack operations.\n                    if iszero(gt(d, p1)) {\n                        mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    d := div(d, t) // Divide `d` by `t`, which is a power of two.\n                    // Invert `d mod 2**256`\n                    // Now that `d` is an odd number, it has an inverse\n                    // modulo `2**256` such that `d * inv = 1 mod 2**256`.\n                    // Compute the inverse by starting with a seed that is correct\n                    // correct for four bits. That is, `d * inv = 1 mod 2**4`.\n                    let inv := xor(2, mul(3, d))\n                    // Now use Newton-Raphson iteration to improve the precision.\n                    // Thanks to Hensel's lifting lemma, this also works in modular\n                    // arithmetic, doubling the correct bits in each step.\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\n                    z :=\n                        mul(\n                            // Divide [p1 p0] by the factors of two.\n                            // Shift in bits from `p1` into `p0`. For this we need\n                            // to flip `t` such that it is `2**256 / t`.\n                            or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                            mul(sub(2, mul(d, inv)), inv) // inverse mod 2**256\n                        )\n                    break\n                }\n                z := div(z, d)\n                break\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Behavior is undefined if `d` is zero or the final result cannot fit in 256 bits.\n    /// Performs the full 512 bit calculation regardless.\n    function fullMulDivUnchecked(uint256 x, uint256 y, uint256 d)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            let mm := mulmod(x, y, not(0))\n            let p1 := sub(mm, add(z, lt(mm, z)))\n            let t := and(d, sub(0, d))\n            let r := mulmod(x, y, d)\n            d := div(d, t)\n            let inv := xor(2, mul(3, d))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            z :=\n                mul(\n                    or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                    mul(sub(2, mul(d, inv)), inv)\n                )\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Uniswap-v3-core under MIT license:\n    /// https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        z = fullMulDiv(x, y, d);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mulmod(x, y, d) {\n                z := add(z, 1)\n                if iszero(z) {\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / 2 ** n)` with full precision.\n    /// Throws if result overflows a uint256.\n    /// Credit to Philogy under MIT license:\n    /// https://github.com/SorellaLabs/angstrom/blob/main/contracts/src/libraries/X128MathLib.sol\n    function fullMulDivN(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`. We'll call this `z`.\n            for {} 1 {} {\n                if iszero(or(iszero(x), eq(div(z, x), y))) {\n                    let k := and(n, 0xff) // `n`, cleaned.\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n                    //         |      p1     |      z     |\n                    // Before: | p1_0 ¦ p1_1 | z_0  ¦ z_1 |\n                    // Final:  |   0  ¦ p1_0 | p1_1 ¦ z_0 |\n                    // Check that final `z` doesn't overflow by checking that p1_0 = 0.\n                    if iszero(shr(k, p1)) {\n                        z := add(shl(sub(256, k), p1), shr(k, z))\n                        break\n                    }\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                z := shr(and(n, 0xff), z)\n                break\n            }\n        }\n    }\n\n    /// @dev Returns `floor(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(z, d)\n        }\n    }\n\n    /// @dev Returns `ceil(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(z, d))), div(z, d))\n        }\n    }\n\n    /// @dev Returns `x`, the modular multiplicative inverse of `a`, such that `(a * x) % n == 1`.\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256 x) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let g := n\n            let r := mod(a, n)\n            for { let y := 1 } 1 {} {\n                let q := div(g, r)\n                let t := g\n                g := r\n                r := sub(t, mul(r, q))\n                let u := x\n                x := y\n                y := sub(u, mul(y, q))\n                if iszero(r) { break }\n            }\n            x := mul(eq(g, 1), add(x, mul(slt(x, 0), n)))\n        }\n    }\n\n    /// @dev Returns `ceil(x / d)`.\n    /// Reverts if `d` is zero.\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(d) {\n                mstore(0x00, 0x65244e4e) // `DivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`. Alias for `saturatingSub`.\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`.\n    function saturatingSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Returns `min(2 ** 256 - 1, x + y)`.\n    function saturatingAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(sub(0, lt(add(x, y), x)), add(x, y))\n        }\n    }\n\n    /// @dev Returns `min(2 ** 256 - 1, x * y)`.\n    function saturatingMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(sub(or(iszero(x), eq(div(mul(x, y), x), y)), 1), mul(x, y))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, address x, address y) internal pure returns (address z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `x != 0 ? x : y`, without branching.\n    function coalesce(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, mul(y, iszero(x)))\n        }\n    }\n\n    /// @dev Returns `x != bytes32(0) ? x : y`, without branching.\n    function coalesce(bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, mul(y, iszero(x)))\n        }\n    }\n\n    /// @dev Returns `x != address(0) ? x : y`, without branching.\n    function coalesce(address x, address y) internal pure returns (address z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, mul(y, iszero(shl(96, x))))\n        }\n    }\n\n    /// @dev Exponentiate `x` to `y` by squaring, denominated in base `b`.\n    /// Reverts if the computation overflows.\n    function rpow(uint256 x, uint256 y, uint256 b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(b, iszero(y)) // `0 ** 0 = 1`. Otherwise, `0 ** n = 0`.\n            if x {\n                z := xor(b, mul(xor(b, x), and(y, 1))) // `z = isEven(y) ? scale : x`\n                let half := shr(1, b) // Divide `b` by 2.\n                // Divide `y` by 2 every iteration.\n                for { y := shr(1, y) } y { y := shr(1, y) } {\n                    let xx := mul(x, x) // Store x squared.\n                    let xxRound := add(xx, half) // Round to the nearest number.\n                    // Revert if `xx + half` overflowed, or if `x ** 2` overflows.\n                    if or(lt(xxRound, xx), shr(128, x)) {\n                        mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                        revert(0x1c, 0x04)\n                    }\n                    x := div(xxRound, b) // Set `x` to scaled `xxRound`.\n                    // If `y` is odd:\n                    if and(y, 1) {\n                        let zx := mul(z, x) // Compute `z * x`.\n                        let zxRound := add(zx, half) // Round to the nearest number.\n                        // If `z * x` overflowed or `zx + half` overflowed:\n                        if or(xor(div(zx, x), z), lt(zxRound, zx)) {\n                            // Revert if `x` is non-zero.\n                            if x {\n                                mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                                revert(0x1c, 0x04)\n                            }\n                        }\n                        z := div(zxRound, b) // Return properly scaled `zxRound`.\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the square root of `x`, rounded down.\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // Let `y = x / 2**r`. We check `y >= 2**(k + 8)`\n            // but shift right by `k` bits to ensure that if `x >= 256`, then `y >= 256`.\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\n            z := shl(shr(1, r), z)\n\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\n\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\n\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\n\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\n            // Then we can estimate `sqrt(y)` using\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\n\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If `x+1` is a perfect square, the Babylonian method cycles between\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, rounded down.\n    /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:\n    /// https://github.com/pcaversaccio/snekmate/blob/main/src/snekmate/utils/math.vy\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // Makeshift lookup table to nudge the approximate log2 result.\n            z := div(shl(div(r, 3), shl(lt(0xf, shr(r, x)), 0xf)), xor(7, mod(r, 3)))\n            // Newton-Raphson's.\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            // Round down.\n            z := sub(z, lt(div(x, mul(z, z)), z))\n        }\n    }\n\n    /// @dev Returns the square root of `x`, denominated in `WAD`, rounded down.\n    function sqrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 18) return sqrt(x * 10 ** 18);\n            z = (1 + sqrt(x)) * 10 ** 9;\n            z = (fullMulDivUnchecked(x, 10 ** 18, z) + z) >> 1;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sub(z, gt(999999999999999999, sub(mulmod(z, z, x), 1))) // Round down.\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, denominated in `WAD`, rounded down.\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 36) return cbrt(x * 10 ** 36);\n            z = (1 + cbrt(x)) * 10 ** 12;\n            z = (fullMulDivUnchecked(x, 10 ** 36, z * z) + z + z) / 3;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let p := x\n            for {} 1 {} {\n                if iszero(shr(229, p)) {\n                    if iszero(shr(199, p)) {\n                        p := mul(p, 100000000000000000) // 10 ** 17.\n                        break\n                    }\n                    p := mul(p, 100000000) // 10 ** 8.\n                    break\n                }\n                if iszero(shr(249, p)) { p := mul(p, 100) }\n                break\n            }\n            let t := mulmod(mul(z, z), z, p)\n            z := sub(z, gt(lt(t, shr(1, p)), iszero(t))) // Round down.\n        }\n    }\n\n    /// @dev Returns the factorial of `x`.\n    function factorial(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := 1\n            if iszero(lt(x, 58)) {\n                mstore(0x00, 0xaba0f2a2) // `FactorialOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            for {} x { x := sub(x, 1) } { z := mul(z, x) }\n        }\n    }\n\n    /// @dev Returns the log2 of `x`.\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\n    /// Returns 0 if `x` is zero.\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020504060203020504030106050205030304010505030400000000))\n        }\n    }\n\n    /// @dev Returns the log2 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\n        r = log2(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(r, 1), x))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log10(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, 100000000000000000000000000000000000000)) {\n                x := div(x, 100000000000000000000000000000000000000)\n                r := 38\n            }\n            if iszero(lt(x, 100000000000000000000)) {\n                x := div(x, 100000000000000000000)\n                r := add(r, 20)\n            }\n            if iszero(lt(x, 10000000000)) {\n                x := div(x, 10000000000)\n                r := add(r, 10)\n            }\n            if iszero(lt(x, 100000)) {\n                x := div(x, 100000)\n                r := add(r, 5)\n            }\n            r := add(r, add(gt(x, 9), add(gt(x, 99), add(gt(x, 999), gt(x, 9999)))))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log10Up(uint256 x) internal pure returns (uint256 r) {\n        r = log10(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(exp(10, r), x))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(shr(3, r), lt(0xff, shr(r, x)))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log256Up(uint256 x) internal pure returns (uint256 r) {\n        r = log256(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(shl(3, r), 1), x))\n        }\n    }\n\n    /// @dev Returns the scientific notation format `mantissa * 10 ** exponent` of `x`.\n    /// Useful for compressing prices (e.g. using 25 bit mantissa and 7 bit exponent).\n    function sci(uint256 x) internal pure returns (uint256 mantissa, uint256 exponent) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mantissa := x\n            if mantissa {\n                if iszero(mod(mantissa, 1000000000000000000000000000000000)) {\n                    mantissa := div(mantissa, 1000000000000000000000000000000000)\n                    exponent := 33\n                }\n                if iszero(mod(mantissa, 10000000000000000000)) {\n                    mantissa := div(mantissa, 10000000000000000000)\n                    exponent := add(exponent, 19)\n                }\n                if iszero(mod(mantissa, 1000000000000)) {\n                    mantissa := div(mantissa, 1000000000000)\n                    exponent := add(exponent, 12)\n                }\n                if iszero(mod(mantissa, 1000000)) {\n                    mantissa := div(mantissa, 1000000)\n                    exponent := add(exponent, 6)\n                }\n                if iszero(mod(mantissa, 10000)) {\n                    mantissa := div(mantissa, 10000)\n                    exponent := add(exponent, 4)\n                }\n                if iszero(mod(mantissa, 100)) {\n                    mantissa := div(mantissa, 100)\n                    exponent := add(exponent, 2)\n                }\n                if iszero(mod(mantissa, 10)) {\n                    mantissa := div(mantissa, 10)\n                    exponent := add(exponent, 1)\n                }\n            }\n        }\n    }\n\n    /// @dev Convenience function for packing `x` into a smaller number using `sci`.\n    /// The `mantissa` will be in bits [7..255] (the upper 249 bits).\n    /// The `exponent` will be in bits [0..6] (the lower 7 bits).\n    /// Use `SafeCastLib` to safely ensure that the `packed` number is small\n    /// enough to fit in the desired unsigned integer type:\n    /// ```\n    ///     uint32 packed = SafeCastLib.toUint32(FixedPointMathLib.packSci(777 ether));\n    /// ```\n    function packSci(uint256 x) internal pure returns (uint256 packed) {\n        (x, packed) = sci(x); // Reuse for `mantissa` and `exponent`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            if shr(249, x) {\n                mstore(0x00, 0xce30380c) // `MantissaOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            packed := or(shl(7, x), packed)\n        }\n    }\n\n    /// @dev Convenience function for unpacking a packed number from `packSci`.\n    function unpackSci(uint256 packed) internal pure returns (uint256 unpacked) {\n        unchecked {\n            unpacked = (packed >> 7) * 10 ** (packed & 0x7f);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards zero.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = (x & y) + ((x ^ y) >> 1);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards negative infinity.\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @dev Returns the absolute value of `x`.\n    function abs(int256 x) internal pure returns (uint256 z) {\n        unchecked {\n            z = (uint256(x) + uint256(x >> 255)) ^ uint256(x >> 255);\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, gt(x, y)), sub(y, x)), gt(x, y))\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, sgt(x, y)), sub(y, x)), sgt(x, y))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), lt(y, x)))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), slt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), gt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), gt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), lt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), sgt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), slt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns greatest common divisor of `x` and `y`.\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { z := x } y {} {\n                let t := y\n                y := mod(z, y)\n                z := t\n            }\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`,\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(uint256 a, uint256 b, uint256 t, uint256 begin, uint256 end)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        unchecked {\n            if (b >= a) return a + fullMulDiv(b - a, t - begin, end - begin);\n            return a - fullMulDiv(a - b, t - begin, end - begin);\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`.\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(int256 a, int256 b, int256 t, int256 begin, int256 end)\n        internal\n        pure\n        returns (int256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        // forgefmt: disable-next-item\n        unchecked {\n            if (b >= a) return int256(uint256(a) + fullMulDiv(uint256(b - a),\n                uint256(t - begin), uint256(end - begin)));\n            return int256(uint256(a) - fullMulDiv(uint256(a - b),\n                uint256(t - begin), uint256(end - begin)));\n        }\n    }\n\n    /// @dev Returns if `x` is an even number. Some people may need this.\n    function isEven(uint256 x) internal pure returns (bool) {\n        return x & uint256(1) == uint256(0);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   RAW NUMBER OPERATIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(x, y)\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mod(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := smod(x, y)\n        }\n    }\n\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := addmod(x, y, d)\n        }\n    }\n\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mulmod(x, y, d)\n        }\n    }\n}\n",
      "importedIds": [],
      "code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error ExpOverflow();\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error FactorialOverflow();\n\n    /// @dev The operation failed, due to an overflow.\n    error RPowOverflow();\n\n    /// @dev The mantissa is too big to fit.\n    error MantissaOverflow();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error MulWadFailed();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error SMulWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error DivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error SDivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error MulDivFailed();\n\n    /// @dev The division failed, as the denominator is zero.\n    error DivFailed();\n\n    /// @dev The full precision multiply-divide operation failed, either due\n    /// to the result being larger than 256 bits, or a division by a zero.\n    error FullMulDivFailed();\n\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\n    error LnWadUndefined();\n\n    /// @dev The input outside the acceptable domain.\n    error OutOfDomain();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The scalar of ETH and most ERC20s.\n    uint256 internal constant WAD = 1e18;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if gt(x, div(not(0), y)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function sMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require((x == 0 || z / x == y) && !(x == -1 && y == type(int256).min))`.\n            if iszero(gt(or(iszero(x), eq(sdiv(z, x), y)), lt(not(x), eq(y, shl(255, 1))))) {\n                mstore(0x00, 0xedcd4dd4) // `SMulWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawMulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawSMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if iszero(eq(div(z, y), x)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := add(iszero(iszero(mod(z, WAD))), div(z, WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up, but without overflow checks.\n    function rawMulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function sDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, WAD)\n            // Equivalent to `require(y != 0 && ((x * WAD) / WAD == x))`.\n            if iszero(mul(y, eq(sdiv(z, WAD), x))) {\n                mstore(0x00, 0x5c43740d) // `SDivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawDivWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawSDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up, but without overflow and divide by zero checks.\n    function rawDivWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `x` to the power of `y`.\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\n    /// Note: This function is an approximation.\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Using `ln(x)` means `x` must be greater than 0.\n        return expWad((lnWad(x) * y) / int256(WAD));\n    }\n\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is less than 0.5 we return zero.\n            // This happens when `x <= (log(1e-18) * 1e18) ~ -4.15e19`.\n            if (x <= -41446531673892822313) return r;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // When the result is greater than `(2**255 - 1) / 1e18` we can not represent it as\n                // an int. This happens when `x >= floor(log((2**255 - 1) / 1e18) * 1e18) ≈ 135`.\n                if iszero(slt(x, 135305999368893231589)) {\n                    mstore(0x00, 0xa37bfec9) // `ExpOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            // `x` is now in the range `(-42, 136) * 1e18`. Convert to `(-42, 136) * 2**96`\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5 ** 18;\n\n            // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // `k` is in the range `[-61, 195]`.\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // `p` is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already `2**96` too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range `(0.09, 0.25) * 2**96`.\n\n            // We now need to multiply r by:\n            // - The scale factor `s ≈ 6.031367120`.\n            // - The `2**k` factor from the range reduction.\n            // - The `1e18 / 2**96` factor for base conversion.\n            // We do this all at once, with an intermediate result in `2**213`\n            // basis, so the final right shift is always by a positive amount.\n            r = int256(\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\n            );\n        }\n    }\n\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We want to convert `x` from `10**18` fixed point to `2**96` fixed point.\n            // We do this by multiplying by `2**96 / 10**18`. But since\n            // `ln(x * C) = ln(x) + ln(C)`, we can simply do nothing here\n            // and add `ln(2**96 / 10**18)` at the end.\n\n            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // We place the check here for more optimal stack operations.\n            if iszero(sgt(x, 0)) {\n                mstore(0x00, 0x1615e638) // `LnWadUndefined()`.\n                revert(0x1c, 0x04)\n            }\n            // forgefmt: disable-next-item\n            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            x := shr(159, shl(r, x))\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // `p` is made monic, we will multiply by a scale factor later.\n            // forgefmt: disable-next-item\n            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.\n                sar(96, mul(add(43456485725739037958740375743393,\n                sar(96, mul(add(24828157081833163892658089445524,\n                sar(96, mul(add(3273285459638523848632254066296,\n                    x), x))), x))), x)), 11111509109440967052023855526967)\n            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)\n            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)\n            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n\n            // `q` is monic by convention.\n            let q := add(5573035233440673466300451813936, x)\n            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))\n            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))\n            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))\n            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))\n            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))\n            q := add(909429971244387300277376558375, sar(96, mul(x, q)))\n\n            // `p / q` is in the range `(0, 0.125) * 2**96`.\n\n            // Finalization, we need to:\n            // - Multiply by the scale factor `s = 5.549…`.\n            // - Add `ln(2**96 / 10**18)`.\n            // - Add `k * ln(2)`.\n            // - Multiply by `10**18 / 2**96 = 5**18 >> 78`.\n\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already `2**96` too large.\n            p := sdiv(p, q)\n            // Multiply by the scaling factor: `s * 5**18 * 2**96`, base is now `5**18 * 2**192`.\n            p := mul(1677202110996718588342820967067443963516166, p)\n            // Add `ln(2) * k * 5**18 * 2**192`.\n            // forgefmt: disable-next-item\n            p := add(mul(16597577552685614221487285958193947469193820559219878177908093499208371, sub(159, r)), p)\n            // Add `ln(2**96 / 10**18) * 5**18 * 2**192`.\n            p := add(600920179829731861736702779321621459595472258049074101567377883020018308, p)\n            // Base conversion: mul `2**18 / 2**192`.\n            r := sar(174, p)\n        }\n    }\n\n    /// @dev Returns `W_0(x)`, denominated in `WAD`.\n    /// See: https://en.wikipedia.org/wiki/Lambert_W_function\n    /// a.k.a. Product log function. This is an approximation of the principal branch.\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lambertW0Wad(int256 x) internal pure returns (int256 w) {\n        // forgefmt: disable-next-item\n        unchecked {\n            if ((w = x) <= -367879441171442322) revert OutOfDomain(); // `x` less than `-1/e`.\n            (int256 wad, int256 p) = (int256(WAD), x);\n            uint256 c; // Whether we need to avoid catastrophic cancellation.\n            uint256 i = 4; // Number of iterations.\n            if (w <= 0x1ffffffffffff) {\n                if (-0x4000000000000 <= w) {\n                    i = 1; // Inputs near zero only take one step to converge.\n                } else if (w <= -0x3ffffffffffffff) {\n                    i = 32; // Inputs near `-1/e` take very long to converge.\n                }\n            } else if (uint256(w >> 63) == uint256(0)) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // Inline log2 for more performance, since the range is small.\n                    let v := shr(49, w)\n                    let l := shl(3, lt(0xff, v))\n                    l := add(or(l, byte(and(0x1f, shr(shr(l, v), 0x8421084210842108cc6318c6db6d54be)),\n                        0x0706060506020504060203020504030106050205030304010505030400000000)), 49)\n                    w := sdiv(shl(l, 7), byte(sub(l, 31), 0x0303030303030303040506080c13))\n                    c := gt(l, 60)\n                    i := add(2, add(gt(l, 53), c))\n                }\n            } else {\n                int256 ll = lnWad(w = lnWad(w));\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // `w = ln(x) - ln(ln(x)) + b * ln(ln(x)) / ln(x)`.\n                    w := add(sdiv(mul(ll, 1023715080943847266), w), sub(w, ll))\n                    i := add(3, iszero(shr(68, x)))\n                    c := iszero(shr(143, x))\n                }\n                if (c == uint256(0)) {\n                    do { // If `x` is big, use Newton's so that intermediate values won't overflow.\n                        int256 e = expWad(w);\n                        /// @solidity memory-safe-assembly\n                        assembly {\n                            let t := mul(w, div(e, wad))\n                            w := sub(w, sdiv(sub(t, x), div(add(e, t), wad)))\n                        }\n                        if (p <= w) break;\n                        p = w;\n                    } while (--i != uint256(0));\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        w := sub(w, sgt(w, 2))\n                    }\n                    return w;\n                }\n            }\n            do { // Otherwise, use Halley's for faster convergence.\n                int256 e = expWad(w);\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let t := add(w, wad)\n                    let s := sub(mul(w, e), mul(x, wad))\n                    w := sub(w, sdiv(mul(s, wad), sub(mul(e, t), sdiv(mul(add(t, wad), s), add(t, t)))))\n                }\n                if (p <= w) break;\n                p = w;\n            } while (--i != c);\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sub(w, sgt(w, 2))\n            }\n            // For certain ranges of `x`, we'll use the quadratic-rate recursive formula of\n            // R. Iacono and J.P. Boyd for the last iteration, to avoid catastrophic cancellation.\n            if (c == uint256(0)) return w;\n            int256 t = w | 1;\n            /// @solidity memory-safe-assembly\n            assembly {\n                x := sdiv(mul(x, wad), t)\n            }\n            x = (t * (wad + lnWad(x)));\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sdiv(x, add(wad, t))\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  GENERAL NUMBER UTILITIES                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `a * b == x * y`, with full precision.\n    function fullMulEq(uint256 a, uint256 b, uint256 x, uint256 y)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(mul(a, b), mul(x, y)), eq(mulmod(x, y, not(0)), mulmod(a, b, not(0))))\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/21/muldiv\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // 512-bit multiply `[p1 p0] = x * y`.\n            // Compute the product mod `2**256` and mod `2**256 - 1`\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that `product = p1 * 2**256 + p0`.\n\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`.\n            for {} 1 {} {\n                // If overflows.\n                if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n\n                    /*------------------- 512 by 256 division --------------------*/\n\n                    // Make division exact by subtracting the remainder from `[p1 p0]`.\n                    let r := mulmod(x, y, d) // Compute remainder using mulmod.\n                    let t := and(d, sub(0, d)) // The least significant bit of `d`. `t >= 1`.\n                    // Make sure `z` is less than `2**256`. Also prevents `d == 0`.\n                    // Placing the check here seems to give more optimal stack operations.\n                    if iszero(gt(d, p1)) {\n                        mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    d := div(d, t) // Divide `d` by `t`, which is a power of two.\n                    // Invert `d mod 2**256`\n                    // Now that `d` is an odd number, it has an inverse\n                    // modulo `2**256` such that `d * inv = 1 mod 2**256`.\n                    // Compute the inverse by starting with a seed that is correct\n                    // correct for four bits. That is, `d * inv = 1 mod 2**4`.\n                    let inv := xor(2, mul(3, d))\n                    // Now use Newton-Raphson iteration to improve the precision.\n                    // Thanks to Hensel's lifting lemma, this also works in modular\n                    // arithmetic, doubling the correct bits in each step.\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\n                    z :=\n                        mul(\n                            // Divide [p1 p0] by the factors of two.\n                            // Shift in bits from `p1` into `p0`. For this we need\n                            // to flip `t` such that it is `2**256 / t`.\n                            or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                            mul(sub(2, mul(d, inv)), inv) // inverse mod 2**256\n                        )\n                    break\n                }\n                z := div(z, d)\n                break\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Behavior is undefined if `d` is zero or the final result cannot fit in 256 bits.\n    /// Performs the full 512 bit calculation regardless.\n    function fullMulDivUnchecked(uint256 x, uint256 y, uint256 d)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            let mm := mulmod(x, y, not(0))\n            let p1 := sub(mm, add(z, lt(mm, z)))\n            let t := and(d, sub(0, d))\n            let r := mulmod(x, y, d)\n            d := div(d, t)\n            let inv := xor(2, mul(3, d))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            z :=\n                mul(\n                    or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                    mul(sub(2, mul(d, inv)), inv)\n                )\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Uniswap-v3-core under MIT license:\n    /// https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        z = fullMulDiv(x, y, d);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mulmod(x, y, d) {\n                z := add(z, 1)\n                if iszero(z) {\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / 2 ** n)` with full precision.\n    /// Throws if result overflows a uint256.\n    /// Credit to Philogy under MIT license:\n    /// https://github.com/SorellaLabs/angstrom/blob/main/contracts/src/libraries/X128MathLib.sol\n    function fullMulDivN(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`. We'll call this `z`.\n            for {} 1 {} {\n                if iszero(or(iszero(x), eq(div(z, x), y))) {\n                    let k := and(n, 0xff) // `n`, cleaned.\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n                    //         |      p1     |      z     |\n                    // Before: | p1_0 ¦ p1_1 | z_0  ¦ z_1 |\n                    // Final:  |   0  ¦ p1_0 | p1_1 ¦ z_0 |\n                    // Check that final `z` doesn't overflow by checking that p1_0 = 0.\n                    if iszero(shr(k, p1)) {\n                        z := add(shl(sub(256, k), p1), shr(k, z))\n                        break\n                    }\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                z := shr(and(n, 0xff), z)\n                break\n            }\n        }\n    }\n\n    /// @dev Returns `floor(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(z, d)\n        }\n    }\n\n    /// @dev Returns `ceil(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(z, d))), div(z, d))\n        }\n    }\n\n    /// @dev Returns `x`, the modular multiplicative inverse of `a`, such that `(a * x) % n == 1`.\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256 x) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let g := n\n            let r := mod(a, n)\n            for { let y := 1 } 1 {} {\n                let q := div(g, r)\n                let t := g\n                g := r\n                r := sub(t, mul(r, q))\n                let u := x\n                x := y\n                y := sub(u, mul(y, q))\n                if iszero(r) { break }\n            }\n            x := mul(eq(g, 1), add(x, mul(slt(x, 0), n)))\n        }\n    }\n\n    /// @dev Returns `ceil(x / d)`.\n    /// Reverts if `d` is zero.\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(d) {\n                mstore(0x00, 0x65244e4e) // `DivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`. Alias for `saturatingSub`.\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`.\n    function saturatingSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Returns `min(2 ** 256 - 1, x + y)`.\n    function saturatingAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(sub(0, lt(add(x, y), x)), add(x, y))\n        }\n    }\n\n    /// @dev Returns `min(2 ** 256 - 1, x * y)`.\n    function saturatingMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(sub(or(iszero(x), eq(div(mul(x, y), x), y)), 1), mul(x, y))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, address x, address y) internal pure returns (address z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `x != 0 ? x : y`, without branching.\n    function coalesce(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, mul(y, iszero(x)))\n        }\n    }\n\n    /// @dev Returns `x != bytes32(0) ? x : y`, without branching.\n    function coalesce(bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, mul(y, iszero(x)))\n        }\n    }\n\n    /// @dev Returns `x != address(0) ? x : y`, without branching.\n    function coalesce(address x, address y) internal pure returns (address z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, mul(y, iszero(shl(96, x))))\n        }\n    }\n\n    /// @dev Exponentiate `x` to `y` by squaring, denominated in base `b`.\n    /// Reverts if the computation overflows.\n    function rpow(uint256 x, uint256 y, uint256 b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(b, iszero(y)) // `0 ** 0 = 1`. Otherwise, `0 ** n = 0`.\n            if x {\n                z := xor(b, mul(xor(b, x), and(y, 1))) // `z = isEven(y) ? scale : x`\n                let half := shr(1, b) // Divide `b` by 2.\n                // Divide `y` by 2 every iteration.\n                for { y := shr(1, y) } y { y := shr(1, y) } {\n                    let xx := mul(x, x) // Store x squared.\n                    let xxRound := add(xx, half) // Round to the nearest number.\n                    // Revert if `xx + half` overflowed, or if `x ** 2` overflows.\n                    if or(lt(xxRound, xx), shr(128, x)) {\n                        mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                        revert(0x1c, 0x04)\n                    }\n                    x := div(xxRound, b) // Set `x` to scaled `xxRound`.\n                    // If `y` is odd:\n                    if and(y, 1) {\n                        let zx := mul(z, x) // Compute `z * x`.\n                        let zxRound := add(zx, half) // Round to the nearest number.\n                        // If `z * x` overflowed or `zx + half` overflowed:\n                        if or(xor(div(zx, x), z), lt(zxRound, zx)) {\n                            // Revert if `x` is non-zero.\n                            if x {\n                                mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                                revert(0x1c, 0x04)\n                            }\n                        }\n                        z := div(zxRound, b) // Return properly scaled `zxRound`.\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the square root of `x`, rounded down.\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // Let `y = x / 2**r`. We check `y >= 2**(k + 8)`\n            // but shift right by `k` bits to ensure that if `x >= 256`, then `y >= 256`.\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\n            z := shl(shr(1, r), z)\n\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\n\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\n\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\n\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\n            // Then we can estimate `sqrt(y)` using\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\n\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If `x+1` is a perfect square, the Babylonian method cycles between\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, rounded down.\n    /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:\n    /// https://github.com/pcaversaccio/snekmate/blob/main/src/snekmate/utils/math.vy\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // Makeshift lookup table to nudge the approximate log2 result.\n            z := div(shl(div(r, 3), shl(lt(0xf, shr(r, x)), 0xf)), xor(7, mod(r, 3)))\n            // Newton-Raphson's.\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            // Round down.\n            z := sub(z, lt(div(x, mul(z, z)), z))\n        }\n    }\n\n    /// @dev Returns the square root of `x`, denominated in `WAD`, rounded down.\n    function sqrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 18) return sqrt(x * 10 ** 18);\n            z = (1 + sqrt(x)) * 10 ** 9;\n            z = (fullMulDivUnchecked(x, 10 ** 18, z) + z) >> 1;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sub(z, gt(999999999999999999, sub(mulmod(z, z, x), 1))) // Round down.\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, denominated in `WAD`, rounded down.\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 36) return cbrt(x * 10 ** 36);\n            z = (1 + cbrt(x)) * 10 ** 12;\n            z = (fullMulDivUnchecked(x, 10 ** 36, z * z) + z + z) / 3;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let p := x\n            for {} 1 {} {\n                if iszero(shr(229, p)) {\n                    if iszero(shr(199, p)) {\n                        p := mul(p, 100000000000000000) // 10 ** 17.\n                        break\n                    }\n                    p := mul(p, 100000000) // 10 ** 8.\n                    break\n                }\n                if iszero(shr(249, p)) { p := mul(p, 100) }\n                break\n            }\n            let t := mulmod(mul(z, z), z, p)\n            z := sub(z, gt(lt(t, shr(1, p)), iszero(t))) // Round down.\n        }\n    }\n\n    /// @dev Returns the factorial of `x`.\n    function factorial(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := 1\n            if iszero(lt(x, 58)) {\n                mstore(0x00, 0xaba0f2a2) // `FactorialOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            for {} x { x := sub(x, 1) } { z := mul(z, x) }\n        }\n    }\n\n    /// @dev Returns the log2 of `x`.\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\n    /// Returns 0 if `x` is zero.\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020504060203020504030106050205030304010505030400000000))\n        }\n    }\n\n    /// @dev Returns the log2 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\n        r = log2(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(r, 1), x))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log10(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, 100000000000000000000000000000000000000)) {\n                x := div(x, 100000000000000000000000000000000000000)\n                r := 38\n            }\n            if iszero(lt(x, 100000000000000000000)) {\n                x := div(x, 100000000000000000000)\n                r := add(r, 20)\n            }\n            if iszero(lt(x, 10000000000)) {\n                x := div(x, 10000000000)\n                r := add(r, 10)\n            }\n            if iszero(lt(x, 100000)) {\n                x := div(x, 100000)\n                r := add(r, 5)\n            }\n            r := add(r, add(gt(x, 9), add(gt(x, 99), add(gt(x, 999), gt(x, 9999)))))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log10Up(uint256 x) internal pure returns (uint256 r) {\n        r = log10(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(exp(10, r), x))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(shr(3, r), lt(0xff, shr(r, x)))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log256Up(uint256 x) internal pure returns (uint256 r) {\n        r = log256(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(shl(3, r), 1), x))\n        }\n    }\n\n    /// @dev Returns the scientific notation format `mantissa * 10 ** exponent` of `x`.\n    /// Useful for compressing prices (e.g. using 25 bit mantissa and 7 bit exponent).\n    function sci(uint256 x) internal pure returns (uint256 mantissa, uint256 exponent) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mantissa := x\n            if mantissa {\n                if iszero(mod(mantissa, 1000000000000000000000000000000000)) {\n                    mantissa := div(mantissa, 1000000000000000000000000000000000)\n                    exponent := 33\n                }\n                if iszero(mod(mantissa, 10000000000000000000)) {\n                    mantissa := div(mantissa, 10000000000000000000)\n                    exponent := add(exponent, 19)\n                }\n                if iszero(mod(mantissa, 1000000000000)) {\n                    mantissa := div(mantissa, 1000000000000)\n                    exponent := add(exponent, 12)\n                }\n                if iszero(mod(mantissa, 1000000)) {\n                    mantissa := div(mantissa, 1000000)\n                    exponent := add(exponent, 6)\n                }\n                if iszero(mod(mantissa, 10000)) {\n                    mantissa := div(mantissa, 10000)\n                    exponent := add(exponent, 4)\n                }\n                if iszero(mod(mantissa, 100)) {\n                    mantissa := div(mantissa, 100)\n                    exponent := add(exponent, 2)\n                }\n                if iszero(mod(mantissa, 10)) {\n                    mantissa := div(mantissa, 10)\n                    exponent := add(exponent, 1)\n                }\n            }\n        }\n    }\n\n    /// @dev Convenience function for packing `x` into a smaller number using `sci`.\n    /// The `mantissa` will be in bits [7..255] (the upper 249 bits).\n    /// The `exponent` will be in bits [0..6] (the lower 7 bits).\n    /// Use `SafeCastLib` to safely ensure that the `packed` number is small\n    /// enough to fit in the desired unsigned integer type:\n    /// ```\n    ///     uint32 packed = SafeCastLib.toUint32(FixedPointMathLib.packSci(777 ether));\n    /// ```\n    function packSci(uint256 x) internal pure returns (uint256 packed) {\n        (x, packed) = sci(x); // Reuse for `mantissa` and `exponent`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            if shr(249, x) {\n                mstore(0x00, 0xce30380c) // `MantissaOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            packed := or(shl(7, x), packed)\n        }\n    }\n\n    /// @dev Convenience function for unpacking a packed number from `packSci`.\n    function unpackSci(uint256 packed) internal pure returns (uint256 unpacked) {\n        unchecked {\n            unpacked = (packed >> 7) * 10 ** (packed & 0x7f);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards zero.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = (x & y) + ((x ^ y) >> 1);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards negative infinity.\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @dev Returns the absolute value of `x`.\n    function abs(int256 x) internal pure returns (uint256 z) {\n        unchecked {\n            z = (uint256(x) + uint256(x >> 255)) ^ uint256(x >> 255);\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, gt(x, y)), sub(y, x)), gt(x, y))\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, sgt(x, y)), sub(y, x)), sgt(x, y))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), lt(y, x)))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), slt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), gt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), gt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), lt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), sgt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), slt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns greatest common divisor of `x` and `y`.\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { z := x } y {} {\n                let t := y\n                y := mod(z, y)\n                z := t\n            }\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`,\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(uint256 a, uint256 b, uint256 t, uint256 begin, uint256 end)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        unchecked {\n            if (b >= a) return a + fullMulDiv(b - a, t - begin, end - begin);\n            return a - fullMulDiv(a - b, t - begin, end - begin);\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`.\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(int256 a, int256 b, int256 t, int256 begin, int256 end)\n        internal\n        pure\n        returns (int256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        // forgefmt: disable-next-item\n        unchecked {\n            if (b >= a) return int256(uint256(a) + fullMulDiv(uint256(b - a),\n                uint256(t - begin), uint256(end - begin)));\n            return int256(uint256(a) - fullMulDiv(uint256(a - b),\n                uint256(t - begin), uint256(end - begin)));\n        }\n    }\n\n    /// @dev Returns if `x` is an even number. Some people may need this.\n    function isEven(uint256 x) internal pure returns (bool) {\n        return x & uint256(1) == uint256(0);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   RAW NUMBER OPERATIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(x, y)\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mod(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := smod(x, y)\n        }\n    }\n\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := addmod(x, y, d)\n        }\n    }\n\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mulmod(x, y, d)\n        }\n    }\n}\n"
    },
    "/Users/williamcory/cavalre-contracts/libraries/FloatLib.sol": {
      "id": "/Users/williamcory/cavalre-contracts/libraries/FloatLib.sol",
      "rawCode": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {FixedPointMathLib} from \"solady/src/utils/FixedPointMathLib.sol\";\n\ntype Float is int256;\n\nlibrary FloatLib {\n    using FloatLib for Float;\n    using FixedPointMathLib for uint256;\n    using FixedPointMathLib for int256;\n\n    // Errors\n    error NoSolution();\n\n    //===============\n    //   Constants\n    //===============\n    uint256 constant SIGNIFICANT_DIGITS = 21;\n    uint256 constant NORMALIZED_MANTISSA_MAX = 10 ** SIGNIFICANT_DIGITS - 1;\n    uint256 constant NORMALIZED_MANTISSA_MIN = 10 ** (SIGNIFICANT_DIGITS - 1);\n    uint256 constant MANTISSA_BITS = 72;\n    uint256 constant MANTISSA_MASK = (uint256(1) << MANTISSA_BITS) - 1;\n\n    int256 constant ONE_MANTISSA = int256(10 ** (SIGNIFICANT_DIGITS - 1));\n    int256 constant ONE_EXPONENT = -int256(SIGNIFICANT_DIGITS - 1);\n\n    Float constant PI = Float.wrap((int256(-1) << MANTISSA_BITS) | 314159265358979323846);\n\n    int256 constant LOG10_WAD = 2302585092994045684;\n    Float constant LOG10 = Float.wrap((int256(-18) << MANTISSA_BITS) | LOG10_WAD);\n\n    Float constant ZERO = Float.wrap(0);\n    Float constant ONE = Float.wrap((ONE_EXPONENT << MANTISSA_BITS) | ONE_MANTISSA);\n    Float constant TWO = Float.wrap((ONE_EXPONENT << MANTISSA_BITS) | (2 * ONE_MANTISSA));\n    Float constant THREE = Float.wrap((ONE_EXPONENT << MANTISSA_BITS) | (3 * ONE_MANTISSA));\n    Float constant FOUR = Float.wrap((ONE_EXPONENT << MANTISSA_BITS) | (4 * ONE_MANTISSA));\n    Float constant FIVE = Float.wrap((ONE_EXPONENT << MANTISSA_BITS) | (5 * ONE_MANTISSA));\n    Float constant SIX = Float.wrap((ONE_EXPONENT << MANTISSA_BITS) | (6 * ONE_MANTISSA));\n    Float constant SEVEN = Float.wrap((ONE_EXPONENT << MANTISSA_BITS) | (7 * ONE_MANTISSA));\n    Float constant EIGHT = Float.wrap((ONE_EXPONENT << MANTISSA_BITS) | (8 * ONE_MANTISSA));\n    Float constant NINE = Float.wrap((ONE_EXPONENT << MANTISSA_BITS) | (9 * ONE_MANTISSA));\n    Float constant TEN = Float.wrap(((ONE_EXPONENT + 1) << MANTISSA_BITS) | ONE_MANTISSA);\n    Float constant HALF = Float.wrap(((ONE_EXPONENT - 1) << MANTISSA_BITS) | (5 * ONE_MANTISSA));\n    //=================\n    //   Conversions\n    //=================\n\n    //-----------\n    //   toInt\n    //-----------\n    // Needed for exponential function\n    function toInt(Float a_, uint8 decimals_) internal pure returns (int256) {\n        (int256 _m, int256 _e) = components(a_);\n        _e += int256(uint256(decimals_));\n        if (_e >= 0) {\n            return _m * int256(10 ** uint256(_e));\n        } else {\n            return _m / int256(10 ** uint256(-_e));\n        }\n    }\n\n    function toInt(Float a_) internal pure returns (int256) {\n        return toInt(a_, 18);\n    }\n\n    //------------\n    //   toUInt\n    //------------\n    function toUInt(Float a_, uint8 decimals_) internal pure returns (uint256) {\n        (int256 _m, int256 _e) = components(a_);\n        require(_m >= 0, \"Value must be non-negative\");\n        _e += int256(uint256(decimals_));\n        if (_e >= 0) {\n            return uint256(_m) * 10 ** uint256(_e);\n        } else {\n            return uint256(_m) / 10 ** uint256(-_e);\n        }\n    }\n\n    function toUInt(Float a_) internal pure returns (uint256) {\n        return toUInt(a_, 18);\n    }\n\n    //--------------\n    //   toFloat\n    //--------------\n    function toFloat(uint256 a_, uint8 decimals_) internal pure returns (Float) {\n        return normalize(int256(a_), -int256(uint256(decimals_)));\n    }\n\n    function toFloat(uint256 a_) internal pure returns (Float) {\n        return toFloat(a_, 18);\n    }\n\n    //-------------------\n    //   toFloatArray\n    //-------------------\n\n    // function toFloatArray(int256[] memory a_, uint8[] memory decimals_) internal pure returns (Float[] memory) {\n    //     Float[] memory _result = new Float[](a_.length);\n    //     for (uint256 _i = 0; _i < a_.length; _i++) {\n    //         _result[_i] = toFloat(a_[_i], decimals_[_i]);\n    //     }\n    //     return _result;\n    // }\n\n    // function toFloatArray(int256[] memory a_) internal pure returns (Float[] memory) {\n    //     Float[] memory _result = new Float[](a_.length);\n    //     for (uint256 _i = 0; _i < a_.length; _i++) {\n    //         _result[_i] = toFloat(a_[_i]);\n    //     }\n    //     return _result;\n    // }\n\n    //=================\n    //   Comparisons\n    //=================\n    //----------\n    //   isEQ\n    //----------\n    function isEQ(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) == mantissa(_alignedB);\n    }\n\n    function isGT(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) > mantissa(_alignedB);\n    }\n\n    function isGEQ(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) >= mantissa(_alignedB);\n    }\n\n    function isLT(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) < mantissa(_alignedB);\n    }\n\n    function isLEQ(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) <= mantissa(_alignedB);\n    }\n\n    function isZero(Float a_) internal pure returns (bool) {\n        return mantissa(a_) == 0;\n    }\n\n    //=====================\n    //   Transformations\n    //=====================\n    function abs(Float a_) internal pure returns (Float) {\n        (int256 _m, int256 _e) = components(a_);\n        if (_m >= 0) return a_;\n        return from(-_m, _e);\n    }\n\n    //-----------\n    //   Shift\n    //-----------\n    function shift(Float a_, int256 i_) internal pure returns (Float) {\n        int256 _mantissa = mantissa(a_);\n        if (i_ == 0 || _mantissa == 0) return a_;\n\n        int256 _shift = i_;\n        int256 _m = _mantissa;\n        int256 _e = exponent(a_) + i_;\n\n        if (_shift > 0) {\n            while (_shift >= 16) {\n                _m /= 1e16;\n                _shift -= 16;\n            }\n            if (_shift >= 8) {\n                _m /= 1e8;\n                _shift -= 8;\n            }\n            if (_shift >= 4) {\n                _m /= 1e4;\n                _shift -= 4;\n            }\n            if (_shift >= 2) {\n                _m /= 1e2;\n                _shift -= 2;\n            }\n            if (_shift >= 1) {\n                _m /= 10;\n                _shift -= 1;\n            }\n        } else {\n            _shift = -_shift;\n            require(_shift <= int256(SIGNIFICANT_DIGITS), \"shift: |i| too large\");\n            while (_shift >= 16) {\n                _m *= 1e16;\n                _shift -= 16;\n            }\n            if (_shift >= 8) {\n                _m *= 1e8;\n                _shift -= 8;\n            }\n            if (_shift >= 4) {\n                _m *= 1e4;\n                _shift -= 4;\n            }\n            if (_shift >= 2) {\n                _m *= 1e2;\n                _shift -= 2;\n            }\n            if (_shift >= 1) {\n                _m *= 10;\n                _shift -= 1;\n            }\n        }\n\n        return from(_m, _e);\n    }\n\n    //---------------\n    //   normalize\n    //---------------\n\n    // function normalize(int256 mantissa_, int256 exponent_) internal pure returns (Float) {\n    //     if (mantissa_ == 0) return ZERO;\n\n    //     int256 _mag = mantissa_ >= 0 ? mantissa_ : -mantissa_;\n\n    //     if (_mag > NORMALIZED_MANTISSA_MAX) {\n    //         while (_mag > NORMALIZED_MANTISSA_MAX) {\n    //             mantissa_ /= 10;\n    //             exponent_ += 1;\n    //             _mag /= 10;\n    //         }\n    //         return from(mantissa_, exponent_);\n    //     }\n\n    //     if (_mag < NORMALIZED_MANTISSA_MIN) {\n    //         while (_mag < NORMALIZED_MANTISSA_MIN) {\n    //             mantissa_ *= 10;\n    //             exponent_ -= 1;\n    //             _mag *= 10;\n    //         }\n    //         return from(mantissa_, exponent_);\n    //     }\n\n    //     return from(mantissa_, exponent_);\n    // }\n\n    function normalize(int256 mantissa_, int256 exponent_) internal pure returns (Float) {\n        if (mantissa_ == 0) return ZERO;\n\n        uint256 _mag = mantissa_ >= 0 ? uint256(mantissa_) : uint256(-mantissa_);\n\n        while (_mag > NORMALIZED_MANTISSA_MAX) {\n            mantissa_ /= 10;\n            exponent_ += 1;\n            _mag /= 10;\n        }\n\n        while (_mag < NORMALIZED_MANTISSA_MIN) {\n            mantissa_ *= 10;\n            exponent_ -= 1;\n            _mag *= 10;\n        }\n\n        return from(mantissa_, exponent_);\n    }\n\n    function normalize(Float a_) internal pure returns (Float) {\n        (int256 _mantissa, int256 _exponent) = components(a_);\n        return normalize(_mantissa, _exponent);\n    }\n\n    //-----------\n    //   align\n    //-----------\n    function align(Float a_, Float b_) internal pure returns (Float, Float) {\n        (int256 _aMantissa, int256 _aExponent) = components(a_);\n        (int256 _bMantissa, int256 _bExponent) = components(b_);\n        if (_aMantissa == 0 && _bMantissa == 0) {\n            return (ZERO, ZERO);\n        } else if (_aMantissa == 0) {\n            return (from(0, _bExponent), from(_bMantissa, _bExponent));\n        } else if (_bMantissa == 0) {\n            return (from(_aMantissa, _aExponent), from(0, _aExponent));\n        }\n\n        Float _normA = normalize(a_);\n        Float _normB = normalize(b_);\n        _aMantissa = mantissa(_normA);\n        _aExponent = exponent(_normA);\n        _bMantissa = mantissa(_normB);\n        _bExponent = exponent(_normB);\n\n        int256 _delta = _aExponent - _bExponent;\n        if (_delta >= 0) {\n            if (_delta > int256(SIGNIFICANT_DIGITS)) {\n                return (_normA, from(0, _aExponent));\n            }\n            return (_normA, shift(_normB, _delta));\n        } else {\n            if (-_delta > int256(SIGNIFICANT_DIGITS)) {\n                return (from(0, _bExponent), _normB);\n            }\n            return (shift(_normA, -_delta), _normB);\n        }\n    }\n\n    //================\n    //   Arithmetic\n    //================\n    function plus(Float a_, Float b_) internal pure returns (Float) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return normalize(mantissa(_alignedA) + mantissa(_alignedB), exponent(_alignedA));\n    }\n\n    function minus(Float a_) internal pure returns (Float) {\n        return from(-mantissa(a_), exponent(a_));\n    }\n\n    function minus(Float a_, Float b_) internal pure returns (Float) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return normalize(mantissa(_alignedA) - mantissa(_alignedB), exponent(_alignedA));\n    }\n\n    function times(Float a_, Float b_) internal pure returns (Float) {\n        Float _normA = normalize(a_);\n        Float _normB = normalize(b_);\n        int256 _ma = mantissa(_normA);\n        int256 _mb = mantissa(_normB);\n        return normalize(\n            (_ma * _mb) / int256(10 ** SIGNIFICANT_DIGITS),\n            int256(SIGNIFICANT_DIGITS) + exponent(_normA) + exponent(_normB)\n        );\n    }\n\n    function divide(Float a_, Float b_) internal pure returns (Float) {\n        Float _normA = normalize(a_);\n        Float _normB = normalize(b_);\n        int256 _ma = mantissa(_normA);\n        int256 _mb = mantissa(_normB);\n        return normalize(\n            (_ma * int256(10 ** SIGNIFICANT_DIGITS)) / _mb,\n            exponent(_normA) - exponent(_normB) - int256(SIGNIFICANT_DIGITS)\n        );\n    }\n\n    //=======================\n    //   Special functions\n    //=======================\n    function round(Float a_, uint256 digits_) internal pure returns (Float) {\n        if (mantissa(a_) == 0) return ZERO;\n        if (digits_ >= SIGNIFICANT_DIGITS) return normalize(a_);\n        Float _norm = normalize(a_);\n        int256 _factor = int256(10 ** (SIGNIFICANT_DIGITS - digits_));\n        int256 _mant = int256(mantissa(_norm));\n        int256 _scaled = _mant / _factor;\n        int256 _remainder = _mant % _factor;\n        if (_remainder * 2 >= _factor) {\n            _scaled++;\n        }\n        if (_remainder * 2 <= -_factor) {\n            _scaled--;\n        }\n        int256 _resultMant = _scaled * _factor;\n        return from(_resultMant, exponent(_norm));\n    }\n\n    function parts(Float number_) internal pure returns (Float _integerPart, Float _fractionalPart) {\n        Float _norm = normalize(number_);\n        (int256 _m, int256 _e) = components(_norm);\n\n        if (_m == 0) return (ZERO, ZERO);\n        if (_e >= 0) return (_norm, ZERO);\n        if (int256(SIGNIFICANT_DIGITS) + _e < 0) return (ZERO, _norm); // too small, integer part is 0\n\n        int256 _div = int256(10 ** uint256(-_e)); // shift ≤ SIGNIFICANT_DIGITS\n        _integerPart = normalize(_m / _div, 0); // truncates toward zero\n        _fractionalPart = _norm.minus(_integerPart);\n    }\n\n    function exp(Float x_) internal pure returns (Float) {\n        Float _y = x_.divide(LOG10);\n        (Float _yInt, Float _yFrac) = _y.parts();\n        int256 _wad = _yFrac.times(LOG10).toInt(); // 18-decimal wad\n        int256 _m = _wad.expWad(); // still 18-decimal wad\n        int256 _e = _yInt.toInt(0) - 18; // adjust for wad scale\n        return normalize(_m, _e);\n    }\n\n    function log(Float x_) internal pure returns (Float) {\n        Float _x = normalize(x_);\n        (int256 _m, int256 _e) = components(_x);\n        require(_m > 0, \"log non-positive\");\n\n        int256 _lnWad = (_m * 1e18).lnWad() + _e * LOG10_WAD;\n\n        return normalize(_lnWad, -18);\n    }\n\n    //-------------\n    //   Pow\n    //-------------\n    // Exponentiation by squaring for integer exponents; faster and avoids the rounding stack-up of exp(log(x) * n).\n    function powUint(Float base_, uint256 e_) internal pure returns (Float result_) {\n        if (e_ == 0) return ONE;\n        Float _base = normalize(base_);\n        if (e_ == 1) return _base;\n        if (mantissa(_base) == 0) return ZERO;\n        if (_base.isEQ(ONE)) return ONE;\n\n        result_ = ONE;\n        uint256 _exp = e_;\n        while (_exp != 0) {\n            if (_exp & 1 == 1) {\n                result_ = result_.times(_base);\n            }\n            _exp >>= 1;\n            if (_exp != 0) {\n                _base = _base.times(_base);\n            }\n        }\n    }\n\n    function powInt(Float base_, int256 e_) internal pure returns (Float) {\n        Float _base = normalize(base_);\n        if (e_ >= 0) return powUint(_base, uint256(e_));\n        require(mantissa(_base) != 0, \"pow: zero base\");\n        require(e_ != type(int256).min, \"pow: exponent too small\");\n        Float _pos = powUint(_base, uint256(-e_));\n        return ONE.divide(_pos);\n    }\n\n    // Real-exponent power via exp(log(base) * exponent); base must be positive to keep log defined.\n    function pow(Float base_, Float e_) internal pure returns (Float) {\n        Float _base = normalize(base_);\n        if (mantissa(e_) == 0) return ONE;\n        if (_base.isEQ(ONE)) return ONE;\n        require(mantissa(_base) > 0, \"pow: base must be positive\");\n        return exp(log(_base).times(e_));\n    }\n\n    function sqrt(Float x_) internal pure returns (Float) {\n        return exp(log(x_).divide(TWO));\n    }\n\n    function fullMulDiv(Float a_, Float b_, Float c_) internal pure returns (Float) {\n        bool _isNegative = false;\n        if (mantissa(a_) < 0) {\n            a_ = minus(a_);\n            _isNegative = !_isNegative;\n        }\n        if (mantissa(b_) < 0) {\n            b_ = minus(b_);\n            _isNegative = !_isNegative;\n        }\n        if (mantissa(c_) < 0) {\n            c_ = minus(c_);\n            _isNegative = !_isNegative;\n        }\n        Float _normA = normalize(a_);\n        Float _normB = normalize(b_);\n        Float _normC = normalize(c_);\n        uint256 _ma = uint256(mantissa(_normA));\n        uint256 _mb = uint256(mantissa(_normB));\n        uint256 _mc = uint256(mantissa(_normC));\n        int256 _m = _isNegative ? -int256(_ma.fullMulDiv(_mb, _mc)) : int256(_ma.fullMulDiv(_mb, _mc));\n        int256 _e = exponent(_normA) + exponent(_normB) - exponent(_normC);\n        return normalize(_m, _e);\n    }\n\n    //====================\n    //   Helper methods\n    //====================\n    function from(int256 mantissa_, int256 exponent_) internal pure returns (Float) {\n        int256 _packed = (exponent_ << MANTISSA_BITS) | (mantissa_ & int256(MANTISSA_MASK));\n        return Float.wrap(_packed);\n    }\n\n    function components(Float a_) internal pure returns (int256 _mantissa, int256 _exponent) {\n        int256 _raw = Float.unwrap(a_);\n        _mantissa = int256(int72(_raw));\n        _exponent = _raw >> MANTISSA_BITS;\n    }\n\n    function mantissa(Float a_) internal pure returns (int256) {\n        return int256(int72(Float.unwrap(a_)));\n    }\n\n    function exponent(Float a_) internal pure returns (int256) {\n        return int256(Float.unwrap(a_) >> MANTISSA_BITS);\n    }\n}\n",
      "importedIds": [
        "/Users/williamcory/cavalre-contracts/node_modules/solady/src/utils/FixedPointMathLib.sol"
      ],
      "code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.26;\n\nimport {FixedPointMathLib} from \"/Users/williamcory/cavalre-contracts/node_modules/solady/src/utils/FixedPointMathLib.sol\";\n\ntype Float is int256;\n\nlibrary FloatLib {\n    using FloatLib for Float;\n    using FixedPointMathLib for uint256;\n    using FixedPointMathLib for int256;\n\n    // Errors\n    error NoSolution();\n\n    //===============\n    //   Constants\n    //===============\n    uint256 constant SIGNIFICANT_DIGITS = 21;\n    uint256 constant NORMALIZED_MANTISSA_MAX = 10 ** SIGNIFICANT_DIGITS - 1;\n    uint256 constant NORMALIZED_MANTISSA_MIN = 10 ** (SIGNIFICANT_DIGITS - 1);\n    uint256 constant MANTISSA_BITS = 72;\n    uint256 constant MANTISSA_MASK = (uint256(1) << MANTISSA_BITS) - 1;\n\n    int256 constant ONE_MANTISSA = int256(10 ** (SIGNIFICANT_DIGITS - 1));\n    int256 constant ONE_EXPONENT = -int256(SIGNIFICANT_DIGITS - 1);\n\n    Float constant PI = Float.wrap((int256(-1) << MANTISSA_BITS) | 314159265358979323846);\n\n    int256 constant LOG10_WAD = 2302585092994045684;\n    Float constant LOG10 = Float.wrap((int256(-18) << MANTISSA_BITS) | LOG10_WAD);\n\n    Float constant ZERO = Float.wrap(0);\n    Float constant ONE = Float.wrap((ONE_EXPONENT << MANTISSA_BITS) | ONE_MANTISSA);\n    Float constant TWO = Float.wrap((ONE_EXPONENT << MANTISSA_BITS) | (2 * ONE_MANTISSA));\n    Float constant THREE = Float.wrap((ONE_EXPONENT << MANTISSA_BITS) | (3 * ONE_MANTISSA));\n    Float constant FOUR = Float.wrap((ONE_EXPONENT << MANTISSA_BITS) | (4 * ONE_MANTISSA));\n    Float constant FIVE = Float.wrap((ONE_EXPONENT << MANTISSA_BITS) | (5 * ONE_MANTISSA));\n    Float constant SIX = Float.wrap((ONE_EXPONENT << MANTISSA_BITS) | (6 * ONE_MANTISSA));\n    Float constant SEVEN = Float.wrap((ONE_EXPONENT << MANTISSA_BITS) | (7 * ONE_MANTISSA));\n    Float constant EIGHT = Float.wrap((ONE_EXPONENT << MANTISSA_BITS) | (8 * ONE_MANTISSA));\n    Float constant NINE = Float.wrap((ONE_EXPONENT << MANTISSA_BITS) | (9 * ONE_MANTISSA));\n    Float constant TEN = Float.wrap(((ONE_EXPONENT + 1) << MANTISSA_BITS) | ONE_MANTISSA);\n    Float constant HALF = Float.wrap(((ONE_EXPONENT - 1) << MANTISSA_BITS) | (5 * ONE_MANTISSA));\n    //=================\n    //   Conversions\n    //=================\n\n    //-----------\n    //   toInt\n    //-----------\n    // Needed for exponential function\n    function toInt(Float a_, uint8 decimals_) internal pure returns (int256) {\n        (int256 _m, int256 _e) = components(a_);\n        _e += int256(uint256(decimals_));\n        if (_e >= 0) {\n            return _m * int256(10 ** uint256(_e));\n        } else {\n            return _m / int256(10 ** uint256(-_e));\n        }\n    }\n\n    function toInt(Float a_) internal pure returns (int256) {\n        return toInt(a_, 18);\n    }\n\n    //------------\n    //   toUInt\n    //------------\n    function toUInt(Float a_, uint8 decimals_) internal pure returns (uint256) {\n        (int256 _m, int256 _e) = components(a_);\n        require(_m >= 0, \"Value must be non-negative\");\n        _e += int256(uint256(decimals_));\n        if (_e >= 0) {\n            return uint256(_m) * 10 ** uint256(_e);\n        } else {\n            return uint256(_m) / 10 ** uint256(-_e);\n        }\n    }\n\n    function toUInt(Float a_) internal pure returns (uint256) {\n        return toUInt(a_, 18);\n    }\n\n    //--------------\n    //   toFloat\n    //--------------\n    function toFloat(uint256 a_, uint8 decimals_) internal pure returns (Float) {\n        return normalize(int256(a_), -int256(uint256(decimals_)));\n    }\n\n    function toFloat(uint256 a_) internal pure returns (Float) {\n        return toFloat(a_, 18);\n    }\n\n    //-------------------\n    //   toFloatArray\n    //-------------------\n\n    // function toFloatArray(int256[] memory a_, uint8[] memory decimals_) internal pure returns (Float[] memory) {\n    //     Float[] memory _result = new Float[](a_.length);\n    //     for (uint256 _i = 0; _i < a_.length; _i++) {\n    //         _result[_i] = toFloat(a_[_i], decimals_[_i]);\n    //     }\n    //     return _result;\n    // }\n\n    // function toFloatArray(int256[] memory a_) internal pure returns (Float[] memory) {\n    //     Float[] memory _result = new Float[](a_.length);\n    //     for (uint256 _i = 0; _i < a_.length; _i++) {\n    //         _result[_i] = toFloat(a_[_i]);\n    //     }\n    //     return _result;\n    // }\n\n    //=================\n    //   Comparisons\n    //=================\n    //----------\n    //   isEQ\n    //----------\n    function isEQ(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) == mantissa(_alignedB);\n    }\n\n    function isGT(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) > mantissa(_alignedB);\n    }\n\n    function isGEQ(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) >= mantissa(_alignedB);\n    }\n\n    function isLT(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) < mantissa(_alignedB);\n    }\n\n    function isLEQ(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) <= mantissa(_alignedB);\n    }\n\n    function isZero(Float a_) internal pure returns (bool) {\n        return mantissa(a_) == 0;\n    }\n\n    //=====================\n    //   Transformations\n    //=====================\n    function abs(Float a_) internal pure returns (Float) {\n        (int256 _m, int256 _e) = components(a_);\n        if (_m >= 0) return a_;\n        return from(-_m, _e);\n    }\n\n    //-----------\n    //   Shift\n    //-----------\n    function shift(Float a_, int256 i_) internal pure returns (Float) {\n        int256 _mantissa = mantissa(a_);\n        if (i_ == 0 || _mantissa == 0) return a_;\n\n        int256 _shift = i_;\n        int256 _m = _mantissa;\n        int256 _e = exponent(a_) + i_;\n\n        if (_shift > 0) {\n            while (_shift >= 16) {\n                _m /= 1e16;\n                _shift -= 16;\n            }\n            if (_shift >= 8) {\n                _m /= 1e8;\n                _shift -= 8;\n            }\n            if (_shift >= 4) {\n                _m /= 1e4;\n                _shift -= 4;\n            }\n            if (_shift >= 2) {\n                _m /= 1e2;\n                _shift -= 2;\n            }\n            if (_shift >= 1) {\n                _m /= 10;\n                _shift -= 1;\n            }\n        } else {\n            _shift = -_shift;\n            require(_shift <= int256(SIGNIFICANT_DIGITS), \"shift: |i| too large\");\n            while (_shift >= 16) {\n                _m *= 1e16;\n                _shift -= 16;\n            }\n            if (_shift >= 8) {\n                _m *= 1e8;\n                _shift -= 8;\n            }\n            if (_shift >= 4) {\n                _m *= 1e4;\n                _shift -= 4;\n            }\n            if (_shift >= 2) {\n                _m *= 1e2;\n                _shift -= 2;\n            }\n            if (_shift >= 1) {\n                _m *= 10;\n                _shift -= 1;\n            }\n        }\n\n        return from(_m, _e);\n    }\n\n    //---------------\n    //   normalize\n    //---------------\n\n    // function normalize(int256 mantissa_, int256 exponent_) internal pure returns (Float) {\n    //     if (mantissa_ == 0) return ZERO;\n\n    //     int256 _mag = mantissa_ >= 0 ? mantissa_ : -mantissa_;\n\n    //     if (_mag > NORMALIZED_MANTISSA_MAX) {\n    //         while (_mag > NORMALIZED_MANTISSA_MAX) {\n    //             mantissa_ /= 10;\n    //             exponent_ += 1;\n    //             _mag /= 10;\n    //         }\n    //         return from(mantissa_, exponent_);\n    //     }\n\n    //     if (_mag < NORMALIZED_MANTISSA_MIN) {\n    //         while (_mag < NORMALIZED_MANTISSA_MIN) {\n    //             mantissa_ *= 10;\n    //             exponent_ -= 1;\n    //             _mag *= 10;\n    //         }\n    //         return from(mantissa_, exponent_);\n    //     }\n\n    //     return from(mantissa_, exponent_);\n    // }\n\n    function normalize(int256 mantissa_, int256 exponent_) internal pure returns (Float) {\n        if (mantissa_ == 0) return ZERO;\n\n        uint256 _mag = mantissa_ >= 0 ? uint256(mantissa_) : uint256(-mantissa_);\n\n        while (_mag > NORMALIZED_MANTISSA_MAX) {\n            mantissa_ /= 10;\n            exponent_ += 1;\n            _mag /= 10;\n        }\n\n        while (_mag < NORMALIZED_MANTISSA_MIN) {\n            mantissa_ *= 10;\n            exponent_ -= 1;\n            _mag *= 10;\n        }\n\n        return from(mantissa_, exponent_);\n    }\n\n    function normalize(Float a_) internal pure returns (Float) {\n        (int256 _mantissa, int256 _exponent) = components(a_);\n        return normalize(_mantissa, _exponent);\n    }\n\n    //-----------\n    //   align\n    //-----------\n    function align(Float a_, Float b_) internal pure returns (Float, Float) {\n        (int256 _aMantissa, int256 _aExponent) = components(a_);\n        (int256 _bMantissa, int256 _bExponent) = components(b_);\n        if (_aMantissa == 0 && _bMantissa == 0) {\n            return (ZERO, ZERO);\n        } else if (_aMantissa == 0) {\n            return (from(0, _bExponent), from(_bMantissa, _bExponent));\n        } else if (_bMantissa == 0) {\n            return (from(_aMantissa, _aExponent), from(0, _aExponent));\n        }\n\n        Float _normA = normalize(a_);\n        Float _normB = normalize(b_);\n        _aMantissa = mantissa(_normA);\n        _aExponent = exponent(_normA);\n        _bMantissa = mantissa(_normB);\n        _bExponent = exponent(_normB);\n\n        int256 _delta = _aExponent - _bExponent;\n        if (_delta >= 0) {\n            if (_delta > int256(SIGNIFICANT_DIGITS)) {\n                return (_normA, from(0, _aExponent));\n            }\n            return (_normA, shift(_normB, _delta));\n        } else {\n            if (-_delta > int256(SIGNIFICANT_DIGITS)) {\n                return (from(0, _bExponent), _normB);\n            }\n            return (shift(_normA, -_delta), _normB);\n        }\n    }\n\n    //================\n    //   Arithmetic\n    //================\n    function plus(Float a_, Float b_) internal pure returns (Float) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return normalize(mantissa(_alignedA) + mantissa(_alignedB), exponent(_alignedA));\n    }\n\n    function minus(Float a_) internal pure returns (Float) {\n        return from(-mantissa(a_), exponent(a_));\n    }\n\n    function minus(Float a_, Float b_) internal pure returns (Float) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return normalize(mantissa(_alignedA) - mantissa(_alignedB), exponent(_alignedA));\n    }\n\n    function times(Float a_, Float b_) internal pure returns (Float) {\n        Float _normA = normalize(a_);\n        Float _normB = normalize(b_);\n        int256 _ma = mantissa(_normA);\n        int256 _mb = mantissa(_normB);\n        return normalize(\n            (_ma * _mb) / int256(10 ** SIGNIFICANT_DIGITS),\n            int256(SIGNIFICANT_DIGITS) + exponent(_normA) + exponent(_normB)\n        );\n    }\n\n    function divide(Float a_, Float b_) internal pure returns (Float) {\n        Float _normA = normalize(a_);\n        Float _normB = normalize(b_);\n        int256 _ma = mantissa(_normA);\n        int256 _mb = mantissa(_normB);\n        return normalize(\n            (_ma * int256(10 ** SIGNIFICANT_DIGITS)) / _mb,\n            exponent(_normA) - exponent(_normB) - int256(SIGNIFICANT_DIGITS)\n        );\n    }\n\n    //=======================\n    //   Special functions\n    //=======================\n    function round(Float a_, uint256 digits_) internal pure returns (Float) {\n        if (mantissa(a_) == 0) return ZERO;\n        if (digits_ >= SIGNIFICANT_DIGITS) return normalize(a_);\n        Float _norm = normalize(a_);\n        int256 _factor = int256(10 ** (SIGNIFICANT_DIGITS - digits_));\n        int256 _mant = int256(mantissa(_norm));\n        int256 _scaled = _mant / _factor;\n        int256 _remainder = _mant % _factor;\n        if (_remainder * 2 >= _factor) {\n            _scaled++;\n        }\n        if (_remainder * 2 <= -_factor) {\n            _scaled--;\n        }\n        int256 _resultMant = _scaled * _factor;\n        return from(_resultMant, exponent(_norm));\n    }\n\n    function parts(Float number_) internal pure returns (Float _integerPart, Float _fractionalPart) {\n        Float _norm = normalize(number_);\n        (int256 _m, int256 _e) = components(_norm);\n\n        if (_m == 0) return (ZERO, ZERO);\n        if (_e >= 0) return (_norm, ZERO);\n        if (int256(SIGNIFICANT_DIGITS) + _e < 0) return (ZERO, _norm); // too small, integer part is 0\n\n        int256 _div = int256(10 ** uint256(-_e)); // shift ≤ SIGNIFICANT_DIGITS\n        _integerPart = normalize(_m / _div, 0); // truncates toward zero\n        _fractionalPart = _norm.minus(_integerPart);\n    }\n\n    function exp(Float x_) internal pure returns (Float) {\n        Float _y = x_.divide(LOG10);\n        (Float _yInt, Float _yFrac) = _y.parts();\n        int256 _wad = _yFrac.times(LOG10).toInt(); // 18-decimal wad\n        int256 _m = _wad.expWad(); // still 18-decimal wad\n        int256 _e = _yInt.toInt(0) - 18; // adjust for wad scale\n        return normalize(_m, _e);\n    }\n\n    function log(Float x_) internal pure returns (Float) {\n        Float _x = normalize(x_);\n        (int256 _m, int256 _e) = components(_x);\n        require(_m > 0, \"log non-positive\");\n\n        int256 _lnWad = (_m * 1e18).lnWad() + _e * LOG10_WAD;\n\n        return normalize(_lnWad, -18);\n    }\n\n    //-------------\n    //   Pow\n    //-------------\n    // Exponentiation by squaring for integer exponents; faster and avoids the rounding stack-up of exp(log(x) * n).\n    function powUint(Float base_, uint256 e_) internal pure returns (Float result_) {\n        if (e_ == 0) return ONE;\n        Float _base = normalize(base_);\n        if (e_ == 1) return _base;\n        if (mantissa(_base) == 0) return ZERO;\n        if (_base.isEQ(ONE)) return ONE;\n\n        result_ = ONE;\n        uint256 _exp = e_;\n        while (_exp != 0) {\n            if (_exp & 1 == 1) {\n                result_ = result_.times(_base);\n            }\n            _exp >>= 1;\n            if (_exp != 0) {\n                _base = _base.times(_base);\n            }\n        }\n    }\n\n    function powInt(Float base_, int256 e_) internal pure returns (Float) {\n        Float _base = normalize(base_);\n        if (e_ >= 0) return powUint(_base, uint256(e_));\n        require(mantissa(_base) != 0, \"pow: zero base\");\n        require(e_ != type(int256).min, \"pow: exponent too small\");\n        Float _pos = powUint(_base, uint256(-e_));\n        return ONE.divide(_pos);\n    }\n\n    // Real-exponent power via exp(log(base) * exponent); base must be positive to keep log defined.\n    function pow(Float base_, Float e_) internal pure returns (Float) {\n        Float _base = normalize(base_);\n        if (mantissa(e_) == 0) return ONE;\n        if (_base.isEQ(ONE)) return ONE;\n        require(mantissa(_base) > 0, \"pow: base must be positive\");\n        return exp(log(_base).times(e_));\n    }\n\n    function sqrt(Float x_) internal pure returns (Float) {\n        return exp(log(x_).divide(TWO));\n    }\n\n    function fullMulDiv(Float a_, Float b_, Float c_) internal pure returns (Float) {\n        bool _isNegative = false;\n        if (mantissa(a_) < 0) {\n            a_ = minus(a_);\n            _isNegative = !_isNegative;\n        }\n        if (mantissa(b_) < 0) {\n            b_ = minus(b_);\n            _isNegative = !_isNegative;\n        }\n        if (mantissa(c_) < 0) {\n            c_ = minus(c_);\n            _isNegative = !_isNegative;\n        }\n        Float _normA = normalize(a_);\n        Float _normB = normalize(b_);\n        Float _normC = normalize(c_);\n        uint256 _ma = uint256(mantissa(_normA));\n        uint256 _mb = uint256(mantissa(_normB));\n        uint256 _mc = uint256(mantissa(_normC));\n        int256 _m = _isNegative ? -int256(_ma.fullMulDiv(_mb, _mc)) : int256(_ma.fullMulDiv(_mb, _mc));\n        int256 _e = exponent(_normA) + exponent(_normB) - exponent(_normC);\n        return normalize(_m, _e);\n    }\n\n    //====================\n    //   Helper methods\n    //====================\n    function from(int256 mantissa_, int256 exponent_) internal pure returns (Float) {\n        int256 _packed = (exponent_ << MANTISSA_BITS) | (mantissa_ & int256(MANTISSA_MASK));\n        return Float.wrap(_packed);\n    }\n\n    function components(Float a_) internal pure returns (int256 _mantissa, int256 _exponent) {\n        int256 _raw = Float.unwrap(a_);\n        _mantissa = int256(int72(_raw));\n        _exponent = _raw >> MANTISSA_BITS;\n    }\n\n    function mantissa(Float a_) internal pure returns (int256) {\n        return int256(int72(Float.unwrap(a_)));\n    }\n\n    function exponent(Float a_) internal pure returns (int256) {\n        return int256(Float.unwrap(a_) >> MANTISSA_BITS);\n    }\n}\n"
    }
  }
}