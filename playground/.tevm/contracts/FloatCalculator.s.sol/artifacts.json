{
  "solcInput": {
    "language": "Solidity",
    "sources": {
      "/Users/williamcory/cavalre-contracts/playground/contracts/FloatCalculator.s.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.26;\n\nimport {Float, FloatLib} from \"/Users/williamcory/cavalre-contracts/libraries/FloatLib.sol\";\nimport {FloatStrings} from \"/Users/williamcory/cavalre-contracts/libraries/FloatStrings.sol\";\n\ncontract FloatCalculator {\n    using FloatLib for Float;\n    using FloatLib for int256;\n    using FloatLib for uint256;\n    using FloatStrings for Float;\n\n    // ==================\n    //     Arithmetic\n    // ==================\n\n    function add(int256 a, int256 b, uint256 decimals) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        return fa.plus(fb).toString();\n    }\n\n    function subtract(int256 a, int256 b, uint256 decimals) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        return fa.minus(fb).toString();\n    }\n\n    function multiply(int256 a, int256 b, uint256 decimals) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        return fa.times(fb).toString();\n    }\n\n    function divide(int256 a, int256 b, uint256 decimals) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        return fa.divide(fb).toString();\n    }\n\n    function negate(int256 a, uint256 decimals) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        return fa.minus().toString();\n    }\n\n    // ==================\n    //    Comparisons\n    // ==================\n\n    function isEqual(int256 a, int256 b, uint256 decimals) external pure returns (bool) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        return fa.isEQ(fb);\n    }\n\n    function isGreaterThan(int256 a, int256 b, uint256 decimals) external pure returns (bool) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        return fa.isGT(fb);\n    }\n\n    function isLessThan(int256 a, int256 b, uint256 decimals) external pure returns (bool) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        return fa.isLT(fb);\n    }\n\n    function isGreaterOrEqual(int256 a, int256 b, uint256 decimals) external pure returns (bool) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        return fa.isGEQ(fb);\n    }\n\n    function isLessOrEqual(int256 a, int256 b, uint256 decimals) external pure returns (bool) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        return fa.isLEQ(fb);\n    }\n\n    // ==================\n    //  Transformations\n    // ==================\n\n    function absoluteValue(int256 a, uint256 decimals) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        return fa.abs().toString();\n    }\n\n    function getIntegerPart(int256 a, uint256 decimals) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        return fa.integerPart().toString();\n    }\n\n    function shift(int256 a, uint256 decimals, int256 places) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        return fa.shift(places).toString();\n    }\n\n    function roundTo(int256 a, uint256 decimals, uint256 digits) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        return fa.round(digits).toString();\n    }\n\n    // ==================\n    //  Special Functions\n    // ==================\n\n    function exponential(int256 a) external pure returns (string memory) {\n        // exp takes raw int256 (18 decimal fixed point)\n        return FloatLib.exp(a).toString();\n    }\n\n    function naturalLog(int256 a, uint256 decimals) external pure returns (int256) {\n        Float fa = a.toFloat(decimals);\n        return fa.log();\n    }\n\n    function cubicSolve(int256 b, int256 c, int256 d, uint256 decimals) external pure returns (string memory) {\n        Float fb = b.toFloat(decimals);\n        Float fc = c.toFloat(decimals);\n        Float fd = d.toFloat(decimals);\n        return FloatLib.cubicsolve(fb, fc, fd).toString();\n    }\n\n    function fullMulDiv(int256 a, int256 b, int256 c, uint256 decimals) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        Float fc = c.toFloat(decimals);\n        return FloatLib.fullMulDiv(fa, fb, fc).toString();\n    }\n\n    // ==================\n    //     Utilities\n    // ==================\n\n    function toFloatString(int256 value, uint256 decimals) external pure returns (string memory) {\n        return value.toFloat(decimals).toString();\n    }\n\n    function getComponents(int256 value, uint256 decimals) external pure returns (int256 mantissa, int256 exponent) {\n        Float f = value.toFloat(decimals);\n        return FloatLib.components(f);\n    }\n\n    function fromComponents(int256 mantissa, int256 exponent) external pure returns (string memory) {\n        return FloatLib.from(mantissa, exponent).toString();\n    }\n\n    function normalize(int256 mantissa, int256 exponent) external pure returns (string memory) {\n        return FloatLib.normalize(mantissa, exponent).toString();\n    }\n\n    // ==================\n    //     Constants\n    // ==================\n\n    function zero() external pure returns (string memory) {\n        return FloatLib.ZERO.toString();\n    }\n\n    function one() external pure returns (string memory) {\n        return FloatLib.ONE.toString();\n    }\n\n    function two() external pure returns (string memory) {\n        return FloatLib.TWO.toString();\n    }\n\n    function ten() external pure returns (string memory) {\n        return FloatLib.TEN.toString();\n    }\n}\n"
      },
      "/Users/williamcory/cavalre-contracts/libraries/FloatStrings.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.26;\n\nimport {Float, FloatLib} from \"/Users/williamcory/cavalre-contracts/libraries/FloatLib.sol\";\nimport {FixedPointMathLib} from \"/Users/williamcory/cavalre-contracts/node_modules/solady/src/utils/FixedPointMathLib.sol\";\n\nlibrary FloatStrings {\n    using FixedPointMathLib for int256;\n    using FloatLib for Float;\n\n    // Most significant bit\n    function msb(int256 value_) internal pure returns (uint256) {\n        if (value_ == 0) {\n            return 0;\n        }\n\n        return toStringBytes(value_.abs()).length;\n    }\n\n    function shiftStringBytesLeft(bytes memory strBytes_, uint256 numChars_) public pure returns (bytes memory) {\n        bytes memory _result = new bytes(strBytes_.length + numChars_);\n\n        for (uint256 _i = 0; _i < _result.length; _i++) {\n            if (_i < strBytes_.length) {\n                _result[_i] = strBytes_[_i];\n            } else {\n                _result[_i] = \"0\";\n            }\n        }\n\n        return _result;\n    }\n\n    function shiftStringLeft(string memory str_, uint256 numChars_) public pure returns (string memory) {\n        return string(shiftStringBytesLeft(bytes(str_), numChars_));\n    }\n\n    function shiftStringBytesRight(bytes memory strBytes_, uint256 numChars_)\n        public\n        pure\n        returns (bytes memory _result, bytes memory _remainder)\n    {\n        uint256 _resultChars;\n        uint256 _remainderChars;\n        uint256 _excessChars;\n        if (numChars_ > strBytes_.length) {\n            _resultChars = 0;\n            _excessChars = numChars_ - strBytes_.length;\n            _result = new bytes(1);\n        } else {\n            _resultChars = strBytes_.length - numChars_;\n            _result = new bytes(_resultChars);\n        }\n        _remainderChars = numChars_;\n        _remainder = new bytes(_remainderChars);\n\n        for (uint256 _i = 0; _i < strBytes_.length; _i++) {\n            if (_i < _resultChars) {\n                _result[_i] = strBytes_[_i];\n            } else {\n                _remainder[_remainderChars - 1 + _resultChars - _i] =\n                    strBytes_[strBytes_.length - 1 + _resultChars - _i];\n            }\n        }\n\n        return (_result, _remainder);\n    }\n\n    function shiftStringRight(string memory str_, uint256 numChars_)\n        public\n        pure\n        returns (string memory _result, string memory _remainder)\n    {\n        bytes memory _strBytes = bytes(str_);\n        bytes memory _resultBytes;\n        bytes memory _remainderBytes;\n        (_resultBytes, _remainderBytes) = shiftStringBytesRight(_strBytes, numChars_);\n        _result = string(_resultBytes);\n        _remainder = string(_remainderBytes);\n    }\n\n    function toStringBytes(uint256 value_) public pure returns (bytes memory) {\n        // Handle the special case of zero.\n        if (value_ == 0) {\n            return bytes(\"0\");\n        }\n\n        // Determine the length of the decimal number.\n        uint256 _digits = digits(value_);\n\n        // Create a temporary byte array to fill with the digits of the number.\n        bytes memory _buffer = new bytes(_digits);\n        while (value_ != 0) {\n            _digits -= 1;\n            _buffer[_digits] = bytes1(uint8(48 + (value_ % 10)));\n            value_ /= 10;\n        }\n\n        // Convert the byte array to a string and return it.\n        return _buffer;\n    }\n\n    function toStringBytes(Float value_) internal pure returns (bytes memory, bytes memory) {\n        (int256 _mantissa, ) = FloatLib.components(value_);\n        if (_mantissa == 0) {\n            return (bytes(\"0\"), bytes(\"0\"));\n        }\n\n        Float _integerPartFloat = FloatLib.integerPart(value_);\n        bytes memory _integerPartBytes;\n\n        (int256 _intMantissa, int256 _intExponent) = FloatLib.components(_integerPartFloat);\n        if (_intMantissa == 0) {\n            _integerPartBytes = bytes(\"0\");\n        } else {\n            bytes memory _integerPartMantissaBytes =\n                toStringBytes(uint256(_intMantissa >= 0 ? _intMantissa : -_intMantissa));\n\n            _integerPartBytes = new bytes(_integerPartMantissaBytes.length + uint256(_intExponent));\n\n            for (uint256 _i = 0; _i < _integerPartBytes.length; _i++) {\n                if (_i < _integerPartMantissaBytes.length) {\n                    _integerPartBytes[_i] = _integerPartMantissaBytes[_i];\n                } else {\n                    _integerPartBytes[_i] = bytes1(\"0\");\n                }\n            }\n        }\n\n        Float _fractionalPartFloat;\n        if (_intMantissa == 0) {\n            _fractionalPartFloat = value_;\n        } else {\n            _fractionalPartFloat = FloatLib.minus(value_, _integerPartFloat);\n        }\n\n        bytes memory _fractionalPartBytes;\n        (int256 _fracMantissa, int256 _fracExponent) = FloatLib.components(_fractionalPartFloat);\n        if (_fracMantissa == 0) {\n            _fractionalPartBytes = bytes(\"0\");\n        } else {\n            bytes memory _fractionalPartMantissaBytes =\n                toStringBytes(uint256(_fracMantissa >= 0 ? _fracMantissa : -_fracMantissa));\n\n            _fractionalPartBytes = new bytes(uint256(-_fracExponent));\n\n            for (uint256 _i = 0; _i < _fractionalPartBytes.length; _i++) {\n                if (_i < _fractionalPartMantissaBytes.length) {\n                    _fractionalPartBytes[_fractionalPartBytes.length - 1 - _i] =\n                        _fractionalPartMantissaBytes[_fractionalPartMantissaBytes.length - 1 - _i];\n                } else {\n                    _fractionalPartBytes[_fractionalPartBytes.length - 1 - _i] = bytes1(\"0\");\n                }\n            }\n        }\n\n        return (_integerPartBytes, _fractionalPartBytes);\n    }\n\n    function toString(uint256 value_) public pure returns (string memory) {\n        return string(toStringBytes(value_));\n    }\n\n    function toString(int256 value_) public pure returns (string memory) {\n        return string(abi.encodePacked(value_ < 0 ? \"-\" : \"\", toStringBytes(value_.abs())));\n    }\n\n    function trimStringBytesRight(bytes memory strBytes_) public pure returns (bytes memory) {\n        uint256 _i = strBytes_.length - 1;\n        while (_i > 0 && strBytes_[_i] == \"0\") {\n            _i--;\n        }\n        bytes memory _result = new bytes(_i + 1);\n        for (uint256 _j = 0; _j < _i + 1; _j++) {\n            _result[_j] = strBytes_[_j];\n        }\n        return _result;\n    }\n\n    function trimStringRight(string memory str_) public pure returns (string memory) {\n        return string(trimStringBytesRight(bytes(str_)));\n    }\n\n    function toString(Float number_) internal pure returns (string memory) {\n        bytes memory _integerPartBytes;\n        bytes memory _fractionalPartBytes;\n\n        number_ = FloatLib.normalize(number_);\n\n        Float _max = FloatLib.normalize(int256(FloatLib.NORMALIZED_MANTISSA_MAX), 0);\n\n        uint256 _ushift = FloatLib.SIGNIFICANT_DIGITS - 1;\n        int256 _ishift = int256(_ushift);\n\n        (int256 _mantissa, int256 _exponent) = FloatLib.components(number_);\n        if (FloatLib.abs(number_).isLT(_max) && _exponent >= -_ishift) {\n            (_integerPartBytes, _fractionalPartBytes) = toStringBytes(number_);\n            return string(\n                abi.encodePacked(\n                    _mantissa < 0 ? \"-\" : \"\",\n                    string(_integerPartBytes),\n                    \".\",\n                    string(trimStringBytesRight(_fractionalPartBytes))\n                )\n            );\n        } else {\n            (_integerPartBytes, _fractionalPartBytes) = toStringBytes(FloatLib.normalize(_mantissa, -_ishift));\n            return string(\n                abi.encodePacked(\n                    _mantissa < 0 ? \"-\" : \"\",\n                    string(_integerPartBytes),\n                    \".\",\n                    string(trimStringBytesRight(_fractionalPartBytes)),\n                    \"e\",\n                    toString(_exponent + _ishift)\n                )\n            );\n        }\n    }\n\n    function digits(uint256 number_) public pure returns (uint8) {\n        if (number_ == 0) {\n            return 1; // Zero has 1 significant digit\n        }\n\n        uint8 count = 0;\n        while (number_ != 0) {\n            count++;\n            number_ /= 10; // Remove the least significant digit\n        }\n        return count;\n    }\n}\n"
      },
      "/Users/williamcory/cavalre-contracts/node_modules/solady/src/utils/FixedPointMathLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error ExpOverflow();\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error FactorialOverflow();\n\n    /// @dev The operation failed, due to an overflow.\n    error RPowOverflow();\n\n    /// @dev The mantissa is too big to fit.\n    error MantissaOverflow();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error MulWadFailed();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error SMulWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error DivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error SDivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error MulDivFailed();\n\n    /// @dev The division failed, as the denominator is zero.\n    error DivFailed();\n\n    /// @dev The full precision multiply-divide operation failed, either due\n    /// to the result being larger than 256 bits, or a division by a zero.\n    error FullMulDivFailed();\n\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\n    error LnWadUndefined();\n\n    /// @dev The input outside the acceptable domain.\n    error OutOfDomain();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The scalar of ETH and most ERC20s.\n    uint256 internal constant WAD = 1e18;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if gt(x, div(not(0), y)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function sMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require((x == 0 || z / x == y) && !(x == -1 && y == type(int256).min))`.\n            if iszero(gt(or(iszero(x), eq(sdiv(z, x), y)), lt(not(x), eq(y, shl(255, 1))))) {\n                mstore(0x00, 0xedcd4dd4) // `SMulWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawMulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawSMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if iszero(eq(div(z, y), x)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := add(iszero(iszero(mod(z, WAD))), div(z, WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up, but without overflow checks.\n    function rawMulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function sDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, WAD)\n            // Equivalent to `require(y != 0 && ((x * WAD) / WAD == x))`.\n            if iszero(mul(y, eq(sdiv(z, WAD), x))) {\n                mstore(0x00, 0x5c43740d) // `SDivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawDivWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawSDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up, but without overflow and divide by zero checks.\n    function rawDivWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `x` to the power of `y`.\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\n    /// Note: This function is an approximation.\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Using `ln(x)` means `x` must be greater than 0.\n        return expWad((lnWad(x) * y) / int256(WAD));\n    }\n\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is less than 0.5 we return zero.\n            // This happens when `x <= (log(1e-18) * 1e18) ~ -4.15e19`.\n            if (x <= -41446531673892822313) return r;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // When the result is greater than `(2**255 - 1) / 1e18` we can not represent it as\n                // an int. This happens when `x >= floor(log((2**255 - 1) / 1e18) * 1e18) ≈ 135`.\n                if iszero(slt(x, 135305999368893231589)) {\n                    mstore(0x00, 0xa37bfec9) // `ExpOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            // `x` is now in the range `(-42, 136) * 1e18`. Convert to `(-42, 136) * 2**96`\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5 ** 18;\n\n            // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // `k` is in the range `[-61, 195]`.\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // `p` is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already `2**96` too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range `(0.09, 0.25) * 2**96`.\n\n            // We now need to multiply r by:\n            // - The scale factor `s ≈ 6.031367120`.\n            // - The `2**k` factor from the range reduction.\n            // - The `1e18 / 2**96` factor for base conversion.\n            // We do this all at once, with an intermediate result in `2**213`\n            // basis, so the final right shift is always by a positive amount.\n            r = int256(\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\n            );\n        }\n    }\n\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We want to convert `x` from `10**18` fixed point to `2**96` fixed point.\n            // We do this by multiplying by `2**96 / 10**18`. But since\n            // `ln(x * C) = ln(x) + ln(C)`, we can simply do nothing here\n            // and add `ln(2**96 / 10**18)` at the end.\n\n            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // We place the check here for more optimal stack operations.\n            if iszero(sgt(x, 0)) {\n                mstore(0x00, 0x1615e638) // `LnWadUndefined()`.\n                revert(0x1c, 0x04)\n            }\n            // forgefmt: disable-next-item\n            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            x := shr(159, shl(r, x))\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // `p` is made monic, we will multiply by a scale factor later.\n            // forgefmt: disable-next-item\n            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.\n                sar(96, mul(add(43456485725739037958740375743393,\n                sar(96, mul(add(24828157081833163892658089445524,\n                sar(96, mul(add(3273285459638523848632254066296,\n                    x), x))), x))), x)), 11111509109440967052023855526967)\n            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)\n            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)\n            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n\n            // `q` is monic by convention.\n            let q := add(5573035233440673466300451813936, x)\n            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))\n            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))\n            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))\n            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))\n            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))\n            q := add(909429971244387300277376558375, sar(96, mul(x, q)))\n\n            // `p / q` is in the range `(0, 0.125) * 2**96`.\n\n            // Finalization, we need to:\n            // - Multiply by the scale factor `s = 5.549…`.\n            // - Add `ln(2**96 / 10**18)`.\n            // - Add `k * ln(2)`.\n            // - Multiply by `10**18 / 2**96 = 5**18 >> 78`.\n\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already `2**96` too large.\n            p := sdiv(p, q)\n            // Multiply by the scaling factor: `s * 5**18 * 2**96`, base is now `5**18 * 2**192`.\n            p := mul(1677202110996718588342820967067443963516166, p)\n            // Add `ln(2) * k * 5**18 * 2**192`.\n            // forgefmt: disable-next-item\n            p := add(mul(16597577552685614221487285958193947469193820559219878177908093499208371, sub(159, r)), p)\n            // Add `ln(2**96 / 10**18) * 5**18 * 2**192`.\n            p := add(600920179829731861736702779321621459595472258049074101567377883020018308, p)\n            // Base conversion: mul `2**18 / 2**192`.\n            r := sar(174, p)\n        }\n    }\n\n    /// @dev Returns `W_0(x)`, denominated in `WAD`.\n    /// See: https://en.wikipedia.org/wiki/Lambert_W_function\n    /// a.k.a. Product log function. This is an approximation of the principal branch.\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lambertW0Wad(int256 x) internal pure returns (int256 w) {\n        // forgefmt: disable-next-item\n        unchecked {\n            if ((w = x) <= -367879441171442322) revert OutOfDomain(); // `x` less than `-1/e`.\n            (int256 wad, int256 p) = (int256(WAD), x);\n            uint256 c; // Whether we need to avoid catastrophic cancellation.\n            uint256 i = 4; // Number of iterations.\n            if (w <= 0x1ffffffffffff) {\n                if (-0x4000000000000 <= w) {\n                    i = 1; // Inputs near zero only take one step to converge.\n                } else if (w <= -0x3ffffffffffffff) {\n                    i = 32; // Inputs near `-1/e` take very long to converge.\n                }\n            } else if (uint256(w >> 63) == uint256(0)) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // Inline log2 for more performance, since the range is small.\n                    let v := shr(49, w)\n                    let l := shl(3, lt(0xff, v))\n                    l := add(or(l, byte(and(0x1f, shr(shr(l, v), 0x8421084210842108cc6318c6db6d54be)),\n                        0x0706060506020504060203020504030106050205030304010505030400000000)), 49)\n                    w := sdiv(shl(l, 7), byte(sub(l, 31), 0x0303030303030303040506080c13))\n                    c := gt(l, 60)\n                    i := add(2, add(gt(l, 53), c))\n                }\n            } else {\n                int256 ll = lnWad(w = lnWad(w));\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // `w = ln(x) - ln(ln(x)) + b * ln(ln(x)) / ln(x)`.\n                    w := add(sdiv(mul(ll, 1023715080943847266), w), sub(w, ll))\n                    i := add(3, iszero(shr(68, x)))\n                    c := iszero(shr(143, x))\n                }\n                if (c == uint256(0)) {\n                    do { // If `x` is big, use Newton's so that intermediate values won't overflow.\n                        int256 e = expWad(w);\n                        /// @solidity memory-safe-assembly\n                        assembly {\n                            let t := mul(w, div(e, wad))\n                            w := sub(w, sdiv(sub(t, x), div(add(e, t), wad)))\n                        }\n                        if (p <= w) break;\n                        p = w;\n                    } while (--i != uint256(0));\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        w := sub(w, sgt(w, 2))\n                    }\n                    return w;\n                }\n            }\n            do { // Otherwise, use Halley's for faster convergence.\n                int256 e = expWad(w);\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let t := add(w, wad)\n                    let s := sub(mul(w, e), mul(x, wad))\n                    w := sub(w, sdiv(mul(s, wad), sub(mul(e, t), sdiv(mul(add(t, wad), s), add(t, t)))))\n                }\n                if (p <= w) break;\n                p = w;\n            } while (--i != c);\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sub(w, sgt(w, 2))\n            }\n            // For certain ranges of `x`, we'll use the quadratic-rate recursive formula of\n            // R. Iacono and J.P. Boyd for the last iteration, to avoid catastrophic cancellation.\n            if (c == uint256(0)) return w;\n            int256 t = w | 1;\n            /// @solidity memory-safe-assembly\n            assembly {\n                x := sdiv(mul(x, wad), t)\n            }\n            x = (t * (wad + lnWad(x)));\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sdiv(x, add(wad, t))\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  GENERAL NUMBER UTILITIES                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `a * b == x * y`, with full precision.\n    function fullMulEq(uint256 a, uint256 b, uint256 x, uint256 y)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(mul(a, b), mul(x, y)), eq(mulmod(x, y, not(0)), mulmod(a, b, not(0))))\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/21/muldiv\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // 512-bit multiply `[p1 p0] = x * y`.\n            // Compute the product mod `2**256` and mod `2**256 - 1`\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that `product = p1 * 2**256 + p0`.\n\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`.\n            for {} 1 {} {\n                // If overflows.\n                if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n\n                    /*------------------- 512 by 256 division --------------------*/\n\n                    // Make division exact by subtracting the remainder from `[p1 p0]`.\n                    let r := mulmod(x, y, d) // Compute remainder using mulmod.\n                    let t := and(d, sub(0, d)) // The least significant bit of `d`. `t >= 1`.\n                    // Make sure `z` is less than `2**256`. Also prevents `d == 0`.\n                    // Placing the check here seems to give more optimal stack operations.\n                    if iszero(gt(d, p1)) {\n                        mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    d := div(d, t) // Divide `d` by `t`, which is a power of two.\n                    // Invert `d mod 2**256`\n                    // Now that `d` is an odd number, it has an inverse\n                    // modulo `2**256` such that `d * inv = 1 mod 2**256`.\n                    // Compute the inverse by starting with a seed that is correct\n                    // correct for four bits. That is, `d * inv = 1 mod 2**4`.\n                    let inv := xor(2, mul(3, d))\n                    // Now use Newton-Raphson iteration to improve the precision.\n                    // Thanks to Hensel's lifting lemma, this also works in modular\n                    // arithmetic, doubling the correct bits in each step.\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\n                    z :=\n                        mul(\n                            // Divide [p1 p0] by the factors of two.\n                            // Shift in bits from `p1` into `p0`. For this we need\n                            // to flip `t` such that it is `2**256 / t`.\n                            or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                            mul(sub(2, mul(d, inv)), inv) // inverse mod 2**256\n                        )\n                    break\n                }\n                z := div(z, d)\n                break\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Behavior is undefined if `d` is zero or the final result cannot fit in 256 bits.\n    /// Performs the full 512 bit calculation regardless.\n    function fullMulDivUnchecked(uint256 x, uint256 y, uint256 d)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            let mm := mulmod(x, y, not(0))\n            let p1 := sub(mm, add(z, lt(mm, z)))\n            let t := and(d, sub(0, d))\n            let r := mulmod(x, y, d)\n            d := div(d, t)\n            let inv := xor(2, mul(3, d))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            z :=\n                mul(\n                    or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                    mul(sub(2, mul(d, inv)), inv)\n                )\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Uniswap-v3-core under MIT license:\n    /// https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        z = fullMulDiv(x, y, d);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mulmod(x, y, d) {\n                z := add(z, 1)\n                if iszero(z) {\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / 2 ** n)` with full precision.\n    /// Throws if result overflows a uint256.\n    /// Credit to Philogy under MIT license:\n    /// https://github.com/SorellaLabs/angstrom/blob/main/contracts/src/libraries/X128MathLib.sol\n    function fullMulDivN(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`. We'll call this `z`.\n            for {} 1 {} {\n                if iszero(or(iszero(x), eq(div(z, x), y))) {\n                    let k := and(n, 0xff) // `n`, cleaned.\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n                    //         |      p1     |      z     |\n                    // Before: | p1_0 ¦ p1_1 | z_0  ¦ z_1 |\n                    // Final:  |   0  ¦ p1_0 | p1_1 ¦ z_0 |\n                    // Check that final `z` doesn't overflow by checking that p1_0 = 0.\n                    if iszero(shr(k, p1)) {\n                        z := add(shl(sub(256, k), p1), shr(k, z))\n                        break\n                    }\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                z := shr(and(n, 0xff), z)\n                break\n            }\n        }\n    }\n\n    /// @dev Returns `floor(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(z, d)\n        }\n    }\n\n    /// @dev Returns `ceil(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(z, d))), div(z, d))\n        }\n    }\n\n    /// @dev Returns `x`, the modular multiplicative inverse of `a`, such that `(a * x) % n == 1`.\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256 x) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let g := n\n            let r := mod(a, n)\n            for { let y := 1 } 1 {} {\n                let q := div(g, r)\n                let t := g\n                g := r\n                r := sub(t, mul(r, q))\n                let u := x\n                x := y\n                y := sub(u, mul(y, q))\n                if iszero(r) { break }\n            }\n            x := mul(eq(g, 1), add(x, mul(slt(x, 0), n)))\n        }\n    }\n\n    /// @dev Returns `ceil(x / d)`.\n    /// Reverts if `d` is zero.\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(d) {\n                mstore(0x00, 0x65244e4e) // `DivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`. Alias for `saturatingSub`.\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`.\n    function saturatingSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Returns `min(2 ** 256 - 1, x + y)`.\n    function saturatingAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(sub(0, lt(add(x, y), x)), add(x, y))\n        }\n    }\n\n    /// @dev Returns `min(2 ** 256 - 1, x * y)`.\n    function saturatingMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(sub(or(iszero(x), eq(div(mul(x, y), x), y)), 1), mul(x, y))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, address x, address y) internal pure returns (address z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `x != 0 ? x : y`, without branching.\n    function coalesce(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, mul(y, iszero(x)))\n        }\n    }\n\n    /// @dev Returns `x != bytes32(0) ? x : y`, without branching.\n    function coalesce(bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, mul(y, iszero(x)))\n        }\n    }\n\n    /// @dev Returns `x != address(0) ? x : y`, without branching.\n    function coalesce(address x, address y) internal pure returns (address z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, mul(y, iszero(shl(96, x))))\n        }\n    }\n\n    /// @dev Exponentiate `x` to `y` by squaring, denominated in base `b`.\n    /// Reverts if the computation overflows.\n    function rpow(uint256 x, uint256 y, uint256 b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(b, iszero(y)) // `0 ** 0 = 1`. Otherwise, `0 ** n = 0`.\n            if x {\n                z := xor(b, mul(xor(b, x), and(y, 1))) // `z = isEven(y) ? scale : x`\n                let half := shr(1, b) // Divide `b` by 2.\n                // Divide `y` by 2 every iteration.\n                for { y := shr(1, y) } y { y := shr(1, y) } {\n                    let xx := mul(x, x) // Store x squared.\n                    let xxRound := add(xx, half) // Round to the nearest number.\n                    // Revert if `xx + half` overflowed, or if `x ** 2` overflows.\n                    if or(lt(xxRound, xx), shr(128, x)) {\n                        mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                        revert(0x1c, 0x04)\n                    }\n                    x := div(xxRound, b) // Set `x` to scaled `xxRound`.\n                    // If `y` is odd:\n                    if and(y, 1) {\n                        let zx := mul(z, x) // Compute `z * x`.\n                        let zxRound := add(zx, half) // Round to the nearest number.\n                        // If `z * x` overflowed or `zx + half` overflowed:\n                        if or(xor(div(zx, x), z), lt(zxRound, zx)) {\n                            // Revert if `x` is non-zero.\n                            if x {\n                                mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                                revert(0x1c, 0x04)\n                            }\n                        }\n                        z := div(zxRound, b) // Return properly scaled `zxRound`.\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the square root of `x`, rounded down.\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // Let `y = x / 2**r`. We check `y >= 2**(k + 8)`\n            // but shift right by `k` bits to ensure that if `x >= 256`, then `y >= 256`.\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\n            z := shl(shr(1, r), z)\n\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\n\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\n\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\n\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\n            // Then we can estimate `sqrt(y)` using\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\n\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If `x+1` is a perfect square, the Babylonian method cycles between\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, rounded down.\n    /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:\n    /// https://github.com/pcaversaccio/snekmate/blob/main/src/snekmate/utils/math.vy\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // Makeshift lookup table to nudge the approximate log2 result.\n            z := div(shl(div(r, 3), shl(lt(0xf, shr(r, x)), 0xf)), xor(7, mod(r, 3)))\n            // Newton-Raphson's.\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            // Round down.\n            z := sub(z, lt(div(x, mul(z, z)), z))\n        }\n    }\n\n    /// @dev Returns the square root of `x`, denominated in `WAD`, rounded down.\n    function sqrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 18) return sqrt(x * 10 ** 18);\n            z = (1 + sqrt(x)) * 10 ** 9;\n            z = (fullMulDivUnchecked(x, 10 ** 18, z) + z) >> 1;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sub(z, gt(999999999999999999, sub(mulmod(z, z, x), 1))) // Round down.\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, denominated in `WAD`, rounded down.\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 36) return cbrt(x * 10 ** 36);\n            z = (1 + cbrt(x)) * 10 ** 12;\n            z = (fullMulDivUnchecked(x, 10 ** 36, z * z) + z + z) / 3;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let p := x\n            for {} 1 {} {\n                if iszero(shr(229, p)) {\n                    if iszero(shr(199, p)) {\n                        p := mul(p, 100000000000000000) // 10 ** 17.\n                        break\n                    }\n                    p := mul(p, 100000000) // 10 ** 8.\n                    break\n                }\n                if iszero(shr(249, p)) { p := mul(p, 100) }\n                break\n            }\n            let t := mulmod(mul(z, z), z, p)\n            z := sub(z, gt(lt(t, shr(1, p)), iszero(t))) // Round down.\n        }\n    }\n\n    /// @dev Returns the factorial of `x`.\n    function factorial(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := 1\n            if iszero(lt(x, 58)) {\n                mstore(0x00, 0xaba0f2a2) // `FactorialOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            for {} x { x := sub(x, 1) } { z := mul(z, x) }\n        }\n    }\n\n    /// @dev Returns the log2 of `x`.\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\n    /// Returns 0 if `x` is zero.\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020504060203020504030106050205030304010505030400000000))\n        }\n    }\n\n    /// @dev Returns the log2 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\n        r = log2(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(r, 1), x))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log10(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, 100000000000000000000000000000000000000)) {\n                x := div(x, 100000000000000000000000000000000000000)\n                r := 38\n            }\n            if iszero(lt(x, 100000000000000000000)) {\n                x := div(x, 100000000000000000000)\n                r := add(r, 20)\n            }\n            if iszero(lt(x, 10000000000)) {\n                x := div(x, 10000000000)\n                r := add(r, 10)\n            }\n            if iszero(lt(x, 100000)) {\n                x := div(x, 100000)\n                r := add(r, 5)\n            }\n            r := add(r, add(gt(x, 9), add(gt(x, 99), add(gt(x, 999), gt(x, 9999)))))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log10Up(uint256 x) internal pure returns (uint256 r) {\n        r = log10(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(exp(10, r), x))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(shr(3, r), lt(0xff, shr(r, x)))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log256Up(uint256 x) internal pure returns (uint256 r) {\n        r = log256(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(shl(3, r), 1), x))\n        }\n    }\n\n    /// @dev Returns the scientific notation format `mantissa * 10 ** exponent` of `x`.\n    /// Useful for compressing prices (e.g. using 25 bit mantissa and 7 bit exponent).\n    function sci(uint256 x) internal pure returns (uint256 mantissa, uint256 exponent) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mantissa := x\n            if mantissa {\n                if iszero(mod(mantissa, 1000000000000000000000000000000000)) {\n                    mantissa := div(mantissa, 1000000000000000000000000000000000)\n                    exponent := 33\n                }\n                if iszero(mod(mantissa, 10000000000000000000)) {\n                    mantissa := div(mantissa, 10000000000000000000)\n                    exponent := add(exponent, 19)\n                }\n                if iszero(mod(mantissa, 1000000000000)) {\n                    mantissa := div(mantissa, 1000000000000)\n                    exponent := add(exponent, 12)\n                }\n                if iszero(mod(mantissa, 1000000)) {\n                    mantissa := div(mantissa, 1000000)\n                    exponent := add(exponent, 6)\n                }\n                if iszero(mod(mantissa, 10000)) {\n                    mantissa := div(mantissa, 10000)\n                    exponent := add(exponent, 4)\n                }\n                if iszero(mod(mantissa, 100)) {\n                    mantissa := div(mantissa, 100)\n                    exponent := add(exponent, 2)\n                }\n                if iszero(mod(mantissa, 10)) {\n                    mantissa := div(mantissa, 10)\n                    exponent := add(exponent, 1)\n                }\n            }\n        }\n    }\n\n    /// @dev Convenience function for packing `x` into a smaller number using `sci`.\n    /// The `mantissa` will be in bits [7..255] (the upper 249 bits).\n    /// The `exponent` will be in bits [0..6] (the lower 7 bits).\n    /// Use `SafeCastLib` to safely ensure that the `packed` number is small\n    /// enough to fit in the desired unsigned integer type:\n    /// ```\n    ///     uint32 packed = SafeCastLib.toUint32(FixedPointMathLib.packSci(777 ether));\n    /// ```\n    function packSci(uint256 x) internal pure returns (uint256 packed) {\n        (x, packed) = sci(x); // Reuse for `mantissa` and `exponent`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            if shr(249, x) {\n                mstore(0x00, 0xce30380c) // `MantissaOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            packed := or(shl(7, x), packed)\n        }\n    }\n\n    /// @dev Convenience function for unpacking a packed number from `packSci`.\n    function unpackSci(uint256 packed) internal pure returns (uint256 unpacked) {\n        unchecked {\n            unpacked = (packed >> 7) * 10 ** (packed & 0x7f);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards zero.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = (x & y) + ((x ^ y) >> 1);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards negative infinity.\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @dev Returns the absolute value of `x`.\n    function abs(int256 x) internal pure returns (uint256 z) {\n        unchecked {\n            z = (uint256(x) + uint256(x >> 255)) ^ uint256(x >> 255);\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, gt(x, y)), sub(y, x)), gt(x, y))\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, sgt(x, y)), sub(y, x)), sgt(x, y))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), lt(y, x)))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), slt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), gt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), gt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), lt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), sgt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), slt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns greatest common divisor of `x` and `y`.\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { z := x } y {} {\n                let t := y\n                y := mod(z, y)\n                z := t\n            }\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`,\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(uint256 a, uint256 b, uint256 t, uint256 begin, uint256 end)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        unchecked {\n            if (b >= a) return a + fullMulDiv(b - a, t - begin, end - begin);\n            return a - fullMulDiv(a - b, t - begin, end - begin);\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`.\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(int256 a, int256 b, int256 t, int256 begin, int256 end)\n        internal\n        pure\n        returns (int256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        // forgefmt: disable-next-item\n        unchecked {\n            if (b >= a) return int256(uint256(a) + fullMulDiv(uint256(b - a),\n                uint256(t - begin), uint256(end - begin)));\n            return int256(uint256(a) - fullMulDiv(uint256(a - b),\n                uint256(t - begin), uint256(end - begin)));\n        }\n    }\n\n    /// @dev Returns if `x` is an even number. Some people may need this.\n    function isEven(uint256 x) internal pure returns (bool) {\n        return x & uint256(1) == uint256(0);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   RAW NUMBER OPERATIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(x, y)\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mod(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := smod(x, y)\n        }\n    }\n\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := addmod(x, y, d)\n        }\n    }\n\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mulmod(x, y, d)\n        }\n    }\n}\n"
      },
      "/Users/williamcory/cavalre-contracts/libraries/FloatLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.26;\n\nimport {FixedPointMathLib} from \"/Users/williamcory/cavalre-contracts/node_modules/solady/src/utils/FixedPointMathLib.sol\";\n\ntype Float is int256;\n\nlibrary FloatLib {\n    using FloatLib for Float;\n    using FixedPointMathLib for uint256;\n    using FixedPointMathLib for int256;\n\n    // Errors\n    error NoSolution();\n\n    //===============\n    //   Constants\n    //===============\n    uint256 constant SIGNIFICANT_DIGITS = 18;\n    uint256 constant NORMALIZED_MANTISSA_MAX = 10 ** SIGNIFICANT_DIGITS - 1;\n    uint256 constant NORMALIZED_MANTISSA_MIN = 10 ** (SIGNIFICANT_DIGITS - 1);\n\n    int256 constant ONE_MANTISSA = int256(10 ** (SIGNIFICANT_DIGITS - 1));\n    int256 constant ONE_EXPONENT = -int256(SIGNIFICANT_DIGITS - 1);\n\n    int256 constant LOG10 = 2302585092994045684;\n\n    uint256 constant MANTISSA_MASK = (uint256(1) << 128) - 1;\n\n    Float constant ZERO = Float.wrap(0);\n    Float constant ONE = Float.wrap((ONE_EXPONENT << 128) | (ONE_MANTISSA & int256(MANTISSA_MASK)));\n    Float constant TWO = Float.wrap((ONE_EXPONENT << 128) | ((2 * ONE_MANTISSA) & int256(MANTISSA_MASK)));\n    Float constant THREE = Float.wrap((ONE_EXPONENT << 128) | ((3 * ONE_MANTISSA) & int256(MANTISSA_MASK)));\n    Float constant FOUR = Float.wrap((ONE_EXPONENT << 128) | ((4 * ONE_MANTISSA) & int256(MANTISSA_MASK)));\n    Float constant FIVE = Float.wrap((ONE_EXPONENT << 128) | ((5 * ONE_MANTISSA) & int256(MANTISSA_MASK)));\n    Float constant SIX = Float.wrap((ONE_EXPONENT << 128) | ((6 * ONE_MANTISSA) & int256(MANTISSA_MASK)));\n    Float constant SEVEN = Float.wrap((ONE_EXPONENT << 128) | ((7 * ONE_MANTISSA) & int256(MANTISSA_MASK)));\n    Float constant EIGHT = Float.wrap((ONE_EXPONENT << 128) | ((8 * ONE_MANTISSA) & int256(MANTISSA_MASK)));\n    Float constant NINE = Float.wrap((ONE_EXPONENT << 128) | ((9 * ONE_MANTISSA) & int256(MANTISSA_MASK)));\n    Float constant TEN = Float.wrap(((ONE_EXPONENT + 1) << 128) | (ONE_MANTISSA & int256(MANTISSA_MASK)));\n\n    //=================\n    //   Conversions\n    //=================\n\n    //-----------\n    //   toInt\n    //-----------\n    function toInt(uint256 a_) internal pure returns (int256) {\n        require(a_ <= uint256(type(int256).max), \"Value out of int256 range\");\n        return int256(a_);\n    }\n\n    function toInt(Float a_, uint256 decimals_) internal pure returns (int256) {\n        (int256 _mantissa, int256 _exponent) = components(a_);\n        int256 _exp = _exponent + toInt(decimals_);\n        if (_exp >= 0) {\n            return _mantissa * int256(10 ** toUInt(_exp));\n        } else {\n            return _mantissa / int256(10 ** toUInt(-_exp));\n        }\n    }\n\n    function toInt(Float a_) internal pure returns (int256) {\n        return toInt(a_, 18);\n    }\n\n    //------------\n    //   toUInt\n    //------------\n    function toUInt(int256 a_) internal pure returns (uint256) {\n        require(a_ >= 0, \"Value must be non-negative\");\n        return uint256(a_);\n    }\n\n    function toUInt(Float a_, uint256 decimals_) internal pure returns (uint256) {\n        (int256 _mantissa, int256 _exponent) = components(a_);\n        require(_mantissa >= 0, \"Value must be non-negative\");\n        int256 _exp = _exponent + toInt(decimals_);\n        if (_exp >= 0) {\n            return uint256(_mantissa) * 10 ** toUInt(_exp);\n        } else {\n            return uint256(_mantissa) / 10 ** toUInt(-_exp);\n        }\n    }\n\n    function toUInt(Float a_) internal pure returns (uint256) {\n        return toUInt(a_, 18);\n    }\n\n    //--------------\n    //   toFloat\n    //--------------\n\n    function toFloat(int256 a_, uint256 decimals_) internal pure returns (Float) {\n        return normalize(a_, -toInt(decimals_));\n    }\n\n    function toFloat(int256 a_) internal pure returns (Float) {\n        return toFloat(a_, 18);\n    }\n\n    function toFloat(uint256 a_, uint256 decimals_) internal pure returns (Float) {\n        require(a_ <= uint256(type(int256).max), \"Value out of int256 range\");\n        return normalize(int256(a_), -toInt(decimals_));\n    }\n\n    function toFloat(uint256 a_) internal pure returns (Float) {\n        return toFloat(a_, 18);\n    }\n\n    //-------------------\n    //   toFloatArray\n    //-------------------\n\n    function toFloatArray(int256[] memory a_, uint256[] memory decimals_) internal pure returns (Float[] memory) {\n        Float[] memory _result = new Float[](a_.length);\n        for (uint256 _i = 0; _i < a_.length; _i++) {\n            _result[_i] = toFloat(a_[_i], decimals_[_i]);\n        }\n        return _result;\n    }\n\n    function toFloatArray(int256[] memory a_) internal pure returns (Float[] memory) {\n        Float[] memory _result = new Float[](a_.length);\n        for (uint256 _i = 0; _i < a_.length; _i++) {\n            _result[_i] = toFloat(a_[_i]);\n        }\n        return _result;\n    }\n\n    //=================\n    //   Comparisons\n    //=================\n    //----------\n    //   isEQ\n    //----------\n    function isEQ(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) == mantissa(_alignedB);\n    }\n\n    function isGT(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) > mantissa(_alignedB);\n    }\n\n    function isGEQ(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) >= mantissa(_alignedB);\n    }\n\n    function isLT(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) < mantissa(_alignedB);\n    }\n\n    function isLEQ(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) <= mantissa(_alignedB);\n    }\n\n    //=====================\n    //   Transformations\n    //=====================\n    function abs(Float a_) internal pure returns (Float) {\n        return from(int256(mantissa(a_).abs()), exponent(a_));\n    }\n\n    function integerPart(Float number_) internal pure returns (Float) {\n        (int256 _mantissa, int256 _exponent) = components(number_);\n        if (_exponent < 0) {\n            int256 _temp = _mantissa;\n            for (uint256 _i; _i < toUInt(-_exponent); _i++) {\n                _temp /= 10;\n                if (_temp == 0) return ZERO;\n            }\n            return from(_temp, 0);\n        } else {\n            return number_;\n        }\n    }\n\n    //-----------\n    //   Shift\n    //-----------\n    function shift(Float a_, int256 i_) internal pure returns (Float) {\n        int256 _mantissa = mantissa(a_);\n        if (i_ == 0 || _mantissa == 0) return a_;\n\n        uint256 _k = i_ > 0 ? uint256(i_) : uint256(-i_);\n\n        int256 _m = _mantissa;\n        int256 _e = exponent(a_) + i_;\n\n        if (i_ > 0) {\n            while (_k >= 16) {\n                _m /= 1e16;\n                _k -= 16;\n            }\n            if (_k >= 8) {\n                _m /= 1e8;\n                _k -= 8;\n            }\n            if (_k >= 4) {\n                _m /= 1e4;\n                _k -= 4;\n            }\n            if (_k >= 2) {\n                _m /= 1e2;\n                _k -= 2;\n            }\n            if (_k >= 1) _m /= 10;\n        } else {\n            require(_k <= SIGNIFICANT_DIGITS, \"shift: |i| too large\");\n            while (_k >= 16) {\n                _m *= 1e16;\n                _k -= 16;\n            }\n            if (_k >= 8) {\n                _m *= 1e8;\n                _k -= 8;\n            }\n            if (_k >= 4) {\n                _m *= 1e4;\n                _k -= 4;\n            }\n            if (_k >= 2) {\n                _m *= 1e2;\n                _k -= 2;\n            }\n            if (_k >= 1) _m *= 10;\n        }\n\n        return from(_m, _e);\n    }\n\n    //---------------\n    //   normalize\n    //---------------\n    function normalize(int256 mantissa_, int256 exponent_) internal pure returns (Float) {\n        if (mantissa_ == 0) return ZERO;\n\n        int256 _m = mantissa_;\n        int256 _e = exponent_;\n\n        uint256 _mag = abs256(_m);\n\n        if (_mag > NORMALIZED_MANTISSA_MAX) {\n            while (_mag > NORMALIZED_MANTISSA_MAX) {\n                _m /= 10;\n                _e += 1;\n                _mag /= 10;\n            }\n            return from(_m, _e);\n        }\n\n        if (_mag < NORMALIZED_MANTISSA_MIN) {\n            while (_mag < NORMALIZED_MANTISSA_MIN) {\n                _m *= 10;\n                _e -= 1;\n                _mag *= 10;\n            }\n            return from(_m, _e);\n        }\n\n        return from(_m, _e);\n    }\n\n    function normalize(Float a_) internal pure returns (Float) {\n        (int256 _mantissa, int256 _exponent) = components(a_);\n        return normalize(_mantissa, _exponent);\n    }\n\n    //-----------\n    //   align\n    //-----------\n    function align(Float a_, Float b_) internal pure returns (Float, Float) {\n        (int256 _aMantissa, int256 _aExponent) = components(a_);\n        (int256 _bMantissa, int256 _bExponent) = components(b_);\n        if (_aMantissa == 0 && _bMantissa == 0) {\n            return (ZERO, ZERO);\n        } else if (_aMantissa == 0) {\n            return (from(0, _bExponent), from(_bMantissa, _bExponent));\n        } else if (_bMantissa == 0) {\n            return (from(_aMantissa, _aExponent), from(0, _aExponent));\n        }\n\n        Float _normA = normalize(a_);\n        Float _normB = normalize(b_);\n        _aMantissa = mantissa(_normA);\n        _aExponent = exponent(_normA);\n        _bMantissa = mantissa(_normB);\n        _bExponent = exponent(_normB);\n\n        int256 _delta = _aExponent - _bExponent;\n        if (_delta >= 0) {\n            if (uint256(_delta) > SIGNIFICANT_DIGITS) {\n                return (_normA, from(0, _aExponent));\n            }\n            return (_normA, shift(_normB, _delta));\n        } else {\n            if (uint256(-_delta) > SIGNIFICANT_DIGITS) {\n                return (from(0, _bExponent), _normB);\n            }\n            return (shift(_normA, -_delta), _normB);\n        }\n    }\n\n    //================\n    //   Arithmetic\n    //================\n    function plus(Float a_, Float b_) internal pure returns (Float) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return normalize(mantissa(_alignedA) + mantissa(_alignedB), exponent(_alignedA));\n    }\n\n    function minus(Float a_) internal pure returns (Float) {\n        return from(-mantissa(a_), exponent(a_));\n    }\n\n    function minus(Float a_, Float b_) internal pure returns (Float) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return normalize(mantissa(_alignedA) - mantissa(_alignedB), exponent(_alignedA));\n    }\n\n    function times(Float a_, Float b_) internal pure returns (Float) {\n        Float _normA = normalize(a_);\n        Float _normB = normalize(b_);\n        return normalize(\n            (mantissa(_normA) * mantissa(_normB)) / int256(10 ** SIGNIFICANT_DIGITS),\n            toInt(SIGNIFICANT_DIGITS) + exponent(_normA) + exponent(_normB)\n        );\n    }\n\n    function divide(Float a_, Float b_) internal pure returns (Float) {\n        Float _normA = normalize(a_);\n        Float _normB = normalize(b_);\n        return normalize(\n            (mantissa(_normA) * int256(10 ** SIGNIFICANT_DIGITS)) / mantissa(_normB),\n            exponent(_normA) - exponent(_normB) - toInt(SIGNIFICANT_DIGITS)\n        );\n    }\n\n    //=======================\n    //   Special functions\n    //=======================\n    function round(Float a_, uint256 digits_) internal pure returns (Float) {\n        if (mantissa(a_) == 0) return ZERO;\n        Float _norm = normalize(a_);\n        int256 _factor = int256(10 ** (SIGNIFICANT_DIGITS - digits_));\n        int256 _scaled = mantissa(_norm) / _factor;\n        int256 _remainder = mantissa(_norm) % _factor;\n        if (_remainder * 2 >= _factor) {\n            _scaled++;\n        }\n        if (_remainder * 2 <= -_factor) {\n            _scaled--;\n        }\n        return from(_scaled * _factor, exponent(_norm));\n    }\n\n    function exp(int256 a_) internal pure returns (Float) {\n        int256 _k = a_ / LOG10;\n        int256 _aprime = a_ - _k * LOG10;\n        return normalize(_aprime.expWad(), _k - 18);\n    }\n\n    function log(Float a_) internal pure returns (int256) {\n        Float _norm = normalize(a_);\n        return int256(mantissa(_norm)).lnWad() + (exponent(_norm) + 18) * LOG10;\n    }\n\n    struct Cubic {\n        Float p;\n        Float q;\n        Float rad;\n        Float u;\n        Float w;\n    }\n\n    function cubicsolve(Float b_, Float c_, Float d_) internal pure returns (Float _x) {\n        Cubic memory _cubic;\n\n        _cubic.p = minus(c_, divide(times(b_, b_), THREE));\n        _cubic.q =\n            minus(plus(d_, divide(times(b_, times(b_, b_)), from(135, -1))), divide(times(b_, c_), from(3e17, -17)));\n        _cubic.rad = plus(\n            divide(times(_cubic.q, _cubic.q), FOUR), divide(times(_cubic.p, times(_cubic.p, _cubic.p)), from(27, 0))\n        );\n        if (isLT(_cubic.rad, ZERO)) revert NoSolution();\n        _cubic.u = minus(exp(log(_cubic.rad) / 2), divide(_cubic.q, TWO));\n        _cubic.w = mantissa(_cubic.u) > 0 ? exp(log(_cubic.u) / 3) : minus(exp(log(minus(_cubic.u)) / 3));\n\n        _x = minus(minus(_cubic.w, divide(_cubic.p, times(THREE, _cubic.w))), divide(b_, THREE));\n    }\n\n    function fullMulDiv(Float a_, Float b_, Float c_) internal pure returns (Float) {\n        int256 _sign = 1;\n        if (mantissa(a_) < 0) {\n            _sign *= -1;\n        }\n        if (mantissa(b_) < 0) {\n            _sign *= -1;\n        }\n        if (mantissa(c_) < 0) {\n            _sign *= -1;\n        }\n        Float _normA = normalize(a_);\n        Float _normB = normalize(b_);\n        Float _normC = normalize(c_);\n        return normalize(\n            _sign * int256(mantissa(_normA).abs().fullMulDiv(mantissa(_normB).abs(), mantissa(_normC).abs())),\n            exponent(_normA) + exponent(_normB) - exponent(_normC)\n        );\n    }\n\n    //====================\n    //   Helper methods\n    //====================\n    function from(int256 mantissa_, int256 exponent_) internal pure returns (Float) {\n        require(mantissa_ >= type(int128).min && mantissa_ <= type(int128).max, \"Mantissa overflow\");\n        require(exponent_ >= type(int128).min && exponent_ <= type(int128).max, \"Exponent overflow\");\n        int256 _packed = (exponent_ << 128) | (mantissa_ & int256(MANTISSA_MASK));\n        return Float.wrap(_packed);\n    }\n\n    function components(Float a_) internal pure returns (int256 _mantissa, int256 _exponent) {\n        int256 _raw = Float.unwrap(a_);\n        _mantissa = int256(int128(_raw));\n        _exponent = int256(int128(_raw >> 128));\n    }\n\n    function mantissa(Float a_) internal pure returns (int256) {\n        return int256(int128(Float.unwrap(a_)));\n    }\n\n    function exponent(Float a_) internal pure returns (int256) {\n        return int256(int128(Float.unwrap(a_) >> 128));\n    }\n\n    function abs256(int256 x_) internal pure returns (uint256) {\n        if (x_ >= 0) return uint256(x_);\n        unchecked {\n            return uint256(~x_) + 1;\n        }\n    }\n}\n"
      }
    },
    "settings": {
      "outputSelection": {
        "*": {
          "*": [
            "abi",
            "userdoc",
            "evm.bytecode.object",
            "evm.deployedBytecode.object"
          ]
        }
      }
    }
  },
  "solcOutput": {
    "contracts": {
      "/Users/williamcory/cavalre-contracts/libraries/FloatLib.sol": {
        "FloatLib": {
          "abi": [
            {
              "inputs": [],
              "name": "NoSolution",
              "type": "error"
            }
          ],
          "evm": {
            "bytecode": {
              "object": "6055604b600b8282823980515f1a607314603f577f4e487b71000000000000000000000000000000000000000000000000000000005f525f60045260245ffd5b305f52607381538281f3fe730000000000000000000000000000000000000000301460806040525f5ffdfea2646970667358221220cbe406e452416d4e6f84d62c42ce23c4769dad09d75b6561a6ec8fd482052c9a64736f6c634300081e0033"
            },
            "deployedBytecode": {
              "object": "730000000000000000000000000000000000000000301460806040525f5ffdfea2646970667358221220cbe406e452416d4e6f84d62c42ce23c4769dad09d75b6561a6ec8fd482052c9a64736f6c634300081e0033"
            }
          },
          "userdoc": {
            "kind": "user",
            "methods": {},
            "version": 1
          }
        }
      },
      "/Users/williamcory/cavalre-contracts/libraries/FloatStrings.sol": {
        "FloatStrings": {
          "abi": [
            {
              "inputs": [
                {
                  "internalType": "uint256",
                  "name": "number_",
                  "type": "uint256"
                }
              ],
              "name": "digits",
              "outputs": [
                {
                  "internalType": "uint8",
                  "name": "",
                  "type": "uint8"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "bytes",
                  "name": "strBytes_",
                  "type": "bytes"
                },
                {
                  "internalType": "uint256",
                  "name": "numChars_",
                  "type": "uint256"
                }
              ],
              "name": "shiftStringBytesLeft",
              "outputs": [
                {
                  "internalType": "bytes",
                  "name": "",
                  "type": "bytes"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "bytes",
                  "name": "strBytes_",
                  "type": "bytes"
                },
                {
                  "internalType": "uint256",
                  "name": "numChars_",
                  "type": "uint256"
                }
              ],
              "name": "shiftStringBytesRight",
              "outputs": [
                {
                  "internalType": "bytes",
                  "name": "_result",
                  "type": "bytes"
                },
                {
                  "internalType": "bytes",
                  "name": "_remainder",
                  "type": "bytes"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "string",
                  "name": "str_",
                  "type": "string"
                },
                {
                  "internalType": "uint256",
                  "name": "numChars_",
                  "type": "uint256"
                }
              ],
              "name": "shiftStringLeft",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "string",
                  "name": "str_",
                  "type": "string"
                },
                {
                  "internalType": "uint256",
                  "name": "numChars_",
                  "type": "uint256"
                }
              ],
              "name": "shiftStringRight",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "_result",
                  "type": "string"
                },
                {
                  "internalType": "string",
                  "name": "_remainder",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "uint256",
                  "name": "value_",
                  "type": "uint256"
                }
              ],
              "name": "toString",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "value_",
                  "type": "int256"
                }
              ],
              "name": "toString",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "uint256",
                  "name": "value_",
                  "type": "uint256"
                }
              ],
              "name": "toStringBytes",
              "outputs": [
                {
                  "internalType": "bytes",
                  "name": "",
                  "type": "bytes"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "bytes",
                  "name": "strBytes_",
                  "type": "bytes"
                }
              ],
              "name": "trimStringBytesRight",
              "outputs": [
                {
                  "internalType": "bytes",
                  "name": "",
                  "type": "bytes"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "string",
                  "name": "str_",
                  "type": "string"
                }
              ],
              "name": "trimStringRight",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            }
          ],
          "evm": {
            "bytecode": {
              "object": "61122c61004d600b8282823980515f1a6073146041577f4e487b71000000000000000000000000000000000000000000000000000000005f525f60045260245ffd5b305f52607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100a7575f3560e01c80636f74acfc1161006f5780636f74acfc1461019b5780637b23c90d146101cc578063a322c40e146101fc578063f5d39bab1461022c578063fb85559f1461025d576100a7565b806304eaf90b146100ab5780630efc2a42146100db5780632ed038321461010b5780635a770e1d1461013b5780636900a3ae1461016b575b5f5ffd5b6100c560048036038101906100c09190610bca565b61028d565b6040516100d29190610c84565b60405180910390f35b6100f560048036038101906100f09190610d42565b6102a1565b6040516101029190610dee565b60405180910390f35b61012560048036038101906101209190610e0e565b6103f5565b6040516101329190610c84565b60405180910390f35b61015560048036038101906101509190610e55565b610407565b6040516101629190610dee565b60405180910390f35b61018560048036038101906101809190610e55565b61053f565b6040516101929190610c84565b60405180910390f35b6101b560048036038101906101b09190610bca565b610551565b6040516101c3929190610e80565b60405180910390f35b6101e660048036038101906101e19190610e55565b61057d565b6040516101f39190610ed0565b60405180910390f35b61021660048036038101906102119190610f1c565b6105c6565b6040516102239190610c84565b60405180910390f35b61024660048036038101906102419190610d42565b610652565b604051610254929190610f47565b60405180910390f35b61027760048036038101906102729190610f7c565b6108b0565b6040516102849190610dee565b60405180910390f35b606061029983836102a1565b905092915050565b60605f8284516102b19190610ff0565b67ffffffffffffffff8111156102ca576102c9610a73565b5b6040519080825280601f01601f1916602001820160405280156102fc5781602001600182028036833780820191505090505b5090505f5f90505b81518110156103ea57845181101561037a5784818151811061032957610328611023565b5b602001015160f81c60f81b82828151811061034757610346611023565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053506103dd565b7f30000000000000000000000000000000000000000000000000000000000000008282815181106103ae576103ad611023565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053505b8080600101915050610304565b508091505092915050565b6060610400826108b0565b9050919050565b60605f820361044d576040518060400160405280600181526020017f3000000000000000000000000000000000000000000000000000000000000000815250905061053a565b5f6104578361057d565b60ff1690505f8167ffffffffffffffff81111561047757610476610a73565b5b6040519080825280601f01601f1916602001820160405280156104a95781602001600182028036833780820191505090505b5090505b5f8414610534576001826104c19190611050565b9150600a846104d091906110b0565b60306104dc9190610ff0565b60f81b8183815181106104f2576104f1611023565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a905350600a8461052d91906110e0565b93506104ad565b80925050505b919050565b606061054a82610407565b9050919050565b6060805f8490506060806105658387610652565b80925081935050508194508093505050509250929050565b5f5f820361058e57600190506105c1565b5f5f90505b5f83146105bc5780806105a590611110565b915050600a836105b591906110e0565b9250610593565b809150505b919050565b60605f82126105e35760405180602001604052805f81525061061a565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b61062b61062684610a35565b610407565b60405160200161063c9291906111ac565b6040516020818303038152906040529050919050565b6060805f5f5f86518611156106c8575f92508651866106719190611050565b9050600167ffffffffffffffff81111561068e5761068d610a73565b5b6040519080825280601f01601f1916602001820160405280156106c05781602001600182028036833780820191505090505b509450610727565b8587516106d59190611050565b92508267ffffffffffffffff8111156106f1576106f0610a73565b5b6040519080825280601f01601f1916602001820160405280156107235781602001600182028036833780820191505090505b5094505b8591508167ffffffffffffffff81111561074457610743610a73565b5b6040519080825280601f01601f1916602001820160405280156107765781602001600182028036833780820191505090505b5093505f5f90505b87518110156108a557838110156107f3578781815181106107a2576107a1611023565b5b602001015160f81c60f81b8682815181106107c0576107bf611023565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a905350610898565b87818560018b516108049190611050565b61080e9190610ff0565b6108189190611050565b8151811061082957610828611023565b5b602001015160f81c60f81b8582866001876108449190611050565b61084e9190610ff0565b6108589190611050565b8151811061086957610868611023565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053505b808060010191505061077e565b505050509250929050565b60605f600183516108c19190611050565b90505b5f8111801561093157507f300000000000000000000000000000000000000000000000000000000000000083828151811061090257610901611023565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b15610949578080610941906111cf565b9150506108c4565b5f6001826109579190610ff0565b67ffffffffffffffff8111156109705761096f610a73565b5b6040519080825280601f01601f1916602001820160405280156109a25781602001600182028036833780820191505090505b5090505f5f90505b6001836109b79190610ff0565b811015610a2a578481815181106109d1576109d0611023565b5b602001015160f81c60f81b8282815181106109ef576109ee611023565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a90535080806001019150506109aa565b508092505050919050565b5f60ff82901d60ff83901d8301189050919050565b5f604051905090565b5f5ffd5b5f5ffd5b5f5ffd5b5f5ffd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b610aa982610a63565b810181811067ffffffffffffffff82111715610ac857610ac7610a73565b5b80604052505050565b5f610ada610a4a565b9050610ae68282610aa0565b919050565b5f67ffffffffffffffff821115610b0557610b04610a73565b5b610b0e82610a63565b9050602081019050919050565b828183375f83830152505050565b5f610b3b610b3684610aeb565b610ad1565b905082815260208101848484011115610b5757610b56610a5f565b5b610b62848285610b1b565b509392505050565b5f82601f830112610b7e57610b7d610a5b565b5b8135610b8e848260208601610b29565b91505092915050565b5f819050919050565b610ba981610b97565b8114610bb3575f5ffd5b50565b5f81359050610bc481610ba0565b92915050565b5f5f60408385031215610be057610bdf610a53565b5b5f83013567ffffffffffffffff811115610bfd57610bfc610a57565b5b610c0985828601610b6a565b9250506020610c1a85828601610bb6565b9150509250929050565b5f81519050919050565b5f82825260208201905092915050565b8281835e5f83830152505050565b5f610c5682610c24565b610c608185610c2e565b9350610c70818560208601610c3e565b610c7981610a63565b840191505092915050565b5f6020820190508181035f830152610c9c8184610c4c565b905092915050565b5f67ffffffffffffffff821115610cbe57610cbd610a73565b5b610cc782610a63565b9050602081019050919050565b5f610ce6610ce184610ca4565b610ad1565b905082815260208101848484011115610d0257610d01610a5f565b5b610d0d848285610b1b565b509392505050565b5f82601f830112610d2957610d28610a5b565b5b8135610d39848260208601610cd4565b91505092915050565b5f5f60408385031215610d5857610d57610a53565b5b5f83013567ffffffffffffffff811115610d7557610d74610a57565b5b610d8185828601610d15565b9250506020610d9285828601610bb6565b9150509250929050565b5f81519050919050565b5f82825260208201905092915050565b5f610dc082610d9c565b610dca8185610da6565b9350610dda818560208601610c3e565b610de381610a63565b840191505092915050565b5f6020820190508181035f830152610e068184610db6565b905092915050565b5f60208284031215610e2357610e22610a53565b5b5f82013567ffffffffffffffff811115610e4057610e3f610a57565b5b610e4c84828501610b6a565b91505092915050565b5f60208284031215610e6a57610e69610a53565b5b5f610e7784828501610bb6565b91505092915050565b5f6040820190508181035f830152610e988185610c4c565b90508181036020830152610eac8184610c4c565b90509392505050565b5f60ff82169050919050565b610eca81610eb5565b82525050565b5f602082019050610ee35f830184610ec1565b92915050565b5f819050919050565b610efb81610ee9565b8114610f05575f5ffd5b50565b5f81359050610f1681610ef2565b92915050565b5f60208284031215610f3157610f30610a53565b5b5f610f3e84828501610f08565b91505092915050565b5f6040820190508181035f830152610f5f8185610db6565b90508181036020830152610f738184610db6565b90509392505050565b5f60208284031215610f9157610f90610a53565b5b5f82013567ffffffffffffffff811115610fae57610fad610a57565b5b610fba84828501610d15565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f610ffa82610b97565b915061100583610b97565b925082820190508082111561101d5761101c610fc3565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f61105a82610b97565b915061106583610b97565b925082820390508181111561107d5761107c610fc3565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f6110ba82610b97565b91506110c583610b97565b9250826110d5576110d4611083565b5b828206905092915050565b5f6110ea82610b97565b91506110f583610b97565b92508261110557611104611083565b5b828204905092915050565b5f61111a82610eb5565b915060ff820361112d5761112c610fc3565b5b600182019050919050565b5f81905092915050565b5f61114c82610c24565b6111568185611138565b9350611166818560208601610c3e565b80840191505092915050565b5f81905092915050565b5f61118682610d9c565b6111908185611172565b93506111a0818560208601610c3e565b80840191505092915050565b5f6111b78285611142565b91506111c3828461117c565b91508190509392505050565b5f6111d982610b97565b91505f82036111eb576111ea610fc3565b5b60018203905091905056fea2646970667358221220e7be47584098491653d0d19cc8c594489ce16881490794e9b18447638fcbdf5064736f6c634300081e0033"
            },
            "deployedBytecode": {
              "object": "73000000000000000000000000000000000000000030146080604052600436106100a7575f3560e01c80636f74acfc1161006f5780636f74acfc1461019b5780637b23c90d146101cc578063a322c40e146101fc578063f5d39bab1461022c578063fb85559f1461025d576100a7565b806304eaf90b146100ab5780630efc2a42146100db5780632ed038321461010b5780635a770e1d1461013b5780636900a3ae1461016b575b5f5ffd5b6100c560048036038101906100c09190610bca565b61028d565b6040516100d29190610c84565b60405180910390f35b6100f560048036038101906100f09190610d42565b6102a1565b6040516101029190610dee565b60405180910390f35b61012560048036038101906101209190610e0e565b6103f5565b6040516101329190610c84565b60405180910390f35b61015560048036038101906101509190610e55565b610407565b6040516101629190610dee565b60405180910390f35b61018560048036038101906101809190610e55565b61053f565b6040516101929190610c84565b60405180910390f35b6101b560048036038101906101b09190610bca565b610551565b6040516101c3929190610e80565b60405180910390f35b6101e660048036038101906101e19190610e55565b61057d565b6040516101f39190610ed0565b60405180910390f35b61021660048036038101906102119190610f1c565b6105c6565b6040516102239190610c84565b60405180910390f35b61024660048036038101906102419190610d42565b610652565b604051610254929190610f47565b60405180910390f35b61027760048036038101906102729190610f7c565b6108b0565b6040516102849190610dee565b60405180910390f35b606061029983836102a1565b905092915050565b60605f8284516102b19190610ff0565b67ffffffffffffffff8111156102ca576102c9610a73565b5b6040519080825280601f01601f1916602001820160405280156102fc5781602001600182028036833780820191505090505b5090505f5f90505b81518110156103ea57845181101561037a5784818151811061032957610328611023565b5b602001015160f81c60f81b82828151811061034757610346611023565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053506103dd565b7f30000000000000000000000000000000000000000000000000000000000000008282815181106103ae576103ad611023565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053505b8080600101915050610304565b508091505092915050565b6060610400826108b0565b9050919050565b60605f820361044d576040518060400160405280600181526020017f3000000000000000000000000000000000000000000000000000000000000000815250905061053a565b5f6104578361057d565b60ff1690505f8167ffffffffffffffff81111561047757610476610a73565b5b6040519080825280601f01601f1916602001820160405280156104a95781602001600182028036833780820191505090505b5090505b5f8414610534576001826104c19190611050565b9150600a846104d091906110b0565b60306104dc9190610ff0565b60f81b8183815181106104f2576104f1611023565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a905350600a8461052d91906110e0565b93506104ad565b80925050505b919050565b606061054a82610407565b9050919050565b6060805f8490506060806105658387610652565b80925081935050508194508093505050509250929050565b5f5f820361058e57600190506105c1565b5f5f90505b5f83146105bc5780806105a590611110565b915050600a836105b591906110e0565b9250610593565b809150505b919050565b60605f82126105e35760405180602001604052805f81525061061a565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b61062b61062684610a35565b610407565b60405160200161063c9291906111ac565b6040516020818303038152906040529050919050565b6060805f5f5f86518611156106c8575f92508651866106719190611050565b9050600167ffffffffffffffff81111561068e5761068d610a73565b5b6040519080825280601f01601f1916602001820160405280156106c05781602001600182028036833780820191505090505b509450610727565b8587516106d59190611050565b92508267ffffffffffffffff8111156106f1576106f0610a73565b5b6040519080825280601f01601f1916602001820160405280156107235781602001600182028036833780820191505090505b5094505b8591508167ffffffffffffffff81111561074457610743610a73565b5b6040519080825280601f01601f1916602001820160405280156107765781602001600182028036833780820191505090505b5093505f5f90505b87518110156108a557838110156107f3578781815181106107a2576107a1611023565b5b602001015160f81c60f81b8682815181106107c0576107bf611023565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a905350610898565b87818560018b516108049190611050565b61080e9190610ff0565b6108189190611050565b8151811061082957610828611023565b5b602001015160f81c60f81b8582866001876108449190611050565b61084e9190610ff0565b6108589190611050565b8151811061086957610868611023565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053505b808060010191505061077e565b505050509250929050565b60605f600183516108c19190611050565b90505b5f8111801561093157507f300000000000000000000000000000000000000000000000000000000000000083828151811061090257610901611023565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b15610949578080610941906111cf565b9150506108c4565b5f6001826109579190610ff0565b67ffffffffffffffff8111156109705761096f610a73565b5b6040519080825280601f01601f1916602001820160405280156109a25781602001600182028036833780820191505090505b5090505f5f90505b6001836109b79190610ff0565b811015610a2a578481815181106109d1576109d0611023565b5b602001015160f81c60f81b8282815181106109ef576109ee611023565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a90535080806001019150506109aa565b508092505050919050565b5f60ff82901d60ff83901d8301189050919050565b5f604051905090565b5f5ffd5b5f5ffd5b5f5ffd5b5f5ffd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b610aa982610a63565b810181811067ffffffffffffffff82111715610ac857610ac7610a73565b5b80604052505050565b5f610ada610a4a565b9050610ae68282610aa0565b919050565b5f67ffffffffffffffff821115610b0557610b04610a73565b5b610b0e82610a63565b9050602081019050919050565b828183375f83830152505050565b5f610b3b610b3684610aeb565b610ad1565b905082815260208101848484011115610b5757610b56610a5f565b5b610b62848285610b1b565b509392505050565b5f82601f830112610b7e57610b7d610a5b565b5b8135610b8e848260208601610b29565b91505092915050565b5f819050919050565b610ba981610b97565b8114610bb3575f5ffd5b50565b5f81359050610bc481610ba0565b92915050565b5f5f60408385031215610be057610bdf610a53565b5b5f83013567ffffffffffffffff811115610bfd57610bfc610a57565b5b610c0985828601610b6a565b9250506020610c1a85828601610bb6565b9150509250929050565b5f81519050919050565b5f82825260208201905092915050565b8281835e5f83830152505050565b5f610c5682610c24565b610c608185610c2e565b9350610c70818560208601610c3e565b610c7981610a63565b840191505092915050565b5f6020820190508181035f830152610c9c8184610c4c565b905092915050565b5f67ffffffffffffffff821115610cbe57610cbd610a73565b5b610cc782610a63565b9050602081019050919050565b5f610ce6610ce184610ca4565b610ad1565b905082815260208101848484011115610d0257610d01610a5f565b5b610d0d848285610b1b565b509392505050565b5f82601f830112610d2957610d28610a5b565b5b8135610d39848260208601610cd4565b91505092915050565b5f5f60408385031215610d5857610d57610a53565b5b5f83013567ffffffffffffffff811115610d7557610d74610a57565b5b610d8185828601610d15565b9250506020610d9285828601610bb6565b9150509250929050565b5f81519050919050565b5f82825260208201905092915050565b5f610dc082610d9c565b610dca8185610da6565b9350610dda818560208601610c3e565b610de381610a63565b840191505092915050565b5f6020820190508181035f830152610e068184610db6565b905092915050565b5f60208284031215610e2357610e22610a53565b5b5f82013567ffffffffffffffff811115610e4057610e3f610a57565b5b610e4c84828501610b6a565b91505092915050565b5f60208284031215610e6a57610e69610a53565b5b5f610e7784828501610bb6565b91505092915050565b5f6040820190508181035f830152610e988185610c4c565b90508181036020830152610eac8184610c4c565b90509392505050565b5f60ff82169050919050565b610eca81610eb5565b82525050565b5f602082019050610ee35f830184610ec1565b92915050565b5f819050919050565b610efb81610ee9565b8114610f05575f5ffd5b50565b5f81359050610f1681610ef2565b92915050565b5f60208284031215610f3157610f30610a53565b5b5f610f3e84828501610f08565b91505092915050565b5f6040820190508181035f830152610f5f8185610db6565b90508181036020830152610f738184610db6565b90509392505050565b5f60208284031215610f9157610f90610a53565b5b5f82013567ffffffffffffffff811115610fae57610fad610a57565b5b610fba84828501610d15565b91505092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f610ffa82610b97565b915061100583610b97565b925082820190508082111561101d5761101c610fc3565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f61105a82610b97565b915061106583610b97565b925082820390508181111561107d5761107c610fc3565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f6110ba82610b97565b91506110c583610b97565b9250826110d5576110d4611083565b5b828206905092915050565b5f6110ea82610b97565b91506110f583610b97565b92508261110557611104611083565b5b828204905092915050565b5f61111a82610eb5565b915060ff820361112d5761112c610fc3565b5b600182019050919050565b5f81905092915050565b5f61114c82610c24565b6111568185611138565b9350611166818560208601610c3e565b80840191505092915050565b5f81905092915050565b5f61118682610d9c565b6111908185611172565b93506111a0818560208601610c3e565b80840191505092915050565b5f6111b78285611142565b91506111c3828461117c565b91508190509392505050565b5f6111d982610b97565b91505f82036111eb576111ea610fc3565b5b60018203905091905056fea2646970667358221220e7be47584098491653d0d19cc8c594489ce16881490794e9b18447638fcbdf5064736f6c634300081e0033"
            }
          },
          "userdoc": {
            "kind": "user",
            "methods": {},
            "version": 1
          }
        }
      },
      "/Users/williamcory/cavalre-contracts/node_modules/solady/src/utils/FixedPointMathLib.sol": {
        "FixedPointMathLib": {
          "abi": [
            {
              "inputs": [],
              "name": "DivFailed",
              "type": "error"
            },
            {
              "inputs": [],
              "name": "DivWadFailed",
              "type": "error"
            },
            {
              "inputs": [],
              "name": "ExpOverflow",
              "type": "error"
            },
            {
              "inputs": [],
              "name": "FactorialOverflow",
              "type": "error"
            },
            {
              "inputs": [],
              "name": "FullMulDivFailed",
              "type": "error"
            },
            {
              "inputs": [],
              "name": "LnWadUndefined",
              "type": "error"
            },
            {
              "inputs": [],
              "name": "MantissaOverflow",
              "type": "error"
            },
            {
              "inputs": [],
              "name": "MulDivFailed",
              "type": "error"
            },
            {
              "inputs": [],
              "name": "MulWadFailed",
              "type": "error"
            },
            {
              "inputs": [],
              "name": "OutOfDomain",
              "type": "error"
            },
            {
              "inputs": [],
              "name": "RPowOverflow",
              "type": "error"
            },
            {
              "inputs": [],
              "name": "SDivWadFailed",
              "type": "error"
            },
            {
              "inputs": [],
              "name": "SMulWadFailed",
              "type": "error"
            }
          ],
          "evm": {
            "bytecode": {
              "object": "6055604b600b8282823980515f1a607314603f577f4e487b71000000000000000000000000000000000000000000000000000000005f525f60045260245ffd5b305f52607381538281f3fe730000000000000000000000000000000000000000301460806040525f5ffdfea26469706673582212202e82c4c5997c7d7334d9b44cc375aba74c312f286db81566a8dacbf37ff3968864736f6c634300081e0033"
            },
            "deployedBytecode": {
              "object": "730000000000000000000000000000000000000000301460806040525f5ffdfea26469706673582212202e82c4c5997c7d7334d9b44cc375aba74c312f286db81566a8dacbf37ff3968864736f6c634300081e0033"
            }
          },
          "userdoc": {
            "kind": "user",
            "methods": {},
            "notice": "Arithmetic library with operations for fixed-point numbers.",
            "version": 1
          }
        }
      },
      "/Users/williamcory/cavalre-contracts/playground/contracts/FloatCalculator.s.sol": {
        "FloatCalculator": {
          "abi": [
            {
              "inputs": [],
              "name": "NoSolution",
              "type": "error"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                }
              ],
              "name": "absoluteValue",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "b",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                }
              ],
              "name": "add",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "b",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "c",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "d",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                }
              ],
              "name": "cubicSolve",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "b",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                }
              ],
              "name": "divide",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                }
              ],
              "name": "exponential",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "mantissa",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "exponent",
                  "type": "int256"
                }
              ],
              "name": "fromComponents",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "b",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "c",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                }
              ],
              "name": "fullMulDiv",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "value",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                }
              ],
              "name": "getComponents",
              "outputs": [
                {
                  "internalType": "int256",
                  "name": "mantissa",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "exponent",
                  "type": "int256"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                }
              ],
              "name": "getIntegerPart",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "b",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                }
              ],
              "name": "isEqual",
              "outputs": [
                {
                  "internalType": "bool",
                  "name": "",
                  "type": "bool"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "b",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                }
              ],
              "name": "isGreaterOrEqual",
              "outputs": [
                {
                  "internalType": "bool",
                  "name": "",
                  "type": "bool"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "b",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                }
              ],
              "name": "isGreaterThan",
              "outputs": [
                {
                  "internalType": "bool",
                  "name": "",
                  "type": "bool"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "b",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                }
              ],
              "name": "isLessOrEqual",
              "outputs": [
                {
                  "internalType": "bool",
                  "name": "",
                  "type": "bool"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "b",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                }
              ],
              "name": "isLessThan",
              "outputs": [
                {
                  "internalType": "bool",
                  "name": "",
                  "type": "bool"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "b",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                }
              ],
              "name": "multiply",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                }
              ],
              "name": "naturalLog",
              "outputs": [
                {
                  "internalType": "int256",
                  "name": "",
                  "type": "int256"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                }
              ],
              "name": "negate",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "mantissa",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "exponent",
                  "type": "int256"
                }
              ],
              "name": "normalize",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [],
              "name": "one",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "digits",
                  "type": "uint256"
                }
              ],
              "name": "roundTo",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "internalType": "int256",
                  "name": "places",
                  "type": "int256"
                }
              ],
              "name": "shift",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "a",
                  "type": "int256"
                },
                {
                  "internalType": "int256",
                  "name": "b",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                }
              ],
              "name": "subtract",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [],
              "name": "ten",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [
                {
                  "internalType": "int256",
                  "name": "value",
                  "type": "int256"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                }
              ],
              "name": "toFloatString",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [],
              "name": "two",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "inputs": [],
              "name": "zero",
              "outputs": [
                {
                  "internalType": "string",
                  "name": "",
                  "type": "string"
                }
              ],
              "stateMutability": "pure",
              "type": "function"
            }
          ],
          "evm": {
            "bytecode": {
              "object": "6080604052348015600e575f5ffd5b50613bb18061001c5f395ff3fe608060405234801561000f575f5ffd5b506004361061018c575f3560e01c806379102fa4116100dc578063bc1b392d11610095578063dad234fe1161006f578063dad234fe14610568578063e50ab79914610598578063ecf3f523146105c8578063fcfb9471146105f95761018c565b8063bc1b392d146104ea578063cc375c3d14610508578063cf32087a146105385761018c565b806379102fa4146103dc5780637bf90bbc1461040c5780638ed755bd1461043c578063901717d11461046c57806392c1eb9e1461048a578063a436cea8146104ba5761018c565b80633fb7e161116101495780635fcf9543116101235780635fcf9543146103405780635fdf05d71461037057806363658f821461038e578063643ceff9146103be5761018c565b80633fb7e161146102b057806350f46c17146102e057806353915fef146103105761018c565b80630b44b033146101905780630ff89c2b146101c057806311976261146101f05780631b7e5c19146102205780631e18b7b2146102505780632e293db014610280575b5f5ffd5b6101aa60048036038101906101a59190612eb1565b610629565b6040516101b79190612f1b565b60405180910390f35b6101da60048036038101906101d59190612eb1565b610674565b6040516101e79190612fa4565b60405180910390f35b61020a60048036038101906102059190612fc4565b6106c8565b6040516102179190612fa4565b60405180910390f35b61023a60048036038101906102359190613002565b6106ed565b6040516102479190612fa4565b60405180910390f35b61026a60048036038101906102659190613052565b61072a565b6040516102779190612fa4565b60405180910390f35b61029a60048036038101906102959190612eb1565b610746565b6040516102a79190612f1b565b60405180910390f35b6102ca60048036038101906102c59190612eb1565b610791565b6040516102d79190612f1b565b60405180910390f35b6102fa60048036038101906102f59190612eb1565b6107dc565b6040516103079190612fa4565b60405180910390f35b61032a60048036038101906103259190613090565b610830565b6040516103379190612fa4565b60405180910390f35b61035a60048036038101906103559190612fc4565b61086d565b6040516103679190612fa4565b60405180910390f35b61037861089f565b6040516103859190612fa4565b60405180910390f35b6103a860048036038101906103a39190612eb1565b610903565b6040516103b59190612f1b565b60405180910390f35b6103c661094e565b6040516103d39190612fa4565b60405180910390f35b6103f660048036038101906103f19190612eb1565b6109b1565b6040516104039190612f1b565b60405180910390f35b61042660048036038101906104219190612eb1565b6109fc565b6040516104339190612fa4565b60405180910390f35b610456600480360381019061045191906130e0565b610a50565b6040516104639190612fa4565b60405180910390f35b610474610ab4565b6040516104819190612fa4565b60405180910390f35b6104a4600480360381019061049f9190613052565b610b0c565b6040516104b19190612fa4565b60405180910390f35b6104d460048036038101906104cf9190612eb1565b610b28565b6040516104e19190612fa4565b60405180910390f35b6104f2610b7c565b6040516104ff9190612fa4565b60405180910390f35b610522600480360381019061051d9190612fc4565b610b8c565b60405161052f9190613153565b60405180910390f35b610552600480360381019061054d9190612fc4565b610bb5565b60405161055f9190612fa4565b60405180910390f35b610582600480360381019061057d919061316c565b610be7565b60405161058f9190612fa4565b60405180910390f35b6105b260048036038101906105ad9190612fc4565b610c01565b6040516105bf9190612fa4565b60405180910390f35b6105e260048036038101906105dd9190612fc4565b610c33565b6040516105f0929190613197565b60405180910390f35b610613600480360381019061060e91906130e0565b610c60565b6040516106209190612fa4565b60405180910390f35b5f5f61063e8386610cc490919063ffffffff16565b90505f6106548486610cc490919063ffffffff16565b90506106698183610ce890919063ffffffff16565b925050509392505050565b60605f61068a8386610cc490919063ffffffff16565b90505f6106a08486610cc490919063ffffffff16565b90506106bd6106b88284610d1790919063ffffffff16565b610da6565b925050509392505050565b60606106e56106e08385610cc490919063ffffffff16565b610da6565b905092915050565b60605f6107038486610cc490919063ffffffff16565b905061072061071b8483610f9590919063ffffffff16565b610da6565b9150509392505050565b606061073e61073984846111e2565b610da6565b905092915050565b5f5f61075b8386610cc490919063ffffffff16565b90505f6107718486610cc490919063ffffffff16565b9050610786818361132e90919063ffffffff16565b925050509392505050565b5f5f6107a68386610cc490919063ffffffff16565b90505f6107bc8486610cc490919063ffffffff16565b90506107d1818361135c90919063ffffffff16565b925050509392505050565b60605f6107f28386610cc490919063ffffffff16565b90505f6108088486610cc490919063ffffffff16565b9050610825610820828461138b90919063ffffffff16565b610da6565b925050509392505050565b60605f6108468486610cc490919063ffffffff16565b905061086361085e848361141a90919063ffffffff16565b610da6565b9150509392505050565b60605f6108838385610cc490919063ffffffff16565b9050610896610891826114ff565b610da6565b91505092915050565b60606108fe600160806001901b6108b691906131eb565b600160126108c491906131eb565b600a6108d0919061334d565b60026108dc9190613397565b166080600160126108ed91906131eb565b6108f69061340d565b901b17610da6565b905090565b5f5f6109188386610cc490919063ffffffff16565b90505f61092e8486610cc490919063ffffffff16565b9050610943818361152990919063ffffffff16565b925050509392505050565b60606109ac600160806001901b61096591906131eb565b6001601261097391906131eb565b600a61097f919061334d565b166080600180601261099191906131eb565b61099a9061340d565b6109a49190613453565b901b17610da6565b905090565b5f5f6109c68386610cc490919063ffffffff16565b90505f6109dc8486610cc490919063ffffffff16565b90506109f1818361155790919063ffffffff16565b925050509392505050565b60605f610a128386610cc490919063ffffffff16565b90505f610a288486610cc490919063ffffffff16565b9050610a45610a40828461158590919063ffffffff16565b610da6565b925050509392505050565b60605f610a668387610cc490919063ffffffff16565b90505f610a7c8487610cc490919063ffffffff16565b90505f610a928587610cc490919063ffffffff16565b9050610aa7610aa28484846115cd565b610da6565b9350505050949350505050565b6060610b07600160806001901b610acb91906131eb565b60016012610ad991906131eb565b600a610ae5919061334d565b16608060016012610af691906131eb565b610aff9061340d565b901b17610da6565b905090565b6060610b20610b1b84846119d9565b610da6565b905092915050565b60605f610b3e8386610cc490919063ffffffff16565b90505f610b548486610cc490919063ffffffff16565b9050610b71610b6c8284611b0b90919063ffffffff16565b610da6565b925050509392505050565b6060610b875f610da6565b905090565b5f5f610ba18385610cc490919063ffffffff16565b9050610bac81611b53565b91505092915050565b60605f610bcb8385610cc490919063ffffffff16565b9050610bde610bd982611bab565b610da6565b91505092915050565b6060610bfa610bf583611c31565b610da6565b9050919050565b60605f610c178385610cc490919063ffffffff16565b9050610c2a610c2582611c92565b610da6565b91505092915050565b5f5f5f610c498486610cc490919063ffffffff16565b9050610c5481611cbd565b92509250509250929050565b60605f610c768387610cc490919063ffffffff16565b90505f610c8c8487610cc490919063ffffffff16565b90505f610ca28587610cc490919063ffffffff16565b9050610cb7610cb2848484611cd9565b610da6565b9350505050949350505050565b5f610ce083610cd284611e54565b610cdb9061340d565b6111e2565b905092915050565b5f5f5f610cf58585611ec0565b91509150610d028161203f565b610d0b8361203f565b12159250505092915050565b5f5f610d228461204b565b90505f610d2e8461204b565b9050610d9c610d3c8261203f565b6012600a610d4a919061334d565b610d538561203f565b610d5d9190613397565b610d6791906134c1565b610d716012611e54565b610d7a8461206e565b610d838661206e565b610d8d9190613529565b610d979190613529565b6111e2565b9250505092915050565b6060806060610db48461204b565b93505f610dda60016012600a610dca919061334d565b610dd491906131eb565b5f6111e2565b90505f60016012610deb91906131eb565b90505f8190505f5f610dfc89611cbd565b91509150610e1b85610e0d8b6114ff565b61152990919063ffffffff16565b8015610e30575082610e2c9061340d565b8112155b15610ed157610e3e8961207e565b80975081985050505f8212610e615760405180602001604052805f815250610e98565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b87610ea288612512565b604051602001610eb4939291906135ed565b604051602081830303815290604052975050505050505050610f90565b610eec610ee78385610ee29061340d565b6111e2565b61207e565b80975081985050505f8212610f0f5760405180602001604052805f815250610f46565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b87610f5088612512565b610f648685610f5f9190613453565b612697565b604051602001610f779493929190613672565b6040516020818303038152906040529750505050505050505b919050565b5f5f610fa08461203f565b90505f831480610faf57505f81145b15610fbd57839150506111dc565b5f5f8413610fd45783610fcf9061340d565b610fd6565b835b90505f8290505f85610fe78861206e565b610ff19190613453565b90505f8613156110c3575b6010831061102d57662386f26fc100008261101791906134c1565b915060108361102691906131eb565b9250610ffc565b60088310611057576305f5e1008261104591906134c1565b915060088361105491906131eb565b92505b6004831061107f576127108261106d91906134c1565b915060048361107c91906131eb565b92505b600283106110a65760648261109491906134c1565b91506002836110a391906131eb565b92505b600183106110be57600a826110bb91906134c1565b91505b6111cb565b6012831115611107576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016110fe9061370f565b60405180910390fd5b5b6010831061113957662386f26fc10000826111239190613397565b915060108361113291906131eb565b9250611108565b60088310611163576305f5e100826111519190613397565b915060088361116091906131eb565b92505b6004831061118b57612710826111799190613397565b915060048361118891906131eb565b92505b600283106111b2576064826111a09190613397565b91506002836111af91906131eb565b92505b600183106111ca57600a826111c79190613397565b91505b5b6111d582826119d9565b9450505050505b92915050565b5f5f83036111f2575f9050611328565b5f8390505f8390505f61120483612723565b905060016012600a611216919061334d565b61122091906131eb565b81111561128f575b60016012600a611238919061334d565b61124291906131eb565b81111561127b57600a8361125691906134c1565b92506001826112659190613453565b9150600a81611274919061372d565b9050611228565b61128583836119d9565b9350505050611328565b6001601261129d91906131eb565b600a6112a9919061334d565b811015611318575b600160126112bf91906131eb565b600a6112cb919061334d565b81101561130457600a836112df9190613397565b92506001826112ee9190613529565b9150600a816112fd919061375d565b90506112b1565b61130e83836119d9565b9350505050611328565b61132283836119d9565b93505050505b92915050565b5f5f5f61133b8585611ec0565b915091506113488161203f565b6113518361203f565b139250505092915050565b5f5f5f6113698585611ec0565b915091506113768161203f565b61137f8361203f565b13159250505092915050565b5f5f6113968461204b565b90505f6113a28461204b565b90506114106012600a6113b5919061334d565b6113be8361203f565b6113c78561203f565b6113d19190613397565b6113db91906134c1565b6113e48361206e565b6113ed8561206e565b6113f76012611e54565b6114019190613453565b61140b9190613453565b6111e2565b9250505092915050565b5f5f6114258461203f565b03611432575f90506114f9565b5f61143c8461204b565b90505f83601261144c91906131eb565b600a611458919061334d565b90505f816114658461203f565b61146f91906134c1565b90505f8261147c8561203f565b611486919061379e565b9050826002826114969190613397565b126114aa5781806114a6906137ce565b9250505b826114b49061340d565b6002826114c19190613397565b136114d55781806114d190613815565b9250505b6114f283836114e49190613397565b6114ed8661206e565b6119d9565b9450505050505b92915050565b5f61152261151461150f8461203f565b612740565b61151d8461206e565b6119d9565b9050919050565b5f5f5f6115368585611ec0565b915091506115438161203f565b61154c8361203f565b129250505092915050565b5f5f5f6115648585611ec0565b915091506115718161203f565b61157a8361203f565b149250505092915050565b5f5f5f6115928585611ec0565b915091506115c36115a28261203f565b6115ab8461203f565b6115b59190613453565b6115be8461206e565b6111e2565b9250505092915050565b5f6115d6612e1d565b611646846116416115e7888961138b565b600160806001901b6115f991906131eb565b6001601261160791906131eb565b600a611613919061334d565b600361161f9190613397565b1660806001601261163091906131eb565b6116399061340d565b901b17610d17565b611b0b565b815f0181815250506116e96116a08461169b61166b896116668b8c61138b565b61138b565b61169660877fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6119d9565b610d17565b611585565b6116e46116ad888861138b565b6116df670429d069189e00007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffef6119d9565b610d17565b611b0b565b81602001818152505061179861176461170a8360200151846020015161138b565b600160806001901b61171c91906131eb565b6001601261172a91906131eb565b600a611736919061334d565b60046117429190613397565b1660806001601261175391906131eb565b61175c9061340d565b901b17610d17565b611793611783845f015161177e865f0151875f015161138b565b61138b565b61178e601b5f6119d9565b610d17565b611585565b8160400181815250506117af81604001515f611529565b156117e6576040517f4578c21400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61187161180a60026117fb8460400151611b53565b61180591906134c1565b611c31565b61186c8360200151600160806001901b61182491906131eb565b6001601261183291906131eb565b600a61183e919061334d565b600261184a9190613397565b1660806001601261185b91906131eb565b6118649061340d565b901b17610d17565b611b0b565b8160600181815250505f611888826060015161203f565b136118c3576118be6118b960036118aa6118a58560600151611c92565b611b53565b6118b491906134c1565b611c31565b611c92565b6118e5565b6118e460036118d58360600151611b53565b6118df91906134c1565b611c31565b5b8160800181815250506119cf61196c8260800151611967845f0151611962600160806001901b61191591906131eb565b6001601261192391906131eb565b600a61192f919061334d565b600361193b9190613397565b1660806001601261194c91906131eb565b6119559061340d565b901b17876080015161138b565b610d17565b611b0b565b6119ca87600160806001901b61198291906131eb565b6001601261199091906131eb565b600a61199c919061334d565b60036119a89190613397565b166080600160126119b991906131eb565b6119c29061340d565b901b17610d17565b611b0b565b9150509392505050565b5f7fffffffffffffffffffffffffffffffff80000000000000000000000000000000600f0b8312158015611a2057506f7fffffffffffffffffffffffffffffff600f0b8313155b611a5f576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611a56906138a6565b60405180910390fd5b7fffffffffffffffffffffffffffffffff80000000000000000000000000000000600f0b8212158015611aa557506f7fffffffffffffffffffffffffffffff600f0b8213155b611ae4576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611adb9061390e565b60405180910390fd5b5f600160806001901b611af791906131eb565b8416608084901b1790508091505092915050565b5f5f5f611b188585611ec0565b91509150611b49611b288261203f565b611b318461203f565b611b3b9190613529565b611b448461206e565b6111e2565b9250505092915050565b5f5f611b5e8361204b565b9050671ff46cf1450516f46012611b748361206e565b611b7e9190613453565b611b889190613397565b611b99611b948361203f565b612755565b611ba39190613453565b915050919050565b5f5f5f611bb784611cbd565b915091505f811215611c26575f8290505f5b611bdb83611bd69061340d565b6129ae565b811015611c1157600a82611bef91906134c1565b91505f8203611c04575f945050505050611c2c565b8080600101915050611bc9565b50611c1c815f6119d9565b9350505050611c2c565b83925050505b919050565b5f5f671ff46cf1450516f483611c4791906134c1565b90505f671ff46cf1450516f482611c5e9190613397565b84611c699190613529565b9050611c89611c77826129fa565b601284611c849190613529565b6111e2565b92505050919050565b5f611cb6611c9f8361203f565b611ca89061340d565b611cb18461206e565b6119d9565b9050919050565b5f5f5f83905080600f0b9250608081901d600f0b915050915091565b5f5f600190505f611ce98661203f565b1215611d1e577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81611d1b9190613397565b90505b5f611d288561203f565b1215611d5d577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81611d5a9190613397565b90505b5f611d678461203f565b1215611d9c577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81611d999190613397565b90505b5f611da68661204b565b90505f611db28661204b565b90505f611dbe8661204b565b9050611e47611e08611dd7611dd28561203f565b612740565b611de8611de38561203f565b612740565b611df9611df48861203f565b612740565b612be49092919063ffffffff16565b85611e139190613397565b611e1c8361206e565b611e258561206e565b611e2e8761206e565b611e389190613453565b611e429190613529565b6111e2565b9450505050509392505050565b5f7f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821115611eb8576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611eaf90613976565b60405180910390fd5b819050919050565b5f5f5f5f611ecd86611cbd565b915091505f5f611edc87611cbd565b915091505f84148015611eee57505f82145b15611f02575f5f9550955050505050612038565b5f8403611f2a57611f135f826119d9565b611f1d83836119d9565b9550955050505050612038565b5f8203611f5257611f3b84846119d9565b611f455f856119d9565b9550955050505050612038565b5f611f5c8961204b565b90505f611f688961204b565b9050611f738261203f565b9550611f7e8261206e565b9450611f898161203f565b9350611f948161206e565b92505f8386611fa39190613529565b90505f8112611feb576012811115611fd05782611fc05f886119d9565b9850985050505050505050612038565b82611fdb8383610f95565b9850985050505050505050612038565b601281611ff79061340d565b1115612018576120075f856119d9565b829850985050505050505050612038565b61202b83826120269061340d565b610f95565b8298509850505050505050505b9250929050565b5f81600f0b9050919050565b5f5f5f61205784611cbd565b9150915061206582826111e2565b92505050919050565b5f608082901d600f0b9050919050565b6060805f61208b84611cbd565b5090505f810361210b576040518060400160405280600181526020017f30000000000000000000000000000000000000000000000000000000000000008152506040518060400160405280600181526020017f3000000000000000000000000000000000000000000000000000000000000000815250925092505061250d565b5f61211585611bab565b905060605f5f61212484611cbd565b915091505f820361216c576040518060400160405280600181526020017f300000000000000000000000000000000000000000000000000000000000000081525092506122d9565b5f61218e5f84121561218757836121829061340d565b612189565b835b612c9c565b905081815161219d9190613994565b67ffffffffffffffff8111156121b6576121b56139c7565b5b6040519080825280601f01601f1916602001820160405280156121e85781602001600182028036833780820191505090505b5093505f5f90505b84518110156122d657815181101561226657818181518110612215576122146139f4565b5b602001015160f81c60f81b858281518110612233576122326139f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053506122c9565b7f300000000000000000000000000000000000000000000000000000000000000085828151811061229a576122996139f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053505b80806001019150506121f0565b50505b5f5f83036122e9578890506122f6565b6122f38986611b0b565b90505b60605f5f61230384611cbd565b915091505f820361234b576040518060400160405280600181526020017f300000000000000000000000000000000000000000000000000000000000000081525092506124fd565b5f61236d5f84121561236657836123619061340d565b612368565b835b612c9c565b9050816123799061340d565b67ffffffffffffffff811115612392576123916139c7565b5b6040519080825280601f01601f1916602001820160405280156123c45781602001600182028036833780820191505090505b5093505f5f90505b84518110156124fa578151811015612472578181600184516123ee91906131eb565b6123f891906131eb565b81518110612409576124086139f4565b5b602001015160f81c60f81b85826001885161242491906131eb565b61242e91906131eb565b8151811061243f5761243e6139f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053506124ed565b7f30000000000000000000000000000000000000000000000000000000000000008582600188516124a391906131eb565b6124ad91906131eb565b815181106124be576124bd6139f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053505b80806001019150506123cc565b50505b86839a509a505050505050505050505b915091565b60605f6001835161252391906131eb565b90505b5f8111801561259357507f3000000000000000000000000000000000000000000000000000000000000000838281518110612564576125636139f4565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b156125ab5780806125a390613a21565b915050612526565b5f6001826125b99190613994565b67ffffffffffffffff8111156125d2576125d16139c7565b5b6040519080825280601f01601f1916602001820160405280156126045781602001600182028036833780820191505090505b5090505f5f90505b6001836126199190613994565b81101561268c57848181518110612633576126326139f4565b5b602001015160f81c60f81b828281518110612651576126506139f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a905350808060010191505061260c565b508092505050919050565b60605f82126126b45760405180602001604052805f8152506126eb565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b6126fc6126f784612740565b612c9c565b60405160200161270d929190613a8c565b6040516020818303038152906040529050919050565b5f5f82126127335781905061273b565b600182190190505b919050565b5f60ff82901d60ff83901d8301189050919050565b5f816fffffffffffffffffffffffffffffffff1060071b905081811c67ffffffffffffffff1060061b8117905081811c63ffffffff1060051b8117905081811c61ffff1060041b8117905081811c60ff1060031b811790505f82136127c157631615e6385f526004601cfd5b7ff8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff6f8421084210842108cc6318c6db6d54be83831c1c601f161a8118905081811b609f1c91506c8c3f38e95a6b1ff2ab1c3b3437828384856c29508e458543d8aa4df2abee78010260601d6d0139601a2efabe717e604cbb4894010260601d6d02247f7a7b6594320649aa03aba1010260601d036d02384773bdf1ac5676facced609183820260601d0390506cb9a025d814b29c212b8b1a07ce83820260601d0390506c0a09507084cc699bb0e71ea86a60601b838202039050826c465772b2bbbb5f824b15207a300180840260601d6d0388eaa27412d5aca026815d636e01905080840260601d6d0df99ac502031bf953eff472fdcc01905080840260601d6d13cdffb29d51d99322bdff5f221101905080840260601d6d0a0f742023def783a307a986912e01905080840260601d6d01920d8043ca89b5239253284e4201905080840260601d6c0b7a86d7375468fac667a0a527019050808205915081711340daa0d5f769dba1915cef59f0815a55060291508183609f037d0267a36c0c95b3975ab3ee5b203a7614a3f75373f047d803ae7b6687f2b302019150817d57115e47018c7177eebf7cd370a3356a1b7863008a5ae8028c72b88642840191508160ae1d92505050919050565b5f5f8212156129f2576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016129e990613af9565b60405180910390fd5b819050919050565b5f7ffffffffffffffffffffffffffffffffffffffffffffffffdc0d0570925a462d7821315612bdf57680755bf798b4a1bf1e58212612a405763a37bfec95f526004601cfd5b6503782dace9d9604e83901b81612a5a57612a59613494565b5b0591505f60606b8000000000000000000000006bb17217f7d1cf79abc9e3b398606086901b81612a8d57612a8c613494565b5b0501901d90506bb17217f7d1cf79abc9e3b3988102830392505f6c10fe68e7fd37d0007b713f7650840190506d02d16720577bd19bf614176fe9ea6060858302901d0190505f6d04a4fd9f2a8b96949216d2255a6c8583010390506e0587f503bb6ea29d25fcb7401964506060838302901d01905079d835ebba824c98fb31b83b2ca45c0000000000000000000000008582020190505f6c240c330e9fb2d9cbaf0fd5aafc860390506d0277594991cfc85f6e2461837cd96060878302901d0190506d1a521255e34f6a5061b25ef1c9c46060878302901d0390506db1bbb201f443cf962f1a1d3db4a56060878302901d0190506e02c72388d9f74f51a9331fed693f156060878302901d0390506e05180bb14799ab47a8a8cb2a527d576060878302901d01905080820594508360c30374029d9dc38563c32e5c2f6dc192ee70ef65f9978af38602901c9450505050505b919050565b5f8284029050600115612c955781838583041485151702612c8f575f198385098181108201810383858709845f038516828611612c285763ae47f7025f526004601cfd5b808604955085600302600218808702600203810290508087026002038102905080870260020381029050808702600203810290508087026002038102905080818802600203028284880304600184855f030401888611870302170295505050505050612c95565b81810490505b9392505050565b60605f8203612ce2576040518060400160405280600181526020017f30000000000000000000000000000000000000000000000000000000000000008152509050612dcf565b5f612cec83612dd4565b60ff1690505f8167ffffffffffffffff811115612d0c57612d0b6139c7565b5b6040519080825280601f01601f191660200182016040528015612d3e5781602001600182028036833780820191505090505b5090505b5f8414612dc957600182612d5691906131eb565b9150600a84612d659190613b17565b6030612d719190613994565b60f81b818381518110612d8757612d866139f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a905350600a84612dc2919061372d565b9350612d42565b80925050505b919050565b5f5f8203612de55760019050612e18565b5f5f90505b5f8314612e13578080612dfc90613b53565b915050600a83612e0c919061372d565b9250612dea565b809150505b919050565b6040518060a001604052805f81526020015f81526020015f81526020015f81526020015f81525090565b5f5ffd5b5f819050919050565b612e5d81612e4b565b8114612e67575f5ffd5b50565b5f81359050612e7881612e54565b92915050565b5f819050919050565b612e9081612e7e565b8114612e9a575f5ffd5b50565b5f81359050612eab81612e87565b92915050565b5f5f5f60608486031215612ec857612ec7612e47565b5b5f612ed586828701612e6a565b9350506020612ee686828701612e6a565b9250506040612ef786828701612e9d565b9150509250925092565b5f8115159050919050565b612f1581612f01565b82525050565b5f602082019050612f2e5f830184612f0c565b92915050565b5f81519050919050565b5f82825260208201905092915050565b8281835e5f83830152505050565b5f601f19601f8301169050919050565b5f612f7682612f34565b612f808185612f3e565b9350612f90818560208601612f4e565b612f9981612f5c565b840191505092915050565b5f6020820190508181035f830152612fbc8184612f6c565b905092915050565b5f5f60408385031215612fda57612fd9612e47565b5b5f612fe785828601612e6a565b9250506020612ff885828601612e9d565b9150509250929050565b5f5f5f6060848603121561301957613018612e47565b5b5f61302686828701612e6a565b935050602061303786828701612e9d565b925050604061304886828701612e6a565b9150509250925092565b5f5f6040838503121561306857613067612e47565b5b5f61307585828601612e6a565b925050602061308685828601612e6a565b9150509250929050565b5f5f5f606084860312156130a7576130a6612e47565b5b5f6130b486828701612e6a565b93505060206130c586828701612e9d565b92505060406130d686828701612e9d565b9150509250925092565b5f5f5f5f608085870312156130f8576130f7612e47565b5b5f61310587828801612e6a565b945050602061311687828801612e6a565b935050604061312787828801612e6a565b925050606061313887828801612e9d565b91505092959194509250565b61314d81612e4b565b82525050565b5f6020820190506131665f830184613144565b92915050565b5f6020828403121561318157613180612e47565b5b5f61318e84828501612e6a565b91505092915050565b5f6040820190506131aa5f830185613144565b6131b76020830184613144565b9392505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f6131f582612e7e565b915061320083612e7e565b9250828203905081811115613218576132176131be565b5b92915050565b5f8160011c9050919050565b5f5f8291508390505b60018511156132735780860481111561324f5761324e6131be565b5b600185161561325e5780820291505b808102905061326c8561321e565b9450613233565b94509492505050565b5f8261328b5760019050613346565b81613298575f9050613346565b81600181146132ae57600281146132b8576132e7565b6001915050613346565b60ff8411156132ca576132c96131be565b5b8360020a9150848211156132e1576132e06131be565b5b50613346565b5060208310610133831016604e8410600b841016171561331c5782820a905083811115613317576133166131be565b5b613346565b613329848484600161322a565b925090508184048111156133405761333f6131be565b5b81810290505b9392505050565b5f61335782612e7e565b915061336283612e7e565b925061338f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff848461327c565b905092915050565b5f6133a182612e4b565b91506133ac83612e4b565b92508282026133ba81612e4b565b91507f800000000000000000000000000000000000000000000000000000000000000084145f841216156133f1576133f06131be565b5b8282058414831517613406576134056131be565b5b5092915050565b5f61341782612e4b565b91507f80000000000000000000000000000000000000000000000000000000000000008203613449576134486131be565b5b815f039050919050565b5f61345d82612e4b565b915061346883612e4b565b92508282019050828112155f8312168382125f84121516171561348e5761348d6131be565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f6134cb82612e4b565b91506134d683612e4b565b9250826134e6576134e5613494565b5b60015f0383147f80000000000000000000000000000000000000000000000000000000000000008314161561351e5761351d6131be565b5b828205905092915050565b5f61353382612e4b565b915061353e83612e4b565b925082820390508181125f8412168282135f851215161715613563576135626131be565b5b92915050565b5f81905092915050565b5f61357d82612f34565b6135878185613569565b9350613597818560208601612f4e565b80840191505092915050565b7f2e000000000000000000000000000000000000000000000000000000000000005f82015250565b5f6135d7600183613569565b91506135e2826135a3565b600182019050919050565b5f6135f88286613573565b91506136048285613573565b915061360f826135cb565b915061361b8284613573565b9150819050949350505050565b7f65000000000000000000000000000000000000000000000000000000000000005f82015250565b5f61365c600183613569565b915061366782613628565b600182019050919050565b5f61367d8287613573565b91506136898286613573565b9150613694826135cb565b91506136a08285613573565b91506136ab82613650565b91506136b78284613573565b915081905095945050505050565b7f73686966743a207c697c20746f6f206c617267650000000000000000000000005f82015250565b5f6136f9601483612f3e565b9150613704826136c5565b602082019050919050565b5f6020820190508181035f830152613726816136ed565b9050919050565b5f61373782612e7e565b915061374283612e7e565b92508261375257613751613494565b5b828204905092915050565b5f61376782612e7e565b915061377283612e7e565b925082820261378081612e7e565b91508282048414831517613797576137966131be565b5b5092915050565b5f6137a882612e4b565b91506137b383612e4b565b9250826137c3576137c2613494565b5b828207905092915050565b5f6137d882612e4b565b91507f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361380a576138096131be565b5b600182019050919050565b5f61381f82612e4b565b91507f80000000000000000000000000000000000000000000000000000000000000008203613851576138506131be565b5b600182039050919050565b7f4d616e7469737361206f766572666c6f770000000000000000000000000000005f82015250565b5f613890601183612f3e565b915061389b8261385c565b602082019050919050565b5f6020820190508181035f8301526138bd81613884565b9050919050565b7f4578706f6e656e74206f766572666c6f770000000000000000000000000000005f82015250565b5f6138f8601183612f3e565b9150613903826138c4565b602082019050919050565b5f6020820190508181035f830152613925816138ec565b9050919050565b7f56616c7565206f7574206f6620696e743235362072616e6765000000000000005f82015250565b5f613960601983612f3e565b915061396b8261392c565b602082019050919050565b5f6020820190508181035f83015261398d81613954565b9050919050565b5f61399e82612e7e565b91506139a983612e7e565b92508282019050808211156139c1576139c06131be565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f613a2b82612e7e565b91505f8203613a3d57613a3c6131be565b5b600182039050919050565b5f81519050919050565b5f81905092915050565b5f613a6682613a48565b613a708185613a52565b9350613a80818560208601612f4e565b80840191505092915050565b5f613a978285613573565b9150613aa38284613a5c565b91508190509392505050565b7f56616c7565206d757374206265206e6f6e2d6e656761746976650000000000005f82015250565b5f613ae3601a83612f3e565b9150613aee82613aaf565b602082019050919050565b5f6020820190508181035f830152613b1081613ad7565b9050919050565b5f613b2182612e7e565b9150613b2c83612e7e565b925082613b3c57613b3b613494565b5b828206905092915050565b5f60ff82169050919050565b5f613b5d82613b47565b915060ff8203613b7057613b6f6131be565b5b60018201905091905056fea26469706673582212209573e0249f0829e00655b3519e9c29531393724344f8f9fe64f26c1a6a2f02a464736f6c634300081e0033"
            },
            "deployedBytecode": {
              "object": "608060405234801561000f575f5ffd5b506004361061018c575f3560e01c806379102fa4116100dc578063bc1b392d11610095578063dad234fe1161006f578063dad234fe14610568578063e50ab79914610598578063ecf3f523146105c8578063fcfb9471146105f95761018c565b8063bc1b392d146104ea578063cc375c3d14610508578063cf32087a146105385761018c565b806379102fa4146103dc5780637bf90bbc1461040c5780638ed755bd1461043c578063901717d11461046c57806392c1eb9e1461048a578063a436cea8146104ba5761018c565b80633fb7e161116101495780635fcf9543116101235780635fcf9543146103405780635fdf05d71461037057806363658f821461038e578063643ceff9146103be5761018c565b80633fb7e161146102b057806350f46c17146102e057806353915fef146103105761018c565b80630b44b033146101905780630ff89c2b146101c057806311976261146101f05780631b7e5c19146102205780631e18b7b2146102505780632e293db014610280575b5f5ffd5b6101aa60048036038101906101a59190612eb1565b610629565b6040516101b79190612f1b565b60405180910390f35b6101da60048036038101906101d59190612eb1565b610674565b6040516101e79190612fa4565b60405180910390f35b61020a60048036038101906102059190612fc4565b6106c8565b6040516102179190612fa4565b60405180910390f35b61023a60048036038101906102359190613002565b6106ed565b6040516102479190612fa4565b60405180910390f35b61026a60048036038101906102659190613052565b61072a565b6040516102779190612fa4565b60405180910390f35b61029a60048036038101906102959190612eb1565b610746565b6040516102a79190612f1b565b60405180910390f35b6102ca60048036038101906102c59190612eb1565b610791565b6040516102d79190612f1b565b60405180910390f35b6102fa60048036038101906102f59190612eb1565b6107dc565b6040516103079190612fa4565b60405180910390f35b61032a60048036038101906103259190613090565b610830565b6040516103379190612fa4565b60405180910390f35b61035a60048036038101906103559190612fc4565b61086d565b6040516103679190612fa4565b60405180910390f35b61037861089f565b6040516103859190612fa4565b60405180910390f35b6103a860048036038101906103a39190612eb1565b610903565b6040516103b59190612f1b565b60405180910390f35b6103c661094e565b6040516103d39190612fa4565b60405180910390f35b6103f660048036038101906103f19190612eb1565b6109b1565b6040516104039190612f1b565b60405180910390f35b61042660048036038101906104219190612eb1565b6109fc565b6040516104339190612fa4565b60405180910390f35b610456600480360381019061045191906130e0565b610a50565b6040516104639190612fa4565b60405180910390f35b610474610ab4565b6040516104819190612fa4565b60405180910390f35b6104a4600480360381019061049f9190613052565b610b0c565b6040516104b19190612fa4565b60405180910390f35b6104d460048036038101906104cf9190612eb1565b610b28565b6040516104e19190612fa4565b60405180910390f35b6104f2610b7c565b6040516104ff9190612fa4565b60405180910390f35b610522600480360381019061051d9190612fc4565b610b8c565b60405161052f9190613153565b60405180910390f35b610552600480360381019061054d9190612fc4565b610bb5565b60405161055f9190612fa4565b60405180910390f35b610582600480360381019061057d919061316c565b610be7565b60405161058f9190612fa4565b60405180910390f35b6105b260048036038101906105ad9190612fc4565b610c01565b6040516105bf9190612fa4565b60405180910390f35b6105e260048036038101906105dd9190612fc4565b610c33565b6040516105f0929190613197565b60405180910390f35b610613600480360381019061060e91906130e0565b610c60565b6040516106209190612fa4565b60405180910390f35b5f5f61063e8386610cc490919063ffffffff16565b90505f6106548486610cc490919063ffffffff16565b90506106698183610ce890919063ffffffff16565b925050509392505050565b60605f61068a8386610cc490919063ffffffff16565b90505f6106a08486610cc490919063ffffffff16565b90506106bd6106b88284610d1790919063ffffffff16565b610da6565b925050509392505050565b60606106e56106e08385610cc490919063ffffffff16565b610da6565b905092915050565b60605f6107038486610cc490919063ffffffff16565b905061072061071b8483610f9590919063ffffffff16565b610da6565b9150509392505050565b606061073e61073984846111e2565b610da6565b905092915050565b5f5f61075b8386610cc490919063ffffffff16565b90505f6107718486610cc490919063ffffffff16565b9050610786818361132e90919063ffffffff16565b925050509392505050565b5f5f6107a68386610cc490919063ffffffff16565b90505f6107bc8486610cc490919063ffffffff16565b90506107d1818361135c90919063ffffffff16565b925050509392505050565b60605f6107f28386610cc490919063ffffffff16565b90505f6108088486610cc490919063ffffffff16565b9050610825610820828461138b90919063ffffffff16565b610da6565b925050509392505050565b60605f6108468486610cc490919063ffffffff16565b905061086361085e848361141a90919063ffffffff16565b610da6565b9150509392505050565b60605f6108838385610cc490919063ffffffff16565b9050610896610891826114ff565b610da6565b91505092915050565b60606108fe600160806001901b6108b691906131eb565b600160126108c491906131eb565b600a6108d0919061334d565b60026108dc9190613397565b166080600160126108ed91906131eb565b6108f69061340d565b901b17610da6565b905090565b5f5f6109188386610cc490919063ffffffff16565b90505f61092e8486610cc490919063ffffffff16565b9050610943818361152990919063ffffffff16565b925050509392505050565b60606109ac600160806001901b61096591906131eb565b6001601261097391906131eb565b600a61097f919061334d565b166080600180601261099191906131eb565b61099a9061340d565b6109a49190613453565b901b17610da6565b905090565b5f5f6109c68386610cc490919063ffffffff16565b90505f6109dc8486610cc490919063ffffffff16565b90506109f1818361155790919063ffffffff16565b925050509392505050565b60605f610a128386610cc490919063ffffffff16565b90505f610a288486610cc490919063ffffffff16565b9050610a45610a40828461158590919063ffffffff16565b610da6565b925050509392505050565b60605f610a668387610cc490919063ffffffff16565b90505f610a7c8487610cc490919063ffffffff16565b90505f610a928587610cc490919063ffffffff16565b9050610aa7610aa28484846115cd565b610da6565b9350505050949350505050565b6060610b07600160806001901b610acb91906131eb565b60016012610ad991906131eb565b600a610ae5919061334d565b16608060016012610af691906131eb565b610aff9061340d565b901b17610da6565b905090565b6060610b20610b1b84846119d9565b610da6565b905092915050565b60605f610b3e8386610cc490919063ffffffff16565b90505f610b548486610cc490919063ffffffff16565b9050610b71610b6c8284611b0b90919063ffffffff16565b610da6565b925050509392505050565b6060610b875f610da6565b905090565b5f5f610ba18385610cc490919063ffffffff16565b9050610bac81611b53565b91505092915050565b60605f610bcb8385610cc490919063ffffffff16565b9050610bde610bd982611bab565b610da6565b91505092915050565b6060610bfa610bf583611c31565b610da6565b9050919050565b60605f610c178385610cc490919063ffffffff16565b9050610c2a610c2582611c92565b610da6565b91505092915050565b5f5f5f610c498486610cc490919063ffffffff16565b9050610c5481611cbd565b92509250509250929050565b60605f610c768387610cc490919063ffffffff16565b90505f610c8c8487610cc490919063ffffffff16565b90505f610ca28587610cc490919063ffffffff16565b9050610cb7610cb2848484611cd9565b610da6565b9350505050949350505050565b5f610ce083610cd284611e54565b610cdb9061340d565b6111e2565b905092915050565b5f5f5f610cf58585611ec0565b91509150610d028161203f565b610d0b8361203f565b12159250505092915050565b5f5f610d228461204b565b90505f610d2e8461204b565b9050610d9c610d3c8261203f565b6012600a610d4a919061334d565b610d538561203f565b610d5d9190613397565b610d6791906134c1565b610d716012611e54565b610d7a8461206e565b610d838661206e565b610d8d9190613529565b610d979190613529565b6111e2565b9250505092915050565b6060806060610db48461204b565b93505f610dda60016012600a610dca919061334d565b610dd491906131eb565b5f6111e2565b90505f60016012610deb91906131eb565b90505f8190505f5f610dfc89611cbd565b91509150610e1b85610e0d8b6114ff565b61152990919063ffffffff16565b8015610e30575082610e2c9061340d565b8112155b15610ed157610e3e8961207e565b80975081985050505f8212610e615760405180602001604052805f815250610e98565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b87610ea288612512565b604051602001610eb4939291906135ed565b604051602081830303815290604052975050505050505050610f90565b610eec610ee78385610ee29061340d565b6111e2565b61207e565b80975081985050505f8212610f0f5760405180602001604052805f815250610f46565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b87610f5088612512565b610f648685610f5f9190613453565b612697565b604051602001610f779493929190613672565b6040516020818303038152906040529750505050505050505b919050565b5f5f610fa08461203f565b90505f831480610faf57505f81145b15610fbd57839150506111dc565b5f5f8413610fd45783610fcf9061340d565b610fd6565b835b90505f8290505f85610fe78861206e565b610ff19190613453565b90505f8613156110c3575b6010831061102d57662386f26fc100008261101791906134c1565b915060108361102691906131eb565b9250610ffc565b60088310611057576305f5e1008261104591906134c1565b915060088361105491906131eb565b92505b6004831061107f576127108261106d91906134c1565b915060048361107c91906131eb565b92505b600283106110a65760648261109491906134c1565b91506002836110a391906131eb565b92505b600183106110be57600a826110bb91906134c1565b91505b6111cb565b6012831115611107576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016110fe9061370f565b60405180910390fd5b5b6010831061113957662386f26fc10000826111239190613397565b915060108361113291906131eb565b9250611108565b60088310611163576305f5e100826111519190613397565b915060088361116091906131eb565b92505b6004831061118b57612710826111799190613397565b915060048361118891906131eb565b92505b600283106111b2576064826111a09190613397565b91506002836111af91906131eb565b92505b600183106111ca57600a826111c79190613397565b91505b5b6111d582826119d9565b9450505050505b92915050565b5f5f83036111f2575f9050611328565b5f8390505f8390505f61120483612723565b905060016012600a611216919061334d565b61122091906131eb565b81111561128f575b60016012600a611238919061334d565b61124291906131eb565b81111561127b57600a8361125691906134c1565b92506001826112659190613453565b9150600a81611274919061372d565b9050611228565b61128583836119d9565b9350505050611328565b6001601261129d91906131eb565b600a6112a9919061334d565b811015611318575b600160126112bf91906131eb565b600a6112cb919061334d565b81101561130457600a836112df9190613397565b92506001826112ee9190613529565b9150600a816112fd919061375d565b90506112b1565b61130e83836119d9565b9350505050611328565b61132283836119d9565b93505050505b92915050565b5f5f5f61133b8585611ec0565b915091506113488161203f565b6113518361203f565b139250505092915050565b5f5f5f6113698585611ec0565b915091506113768161203f565b61137f8361203f565b13159250505092915050565b5f5f6113968461204b565b90505f6113a28461204b565b90506114106012600a6113b5919061334d565b6113be8361203f565b6113c78561203f565b6113d19190613397565b6113db91906134c1565b6113e48361206e565b6113ed8561206e565b6113f76012611e54565b6114019190613453565b61140b9190613453565b6111e2565b9250505092915050565b5f5f6114258461203f565b03611432575f90506114f9565b5f61143c8461204b565b90505f83601261144c91906131eb565b600a611458919061334d565b90505f816114658461203f565b61146f91906134c1565b90505f8261147c8561203f565b611486919061379e565b9050826002826114969190613397565b126114aa5781806114a6906137ce565b9250505b826114b49061340d565b6002826114c19190613397565b136114d55781806114d190613815565b9250505b6114f283836114e49190613397565b6114ed8661206e565b6119d9565b9450505050505b92915050565b5f61152261151461150f8461203f565b612740565b61151d8461206e565b6119d9565b9050919050565b5f5f5f6115368585611ec0565b915091506115438161203f565b61154c8361203f565b129250505092915050565b5f5f5f6115648585611ec0565b915091506115718161203f565b61157a8361203f565b149250505092915050565b5f5f5f6115928585611ec0565b915091506115c36115a28261203f565b6115ab8461203f565b6115b59190613453565b6115be8461206e565b6111e2565b9250505092915050565b5f6115d6612e1d565b611646846116416115e7888961138b565b600160806001901b6115f991906131eb565b6001601261160791906131eb565b600a611613919061334d565b600361161f9190613397565b1660806001601261163091906131eb565b6116399061340d565b901b17610d17565b611b0b565b815f0181815250506116e96116a08461169b61166b896116668b8c61138b565b61138b565b61169660877fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6119d9565b610d17565b611585565b6116e46116ad888861138b565b6116df670429d069189e00007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffef6119d9565b610d17565b611b0b565b81602001818152505061179861176461170a8360200151846020015161138b565b600160806001901b61171c91906131eb565b6001601261172a91906131eb565b600a611736919061334d565b60046117429190613397565b1660806001601261175391906131eb565b61175c9061340d565b901b17610d17565b611793611783845f015161177e865f0151875f015161138b565b61138b565b61178e601b5f6119d9565b610d17565b611585565b8160400181815250506117af81604001515f611529565b156117e6576040517f4578c21400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61187161180a60026117fb8460400151611b53565b61180591906134c1565b611c31565b61186c8360200151600160806001901b61182491906131eb565b6001601261183291906131eb565b600a61183e919061334d565b600261184a9190613397565b1660806001601261185b91906131eb565b6118649061340d565b901b17610d17565b611b0b565b8160600181815250505f611888826060015161203f565b136118c3576118be6118b960036118aa6118a58560600151611c92565b611b53565b6118b491906134c1565b611c31565b611c92565b6118e5565b6118e460036118d58360600151611b53565b6118df91906134c1565b611c31565b5b8160800181815250506119cf61196c8260800151611967845f0151611962600160806001901b61191591906131eb565b6001601261192391906131eb565b600a61192f919061334d565b600361193b9190613397565b1660806001601261194c91906131eb565b6119559061340d565b901b17876080015161138b565b610d17565b611b0b565b6119ca87600160806001901b61198291906131eb565b6001601261199091906131eb565b600a61199c919061334d565b60036119a89190613397565b166080600160126119b991906131eb565b6119c29061340d565b901b17610d17565b611b0b565b9150509392505050565b5f7fffffffffffffffffffffffffffffffff80000000000000000000000000000000600f0b8312158015611a2057506f7fffffffffffffffffffffffffffffff600f0b8313155b611a5f576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611a56906138a6565b60405180910390fd5b7fffffffffffffffffffffffffffffffff80000000000000000000000000000000600f0b8212158015611aa557506f7fffffffffffffffffffffffffffffff600f0b8213155b611ae4576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611adb9061390e565b60405180910390fd5b5f600160806001901b611af791906131eb565b8416608084901b1790508091505092915050565b5f5f5f611b188585611ec0565b91509150611b49611b288261203f565b611b318461203f565b611b3b9190613529565b611b448461206e565b6111e2565b9250505092915050565b5f5f611b5e8361204b565b9050671ff46cf1450516f46012611b748361206e565b611b7e9190613453565b611b889190613397565b611b99611b948361203f565b612755565b611ba39190613453565b915050919050565b5f5f5f611bb784611cbd565b915091505f811215611c26575f8290505f5b611bdb83611bd69061340d565b6129ae565b811015611c1157600a82611bef91906134c1565b91505f8203611c04575f945050505050611c2c565b8080600101915050611bc9565b50611c1c815f6119d9565b9350505050611c2c565b83925050505b919050565b5f5f671ff46cf1450516f483611c4791906134c1565b90505f671ff46cf1450516f482611c5e9190613397565b84611c699190613529565b9050611c89611c77826129fa565b601284611c849190613529565b6111e2565b92505050919050565b5f611cb6611c9f8361203f565b611ca89061340d565b611cb18461206e565b6119d9565b9050919050565b5f5f5f83905080600f0b9250608081901d600f0b915050915091565b5f5f600190505f611ce98661203f565b1215611d1e577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81611d1b9190613397565b90505b5f611d288561203f565b1215611d5d577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81611d5a9190613397565b90505b5f611d678461203f565b1215611d9c577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81611d999190613397565b90505b5f611da68661204b565b90505f611db28661204b565b90505f611dbe8661204b565b9050611e47611e08611dd7611dd28561203f565b612740565b611de8611de38561203f565b612740565b611df9611df48861203f565b612740565b612be49092919063ffffffff16565b85611e139190613397565b611e1c8361206e565b611e258561206e565b611e2e8761206e565b611e389190613453565b611e429190613529565b6111e2565b9450505050509392505050565b5f7f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821115611eb8576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611eaf90613976565b60405180910390fd5b819050919050565b5f5f5f5f611ecd86611cbd565b915091505f5f611edc87611cbd565b915091505f84148015611eee57505f82145b15611f02575f5f9550955050505050612038565b5f8403611f2a57611f135f826119d9565b611f1d83836119d9565b9550955050505050612038565b5f8203611f5257611f3b84846119d9565b611f455f856119d9565b9550955050505050612038565b5f611f5c8961204b565b90505f611f688961204b565b9050611f738261203f565b9550611f7e8261206e565b9450611f898161203f565b9350611f948161206e565b92505f8386611fa39190613529565b90505f8112611feb576012811115611fd05782611fc05f886119d9565b9850985050505050505050612038565b82611fdb8383610f95565b9850985050505050505050612038565b601281611ff79061340d565b1115612018576120075f856119d9565b829850985050505050505050612038565b61202b83826120269061340d565b610f95565b8298509850505050505050505b9250929050565b5f81600f0b9050919050565b5f5f5f61205784611cbd565b9150915061206582826111e2565b92505050919050565b5f608082901d600f0b9050919050565b6060805f61208b84611cbd565b5090505f810361210b576040518060400160405280600181526020017f30000000000000000000000000000000000000000000000000000000000000008152506040518060400160405280600181526020017f3000000000000000000000000000000000000000000000000000000000000000815250925092505061250d565b5f61211585611bab565b905060605f5f61212484611cbd565b915091505f820361216c576040518060400160405280600181526020017f300000000000000000000000000000000000000000000000000000000000000081525092506122d9565b5f61218e5f84121561218757836121829061340d565b612189565b835b612c9c565b905081815161219d9190613994565b67ffffffffffffffff8111156121b6576121b56139c7565b5b6040519080825280601f01601f1916602001820160405280156121e85781602001600182028036833780820191505090505b5093505f5f90505b84518110156122d657815181101561226657818181518110612215576122146139f4565b5b602001015160f81c60f81b858281518110612233576122326139f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053506122c9565b7f300000000000000000000000000000000000000000000000000000000000000085828151811061229a576122996139f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053505b80806001019150506121f0565b50505b5f5f83036122e9578890506122f6565b6122f38986611b0b565b90505b60605f5f61230384611cbd565b915091505f820361234b576040518060400160405280600181526020017f300000000000000000000000000000000000000000000000000000000000000081525092506124fd565b5f61236d5f84121561236657836123619061340d565b612368565b835b612c9c565b9050816123799061340d565b67ffffffffffffffff811115612392576123916139c7565b5b6040519080825280601f01601f1916602001820160405280156123c45781602001600182028036833780820191505090505b5093505f5f90505b84518110156124fa578151811015612472578181600184516123ee91906131eb565b6123f891906131eb565b81518110612409576124086139f4565b5b602001015160f81c60f81b85826001885161242491906131eb565b61242e91906131eb565b8151811061243f5761243e6139f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053506124ed565b7f30000000000000000000000000000000000000000000000000000000000000008582600188516124a391906131eb565b6124ad91906131eb565b815181106124be576124bd6139f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053505b80806001019150506123cc565b50505b86839a509a505050505050505050505b915091565b60605f6001835161252391906131eb565b90505b5f8111801561259357507f3000000000000000000000000000000000000000000000000000000000000000838281518110612564576125636139f4565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b156125ab5780806125a390613a21565b915050612526565b5f6001826125b99190613994565b67ffffffffffffffff8111156125d2576125d16139c7565b5b6040519080825280601f01601f1916602001820160405280156126045781602001600182028036833780820191505090505b5090505f5f90505b6001836126199190613994565b81101561268c57848181518110612633576126326139f4565b5b602001015160f81c60f81b828281518110612651576126506139f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a905350808060010191505061260c565b508092505050919050565b60605f82126126b45760405180602001604052805f8152506126eb565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b6126fc6126f784612740565b612c9c565b60405160200161270d929190613a8c565b6040516020818303038152906040529050919050565b5f5f82126127335781905061273b565b600182190190505b919050565b5f60ff82901d60ff83901d8301189050919050565b5f816fffffffffffffffffffffffffffffffff1060071b905081811c67ffffffffffffffff1060061b8117905081811c63ffffffff1060051b8117905081811c61ffff1060041b8117905081811c60ff1060031b811790505f82136127c157631615e6385f526004601cfd5b7ff8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff6f8421084210842108cc6318c6db6d54be83831c1c601f161a8118905081811b609f1c91506c8c3f38e95a6b1ff2ab1c3b3437828384856c29508e458543d8aa4df2abee78010260601d6d0139601a2efabe717e604cbb4894010260601d6d02247f7a7b6594320649aa03aba1010260601d036d02384773bdf1ac5676facced609183820260601d0390506cb9a025d814b29c212b8b1a07ce83820260601d0390506c0a09507084cc699bb0e71ea86a60601b838202039050826c465772b2bbbb5f824b15207a300180840260601d6d0388eaa27412d5aca026815d636e01905080840260601d6d0df99ac502031bf953eff472fdcc01905080840260601d6d13cdffb29d51d99322bdff5f221101905080840260601d6d0a0f742023def783a307a986912e01905080840260601d6d01920d8043ca89b5239253284e4201905080840260601d6c0b7a86d7375468fac667a0a527019050808205915081711340daa0d5f769dba1915cef59f0815a55060291508183609f037d0267a36c0c95b3975ab3ee5b203a7614a3f75373f047d803ae7b6687f2b302019150817d57115e47018c7177eebf7cd370a3356a1b7863008a5ae8028c72b88642840191508160ae1d92505050919050565b5f5f8212156129f2576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016129e990613af9565b60405180910390fd5b819050919050565b5f7ffffffffffffffffffffffffffffffffffffffffffffffffdc0d0570925a462d7821315612bdf57680755bf798b4a1bf1e58212612a405763a37bfec95f526004601cfd5b6503782dace9d9604e83901b81612a5a57612a59613494565b5b0591505f60606b8000000000000000000000006bb17217f7d1cf79abc9e3b398606086901b81612a8d57612a8c613494565b5b0501901d90506bb17217f7d1cf79abc9e3b3988102830392505f6c10fe68e7fd37d0007b713f7650840190506d02d16720577bd19bf614176fe9ea6060858302901d0190505f6d04a4fd9f2a8b96949216d2255a6c8583010390506e0587f503bb6ea29d25fcb7401964506060838302901d01905079d835ebba824c98fb31b83b2ca45c0000000000000000000000008582020190505f6c240c330e9fb2d9cbaf0fd5aafc860390506d0277594991cfc85f6e2461837cd96060878302901d0190506d1a521255e34f6a5061b25ef1c9c46060878302901d0390506db1bbb201f443cf962f1a1d3db4a56060878302901d0190506e02c72388d9f74f51a9331fed693f156060878302901d0390506e05180bb14799ab47a8a8cb2a527d576060878302901d01905080820594508360c30374029d9dc38563c32e5c2f6dc192ee70ef65f9978af38602901c9450505050505b919050565b5f8284029050600115612c955781838583041485151702612c8f575f198385098181108201810383858709845f038516828611612c285763ae47f7025f526004601cfd5b808604955085600302600218808702600203810290508087026002038102905080870260020381029050808702600203810290508087026002038102905080818802600203028284880304600184855f030401888611870302170295505050505050612c95565b81810490505b9392505050565b60605f8203612ce2576040518060400160405280600181526020017f30000000000000000000000000000000000000000000000000000000000000008152509050612dcf565b5f612cec83612dd4565b60ff1690505f8167ffffffffffffffff811115612d0c57612d0b6139c7565b5b6040519080825280601f01601f191660200182016040528015612d3e5781602001600182028036833780820191505090505b5090505b5f8414612dc957600182612d5691906131eb565b9150600a84612d659190613b17565b6030612d719190613994565b60f81b818381518110612d8757612d866139f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a905350600a84612dc2919061372d565b9350612d42565b80925050505b919050565b5f5f8203612de55760019050612e18565b5f5f90505b5f8314612e13578080612dfc90613b53565b915050600a83612e0c919061372d565b9250612dea565b809150505b919050565b6040518060a001604052805f81526020015f81526020015f81526020015f81526020015f81525090565b5f5ffd5b5f819050919050565b612e5d81612e4b565b8114612e67575f5ffd5b50565b5f81359050612e7881612e54565b92915050565b5f819050919050565b612e9081612e7e565b8114612e9a575f5ffd5b50565b5f81359050612eab81612e87565b92915050565b5f5f5f60608486031215612ec857612ec7612e47565b5b5f612ed586828701612e6a565b9350506020612ee686828701612e6a565b9250506040612ef786828701612e9d565b9150509250925092565b5f8115159050919050565b612f1581612f01565b82525050565b5f602082019050612f2e5f830184612f0c565b92915050565b5f81519050919050565b5f82825260208201905092915050565b8281835e5f83830152505050565b5f601f19601f8301169050919050565b5f612f7682612f34565b612f808185612f3e565b9350612f90818560208601612f4e565b612f9981612f5c565b840191505092915050565b5f6020820190508181035f830152612fbc8184612f6c565b905092915050565b5f5f60408385031215612fda57612fd9612e47565b5b5f612fe785828601612e6a565b9250506020612ff885828601612e9d565b9150509250929050565b5f5f5f6060848603121561301957613018612e47565b5b5f61302686828701612e6a565b935050602061303786828701612e9d565b925050604061304886828701612e6a565b9150509250925092565b5f5f6040838503121561306857613067612e47565b5b5f61307585828601612e6a565b925050602061308685828601612e6a565b9150509250929050565b5f5f5f606084860312156130a7576130a6612e47565b5b5f6130b486828701612e6a565b93505060206130c586828701612e9d565b92505060406130d686828701612e9d565b9150509250925092565b5f5f5f5f608085870312156130f8576130f7612e47565b5b5f61310587828801612e6a565b945050602061311687828801612e6a565b935050604061312787828801612e6a565b925050606061313887828801612e9d565b91505092959194509250565b61314d81612e4b565b82525050565b5f6020820190506131665f830184613144565b92915050565b5f6020828403121561318157613180612e47565b5b5f61318e84828501612e6a565b91505092915050565b5f6040820190506131aa5f830185613144565b6131b76020830184613144565b9392505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f6131f582612e7e565b915061320083612e7e565b9250828203905081811115613218576132176131be565b5b92915050565b5f8160011c9050919050565b5f5f8291508390505b60018511156132735780860481111561324f5761324e6131be565b5b600185161561325e5780820291505b808102905061326c8561321e565b9450613233565b94509492505050565b5f8261328b5760019050613346565b81613298575f9050613346565b81600181146132ae57600281146132b8576132e7565b6001915050613346565b60ff8411156132ca576132c96131be565b5b8360020a9150848211156132e1576132e06131be565b5b50613346565b5060208310610133831016604e8410600b841016171561331c5782820a905083811115613317576133166131be565b5b613346565b613329848484600161322a565b925090508184048111156133405761333f6131be565b5b81810290505b9392505050565b5f61335782612e7e565b915061336283612e7e565b925061338f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff848461327c565b905092915050565b5f6133a182612e4b565b91506133ac83612e4b565b92508282026133ba81612e4b565b91507f800000000000000000000000000000000000000000000000000000000000000084145f841216156133f1576133f06131be565b5b8282058414831517613406576134056131be565b5b5092915050565b5f61341782612e4b565b91507f80000000000000000000000000000000000000000000000000000000000000008203613449576134486131be565b5b815f039050919050565b5f61345d82612e4b565b915061346883612e4b565b92508282019050828112155f8312168382125f84121516171561348e5761348d6131be565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f6134cb82612e4b565b91506134d683612e4b565b9250826134e6576134e5613494565b5b60015f0383147f80000000000000000000000000000000000000000000000000000000000000008314161561351e5761351d6131be565b5b828205905092915050565b5f61353382612e4b565b915061353e83612e4b565b925082820390508181125f8412168282135f851215161715613563576135626131be565b5b92915050565b5f81905092915050565b5f61357d82612f34565b6135878185613569565b9350613597818560208601612f4e565b80840191505092915050565b7f2e000000000000000000000000000000000000000000000000000000000000005f82015250565b5f6135d7600183613569565b91506135e2826135a3565b600182019050919050565b5f6135f88286613573565b91506136048285613573565b915061360f826135cb565b915061361b8284613573565b9150819050949350505050565b7f65000000000000000000000000000000000000000000000000000000000000005f82015250565b5f61365c600183613569565b915061366782613628565b600182019050919050565b5f61367d8287613573565b91506136898286613573565b9150613694826135cb565b91506136a08285613573565b91506136ab82613650565b91506136b78284613573565b915081905095945050505050565b7f73686966743a207c697c20746f6f206c617267650000000000000000000000005f82015250565b5f6136f9601483612f3e565b9150613704826136c5565b602082019050919050565b5f6020820190508181035f830152613726816136ed565b9050919050565b5f61373782612e7e565b915061374283612e7e565b92508261375257613751613494565b5b828204905092915050565b5f61376782612e7e565b915061377283612e7e565b925082820261378081612e7e565b91508282048414831517613797576137966131be565b5b5092915050565b5f6137a882612e4b565b91506137b383612e4b565b9250826137c3576137c2613494565b5b828207905092915050565b5f6137d882612e4b565b91507f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361380a576138096131be565b5b600182019050919050565b5f61381f82612e4b565b91507f80000000000000000000000000000000000000000000000000000000000000008203613851576138506131be565b5b600182039050919050565b7f4d616e7469737361206f766572666c6f770000000000000000000000000000005f82015250565b5f613890601183612f3e565b915061389b8261385c565b602082019050919050565b5f6020820190508181035f8301526138bd81613884565b9050919050565b7f4578706f6e656e74206f766572666c6f770000000000000000000000000000005f82015250565b5f6138f8601183612f3e565b9150613903826138c4565b602082019050919050565b5f6020820190508181035f830152613925816138ec565b9050919050565b7f56616c7565206f7574206f6620696e743235362072616e6765000000000000005f82015250565b5f613960601983612f3e565b915061396b8261392c565b602082019050919050565b5f6020820190508181035f83015261398d81613954565b9050919050565b5f61399e82612e7e565b91506139a983612e7e565b92508282019050808211156139c1576139c06131be565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f613a2b82612e7e565b91505f8203613a3d57613a3c6131be565b5b600182039050919050565b5f81519050919050565b5f81905092915050565b5f613a6682613a48565b613a708185613a52565b9350613a80818560208601612f4e565b80840191505092915050565b5f613a978285613573565b9150613aa38284613a5c565b91508190509392505050565b7f56616c7565206d757374206265206e6f6e2d6e656761746976650000000000005f82015250565b5f613ae3601a83612f3e565b9150613aee82613aaf565b602082019050919050565b5f6020820190508181035f830152613b1081613ad7565b9050919050565b5f613b2182612e7e565b9150613b2c83612e7e565b925082613b3c57613b3b613494565b5b828206905092915050565b5f60ff82169050919050565b5f613b5d82613b47565b915060ff8203613b7057613b6f6131be565b5b60018201905091905056fea26469706673582212209573e0249f0829e00655b3519e9c29531393724344f8f9fe64f26c1a6a2f02a464736f6c634300081e0033"
            }
          },
          "userdoc": {
            "kind": "user",
            "methods": {},
            "version": 1
          }
        }
      }
    },
    "sources": {
      "/Users/williamcory/cavalre-contracts/libraries/FloatLib.sol": {
        "id": 0
      },
      "/Users/williamcory/cavalre-contracts/libraries/FloatStrings.sol": {
        "id": 1
      },
      "/Users/williamcory/cavalre-contracts/node_modules/solady/src/utils/FixedPointMathLib.sol": {
        "id": 2
      },
      "/Users/williamcory/cavalre-contracts/playground/contracts/FloatCalculator.s.sol": {
        "id": 3
      }
    }
  },
  "artifacts": {
    "FloatCalculator": {
      "contractName": "FloatCalculator",
      "abi": [
        {
          "inputs": [],
          "name": "NoSolution",
          "type": "error"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "decimals",
              "type": "uint256"
            }
          ],
          "name": "absoluteValue",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "b",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "decimals",
              "type": "uint256"
            }
          ],
          "name": "add",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "b",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "c",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "d",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "decimals",
              "type": "uint256"
            }
          ],
          "name": "cubicSolve",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "b",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "decimals",
              "type": "uint256"
            }
          ],
          "name": "divide",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            }
          ],
          "name": "exponential",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "mantissa",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "exponent",
              "type": "int256"
            }
          ],
          "name": "fromComponents",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "b",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "c",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "decimals",
              "type": "uint256"
            }
          ],
          "name": "fullMulDiv",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "value",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "decimals",
              "type": "uint256"
            }
          ],
          "name": "getComponents",
          "outputs": [
            {
              "internalType": "int256",
              "name": "mantissa",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "exponent",
              "type": "int256"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "decimals",
              "type": "uint256"
            }
          ],
          "name": "getIntegerPart",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "b",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "decimals",
              "type": "uint256"
            }
          ],
          "name": "isEqual",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "b",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "decimals",
              "type": "uint256"
            }
          ],
          "name": "isGreaterOrEqual",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "b",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "decimals",
              "type": "uint256"
            }
          ],
          "name": "isGreaterThan",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "b",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "decimals",
              "type": "uint256"
            }
          ],
          "name": "isLessOrEqual",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "b",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "decimals",
              "type": "uint256"
            }
          ],
          "name": "isLessThan",
          "outputs": [
            {
              "internalType": "bool",
              "name": "",
              "type": "bool"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "b",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "decimals",
              "type": "uint256"
            }
          ],
          "name": "multiply",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "decimals",
              "type": "uint256"
            }
          ],
          "name": "naturalLog",
          "outputs": [
            {
              "internalType": "int256",
              "name": "",
              "type": "int256"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "decimals",
              "type": "uint256"
            }
          ],
          "name": "negate",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "mantissa",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "exponent",
              "type": "int256"
            }
          ],
          "name": "normalize",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "one",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "decimals",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "digits",
              "type": "uint256"
            }
          ],
          "name": "roundTo",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "decimals",
              "type": "uint256"
            },
            {
              "internalType": "int256",
              "name": "places",
              "type": "int256"
            }
          ],
          "name": "shift",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "a",
              "type": "int256"
            },
            {
              "internalType": "int256",
              "name": "b",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "decimals",
              "type": "uint256"
            }
          ],
          "name": "subtract",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "ten",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "int256",
              "name": "value",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "decimals",
              "type": "uint256"
            }
          ],
          "name": "toFloatString",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "two",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "zero",
          "outputs": [
            {
              "internalType": "string",
              "name": "",
              "type": "string"
            }
          ],
          "stateMutability": "pure",
          "type": "function"
        }
      ],
      "userdoc": {
        "kind": "user",
        "methods": {},
        "version": 1
      },
      "evm": {
        "bytecode": {
          "object": "6080604052348015600e575f5ffd5b50613bb18061001c5f395ff3fe608060405234801561000f575f5ffd5b506004361061018c575f3560e01c806379102fa4116100dc578063bc1b392d11610095578063dad234fe1161006f578063dad234fe14610568578063e50ab79914610598578063ecf3f523146105c8578063fcfb9471146105f95761018c565b8063bc1b392d146104ea578063cc375c3d14610508578063cf32087a146105385761018c565b806379102fa4146103dc5780637bf90bbc1461040c5780638ed755bd1461043c578063901717d11461046c57806392c1eb9e1461048a578063a436cea8146104ba5761018c565b80633fb7e161116101495780635fcf9543116101235780635fcf9543146103405780635fdf05d71461037057806363658f821461038e578063643ceff9146103be5761018c565b80633fb7e161146102b057806350f46c17146102e057806353915fef146103105761018c565b80630b44b033146101905780630ff89c2b146101c057806311976261146101f05780631b7e5c19146102205780631e18b7b2146102505780632e293db014610280575b5f5ffd5b6101aa60048036038101906101a59190612eb1565b610629565b6040516101b79190612f1b565b60405180910390f35b6101da60048036038101906101d59190612eb1565b610674565b6040516101e79190612fa4565b60405180910390f35b61020a60048036038101906102059190612fc4565b6106c8565b6040516102179190612fa4565b60405180910390f35b61023a60048036038101906102359190613002565b6106ed565b6040516102479190612fa4565b60405180910390f35b61026a60048036038101906102659190613052565b61072a565b6040516102779190612fa4565b60405180910390f35b61029a60048036038101906102959190612eb1565b610746565b6040516102a79190612f1b565b60405180910390f35b6102ca60048036038101906102c59190612eb1565b610791565b6040516102d79190612f1b565b60405180910390f35b6102fa60048036038101906102f59190612eb1565b6107dc565b6040516103079190612fa4565b60405180910390f35b61032a60048036038101906103259190613090565b610830565b6040516103379190612fa4565b60405180910390f35b61035a60048036038101906103559190612fc4565b61086d565b6040516103679190612fa4565b60405180910390f35b61037861089f565b6040516103859190612fa4565b60405180910390f35b6103a860048036038101906103a39190612eb1565b610903565b6040516103b59190612f1b565b60405180910390f35b6103c661094e565b6040516103d39190612fa4565b60405180910390f35b6103f660048036038101906103f19190612eb1565b6109b1565b6040516104039190612f1b565b60405180910390f35b61042660048036038101906104219190612eb1565b6109fc565b6040516104339190612fa4565b60405180910390f35b610456600480360381019061045191906130e0565b610a50565b6040516104639190612fa4565b60405180910390f35b610474610ab4565b6040516104819190612fa4565b60405180910390f35b6104a4600480360381019061049f9190613052565b610b0c565b6040516104b19190612fa4565b60405180910390f35b6104d460048036038101906104cf9190612eb1565b610b28565b6040516104e19190612fa4565b60405180910390f35b6104f2610b7c565b6040516104ff9190612fa4565b60405180910390f35b610522600480360381019061051d9190612fc4565b610b8c565b60405161052f9190613153565b60405180910390f35b610552600480360381019061054d9190612fc4565b610bb5565b60405161055f9190612fa4565b60405180910390f35b610582600480360381019061057d919061316c565b610be7565b60405161058f9190612fa4565b60405180910390f35b6105b260048036038101906105ad9190612fc4565b610c01565b6040516105bf9190612fa4565b60405180910390f35b6105e260048036038101906105dd9190612fc4565b610c33565b6040516105f0929190613197565b60405180910390f35b610613600480360381019061060e91906130e0565b610c60565b6040516106209190612fa4565b60405180910390f35b5f5f61063e8386610cc490919063ffffffff16565b90505f6106548486610cc490919063ffffffff16565b90506106698183610ce890919063ffffffff16565b925050509392505050565b60605f61068a8386610cc490919063ffffffff16565b90505f6106a08486610cc490919063ffffffff16565b90506106bd6106b88284610d1790919063ffffffff16565b610da6565b925050509392505050565b60606106e56106e08385610cc490919063ffffffff16565b610da6565b905092915050565b60605f6107038486610cc490919063ffffffff16565b905061072061071b8483610f9590919063ffffffff16565b610da6565b9150509392505050565b606061073e61073984846111e2565b610da6565b905092915050565b5f5f61075b8386610cc490919063ffffffff16565b90505f6107718486610cc490919063ffffffff16565b9050610786818361132e90919063ffffffff16565b925050509392505050565b5f5f6107a68386610cc490919063ffffffff16565b90505f6107bc8486610cc490919063ffffffff16565b90506107d1818361135c90919063ffffffff16565b925050509392505050565b60605f6107f28386610cc490919063ffffffff16565b90505f6108088486610cc490919063ffffffff16565b9050610825610820828461138b90919063ffffffff16565b610da6565b925050509392505050565b60605f6108468486610cc490919063ffffffff16565b905061086361085e848361141a90919063ffffffff16565b610da6565b9150509392505050565b60605f6108838385610cc490919063ffffffff16565b9050610896610891826114ff565b610da6565b91505092915050565b60606108fe600160806001901b6108b691906131eb565b600160126108c491906131eb565b600a6108d0919061334d565b60026108dc9190613397565b166080600160126108ed91906131eb565b6108f69061340d565b901b17610da6565b905090565b5f5f6109188386610cc490919063ffffffff16565b90505f61092e8486610cc490919063ffffffff16565b9050610943818361152990919063ffffffff16565b925050509392505050565b60606109ac600160806001901b61096591906131eb565b6001601261097391906131eb565b600a61097f919061334d565b166080600180601261099191906131eb565b61099a9061340d565b6109a49190613453565b901b17610da6565b905090565b5f5f6109c68386610cc490919063ffffffff16565b90505f6109dc8486610cc490919063ffffffff16565b90506109f1818361155790919063ffffffff16565b925050509392505050565b60605f610a128386610cc490919063ffffffff16565b90505f610a288486610cc490919063ffffffff16565b9050610a45610a40828461158590919063ffffffff16565b610da6565b925050509392505050565b60605f610a668387610cc490919063ffffffff16565b90505f610a7c8487610cc490919063ffffffff16565b90505f610a928587610cc490919063ffffffff16565b9050610aa7610aa28484846115cd565b610da6565b9350505050949350505050565b6060610b07600160806001901b610acb91906131eb565b60016012610ad991906131eb565b600a610ae5919061334d565b16608060016012610af691906131eb565b610aff9061340d565b901b17610da6565b905090565b6060610b20610b1b84846119d9565b610da6565b905092915050565b60605f610b3e8386610cc490919063ffffffff16565b90505f610b548486610cc490919063ffffffff16565b9050610b71610b6c8284611b0b90919063ffffffff16565b610da6565b925050509392505050565b6060610b875f610da6565b905090565b5f5f610ba18385610cc490919063ffffffff16565b9050610bac81611b53565b91505092915050565b60605f610bcb8385610cc490919063ffffffff16565b9050610bde610bd982611bab565b610da6565b91505092915050565b6060610bfa610bf583611c31565b610da6565b9050919050565b60605f610c178385610cc490919063ffffffff16565b9050610c2a610c2582611c92565b610da6565b91505092915050565b5f5f5f610c498486610cc490919063ffffffff16565b9050610c5481611cbd565b92509250509250929050565b60605f610c768387610cc490919063ffffffff16565b90505f610c8c8487610cc490919063ffffffff16565b90505f610ca28587610cc490919063ffffffff16565b9050610cb7610cb2848484611cd9565b610da6565b9350505050949350505050565b5f610ce083610cd284611e54565b610cdb9061340d565b6111e2565b905092915050565b5f5f5f610cf58585611ec0565b91509150610d028161203f565b610d0b8361203f565b12159250505092915050565b5f5f610d228461204b565b90505f610d2e8461204b565b9050610d9c610d3c8261203f565b6012600a610d4a919061334d565b610d538561203f565b610d5d9190613397565b610d6791906134c1565b610d716012611e54565b610d7a8461206e565b610d838661206e565b610d8d9190613529565b610d979190613529565b6111e2565b9250505092915050565b6060806060610db48461204b565b93505f610dda60016012600a610dca919061334d565b610dd491906131eb565b5f6111e2565b90505f60016012610deb91906131eb565b90505f8190505f5f610dfc89611cbd565b91509150610e1b85610e0d8b6114ff565b61152990919063ffffffff16565b8015610e30575082610e2c9061340d565b8112155b15610ed157610e3e8961207e565b80975081985050505f8212610e615760405180602001604052805f815250610e98565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b87610ea288612512565b604051602001610eb4939291906135ed565b604051602081830303815290604052975050505050505050610f90565b610eec610ee78385610ee29061340d565b6111e2565b61207e565b80975081985050505f8212610f0f5760405180602001604052805f815250610f46565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b87610f5088612512565b610f648685610f5f9190613453565b612697565b604051602001610f779493929190613672565b6040516020818303038152906040529750505050505050505b919050565b5f5f610fa08461203f565b90505f831480610faf57505f81145b15610fbd57839150506111dc565b5f5f8413610fd45783610fcf9061340d565b610fd6565b835b90505f8290505f85610fe78861206e565b610ff19190613453565b90505f8613156110c3575b6010831061102d57662386f26fc100008261101791906134c1565b915060108361102691906131eb565b9250610ffc565b60088310611057576305f5e1008261104591906134c1565b915060088361105491906131eb565b92505b6004831061107f576127108261106d91906134c1565b915060048361107c91906131eb565b92505b600283106110a65760648261109491906134c1565b91506002836110a391906131eb565b92505b600183106110be57600a826110bb91906134c1565b91505b6111cb565b6012831115611107576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016110fe9061370f565b60405180910390fd5b5b6010831061113957662386f26fc10000826111239190613397565b915060108361113291906131eb565b9250611108565b60088310611163576305f5e100826111519190613397565b915060088361116091906131eb565b92505b6004831061118b57612710826111799190613397565b915060048361118891906131eb565b92505b600283106111b2576064826111a09190613397565b91506002836111af91906131eb565b92505b600183106111ca57600a826111c79190613397565b91505b5b6111d582826119d9565b9450505050505b92915050565b5f5f83036111f2575f9050611328565b5f8390505f8390505f61120483612723565b905060016012600a611216919061334d565b61122091906131eb565b81111561128f575b60016012600a611238919061334d565b61124291906131eb565b81111561127b57600a8361125691906134c1565b92506001826112659190613453565b9150600a81611274919061372d565b9050611228565b61128583836119d9565b9350505050611328565b6001601261129d91906131eb565b600a6112a9919061334d565b811015611318575b600160126112bf91906131eb565b600a6112cb919061334d565b81101561130457600a836112df9190613397565b92506001826112ee9190613529565b9150600a816112fd919061375d565b90506112b1565b61130e83836119d9565b9350505050611328565b61132283836119d9565b93505050505b92915050565b5f5f5f61133b8585611ec0565b915091506113488161203f565b6113518361203f565b139250505092915050565b5f5f5f6113698585611ec0565b915091506113768161203f565b61137f8361203f565b13159250505092915050565b5f5f6113968461204b565b90505f6113a28461204b565b90506114106012600a6113b5919061334d565b6113be8361203f565b6113c78561203f565b6113d19190613397565b6113db91906134c1565b6113e48361206e565b6113ed8561206e565b6113f76012611e54565b6114019190613453565b61140b9190613453565b6111e2565b9250505092915050565b5f5f6114258461203f565b03611432575f90506114f9565b5f61143c8461204b565b90505f83601261144c91906131eb565b600a611458919061334d565b90505f816114658461203f565b61146f91906134c1565b90505f8261147c8561203f565b611486919061379e565b9050826002826114969190613397565b126114aa5781806114a6906137ce565b9250505b826114b49061340d565b6002826114c19190613397565b136114d55781806114d190613815565b9250505b6114f283836114e49190613397565b6114ed8661206e565b6119d9565b9450505050505b92915050565b5f61152261151461150f8461203f565b612740565b61151d8461206e565b6119d9565b9050919050565b5f5f5f6115368585611ec0565b915091506115438161203f565b61154c8361203f565b129250505092915050565b5f5f5f6115648585611ec0565b915091506115718161203f565b61157a8361203f565b149250505092915050565b5f5f5f6115928585611ec0565b915091506115c36115a28261203f565b6115ab8461203f565b6115b59190613453565b6115be8461206e565b6111e2565b9250505092915050565b5f6115d6612e1d565b611646846116416115e7888961138b565b600160806001901b6115f991906131eb565b6001601261160791906131eb565b600a611613919061334d565b600361161f9190613397565b1660806001601261163091906131eb565b6116399061340d565b901b17610d17565b611b0b565b815f0181815250506116e96116a08461169b61166b896116668b8c61138b565b61138b565b61169660877fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6119d9565b610d17565b611585565b6116e46116ad888861138b565b6116df670429d069189e00007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffef6119d9565b610d17565b611b0b565b81602001818152505061179861176461170a8360200151846020015161138b565b600160806001901b61171c91906131eb565b6001601261172a91906131eb565b600a611736919061334d565b60046117429190613397565b1660806001601261175391906131eb565b61175c9061340d565b901b17610d17565b611793611783845f015161177e865f0151875f015161138b565b61138b565b61178e601b5f6119d9565b610d17565b611585565b8160400181815250506117af81604001515f611529565b156117e6576040517f4578c21400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61187161180a60026117fb8460400151611b53565b61180591906134c1565b611c31565b61186c8360200151600160806001901b61182491906131eb565b6001601261183291906131eb565b600a61183e919061334d565b600261184a9190613397565b1660806001601261185b91906131eb565b6118649061340d565b901b17610d17565b611b0b565b8160600181815250505f611888826060015161203f565b136118c3576118be6118b960036118aa6118a58560600151611c92565b611b53565b6118b491906134c1565b611c31565b611c92565b6118e5565b6118e460036118d58360600151611b53565b6118df91906134c1565b611c31565b5b8160800181815250506119cf61196c8260800151611967845f0151611962600160806001901b61191591906131eb565b6001601261192391906131eb565b600a61192f919061334d565b600361193b9190613397565b1660806001601261194c91906131eb565b6119559061340d565b901b17876080015161138b565b610d17565b611b0b565b6119ca87600160806001901b61198291906131eb565b6001601261199091906131eb565b600a61199c919061334d565b60036119a89190613397565b166080600160126119b991906131eb565b6119c29061340d565b901b17610d17565b611b0b565b9150509392505050565b5f7fffffffffffffffffffffffffffffffff80000000000000000000000000000000600f0b8312158015611a2057506f7fffffffffffffffffffffffffffffff600f0b8313155b611a5f576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611a56906138a6565b60405180910390fd5b7fffffffffffffffffffffffffffffffff80000000000000000000000000000000600f0b8212158015611aa557506f7fffffffffffffffffffffffffffffff600f0b8213155b611ae4576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611adb9061390e565b60405180910390fd5b5f600160806001901b611af791906131eb565b8416608084901b1790508091505092915050565b5f5f5f611b188585611ec0565b91509150611b49611b288261203f565b611b318461203f565b611b3b9190613529565b611b448461206e565b6111e2565b9250505092915050565b5f5f611b5e8361204b565b9050671ff46cf1450516f46012611b748361206e565b611b7e9190613453565b611b889190613397565b611b99611b948361203f565b612755565b611ba39190613453565b915050919050565b5f5f5f611bb784611cbd565b915091505f811215611c26575f8290505f5b611bdb83611bd69061340d565b6129ae565b811015611c1157600a82611bef91906134c1565b91505f8203611c04575f945050505050611c2c565b8080600101915050611bc9565b50611c1c815f6119d9565b9350505050611c2c565b83925050505b919050565b5f5f671ff46cf1450516f483611c4791906134c1565b90505f671ff46cf1450516f482611c5e9190613397565b84611c699190613529565b9050611c89611c77826129fa565b601284611c849190613529565b6111e2565b92505050919050565b5f611cb6611c9f8361203f565b611ca89061340d565b611cb18461206e565b6119d9565b9050919050565b5f5f5f83905080600f0b9250608081901d600f0b915050915091565b5f5f600190505f611ce98661203f565b1215611d1e577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81611d1b9190613397565b90505b5f611d288561203f565b1215611d5d577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81611d5a9190613397565b90505b5f611d678461203f565b1215611d9c577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81611d999190613397565b90505b5f611da68661204b565b90505f611db28661204b565b90505f611dbe8661204b565b9050611e47611e08611dd7611dd28561203f565b612740565b611de8611de38561203f565b612740565b611df9611df48861203f565b612740565b612be49092919063ffffffff16565b85611e139190613397565b611e1c8361206e565b611e258561206e565b611e2e8761206e565b611e389190613453565b611e429190613529565b6111e2565b9450505050509392505050565b5f7f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821115611eb8576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611eaf90613976565b60405180910390fd5b819050919050565b5f5f5f5f611ecd86611cbd565b915091505f5f611edc87611cbd565b915091505f84148015611eee57505f82145b15611f02575f5f9550955050505050612038565b5f8403611f2a57611f135f826119d9565b611f1d83836119d9565b9550955050505050612038565b5f8203611f5257611f3b84846119d9565b611f455f856119d9565b9550955050505050612038565b5f611f5c8961204b565b90505f611f688961204b565b9050611f738261203f565b9550611f7e8261206e565b9450611f898161203f565b9350611f948161206e565b92505f8386611fa39190613529565b90505f8112611feb576012811115611fd05782611fc05f886119d9565b9850985050505050505050612038565b82611fdb8383610f95565b9850985050505050505050612038565b601281611ff79061340d565b1115612018576120075f856119d9565b829850985050505050505050612038565b61202b83826120269061340d565b610f95565b8298509850505050505050505b9250929050565b5f81600f0b9050919050565b5f5f5f61205784611cbd565b9150915061206582826111e2565b92505050919050565b5f608082901d600f0b9050919050565b6060805f61208b84611cbd565b5090505f810361210b576040518060400160405280600181526020017f30000000000000000000000000000000000000000000000000000000000000008152506040518060400160405280600181526020017f3000000000000000000000000000000000000000000000000000000000000000815250925092505061250d565b5f61211585611bab565b905060605f5f61212484611cbd565b915091505f820361216c576040518060400160405280600181526020017f300000000000000000000000000000000000000000000000000000000000000081525092506122d9565b5f61218e5f84121561218757836121829061340d565b612189565b835b612c9c565b905081815161219d9190613994565b67ffffffffffffffff8111156121b6576121b56139c7565b5b6040519080825280601f01601f1916602001820160405280156121e85781602001600182028036833780820191505090505b5093505f5f90505b84518110156122d657815181101561226657818181518110612215576122146139f4565b5b602001015160f81c60f81b858281518110612233576122326139f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053506122c9565b7f300000000000000000000000000000000000000000000000000000000000000085828151811061229a576122996139f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053505b80806001019150506121f0565b50505b5f5f83036122e9578890506122f6565b6122f38986611b0b565b90505b60605f5f61230384611cbd565b915091505f820361234b576040518060400160405280600181526020017f300000000000000000000000000000000000000000000000000000000000000081525092506124fd565b5f61236d5f84121561236657836123619061340d565b612368565b835b612c9c565b9050816123799061340d565b67ffffffffffffffff811115612392576123916139c7565b5b6040519080825280601f01601f1916602001820160405280156123c45781602001600182028036833780820191505090505b5093505f5f90505b84518110156124fa578151811015612472578181600184516123ee91906131eb565b6123f891906131eb565b81518110612409576124086139f4565b5b602001015160f81c60f81b85826001885161242491906131eb565b61242e91906131eb565b8151811061243f5761243e6139f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053506124ed565b7f30000000000000000000000000000000000000000000000000000000000000008582600188516124a391906131eb565b6124ad91906131eb565b815181106124be576124bd6139f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053505b80806001019150506123cc565b50505b86839a509a505050505050505050505b915091565b60605f6001835161252391906131eb565b90505b5f8111801561259357507f3000000000000000000000000000000000000000000000000000000000000000838281518110612564576125636139f4565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b156125ab5780806125a390613a21565b915050612526565b5f6001826125b99190613994565b67ffffffffffffffff8111156125d2576125d16139c7565b5b6040519080825280601f01601f1916602001820160405280156126045781602001600182028036833780820191505090505b5090505f5f90505b6001836126199190613994565b81101561268c57848181518110612633576126326139f4565b5b602001015160f81c60f81b828281518110612651576126506139f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a905350808060010191505061260c565b508092505050919050565b60605f82126126b45760405180602001604052805f8152506126eb565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b6126fc6126f784612740565b612c9c565b60405160200161270d929190613a8c565b6040516020818303038152906040529050919050565b5f5f82126127335781905061273b565b600182190190505b919050565b5f60ff82901d60ff83901d8301189050919050565b5f816fffffffffffffffffffffffffffffffff1060071b905081811c67ffffffffffffffff1060061b8117905081811c63ffffffff1060051b8117905081811c61ffff1060041b8117905081811c60ff1060031b811790505f82136127c157631615e6385f526004601cfd5b7ff8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff6f8421084210842108cc6318c6db6d54be83831c1c601f161a8118905081811b609f1c91506c8c3f38e95a6b1ff2ab1c3b3437828384856c29508e458543d8aa4df2abee78010260601d6d0139601a2efabe717e604cbb4894010260601d6d02247f7a7b6594320649aa03aba1010260601d036d02384773bdf1ac5676facced609183820260601d0390506cb9a025d814b29c212b8b1a07ce83820260601d0390506c0a09507084cc699bb0e71ea86a60601b838202039050826c465772b2bbbb5f824b15207a300180840260601d6d0388eaa27412d5aca026815d636e01905080840260601d6d0df99ac502031bf953eff472fdcc01905080840260601d6d13cdffb29d51d99322bdff5f221101905080840260601d6d0a0f742023def783a307a986912e01905080840260601d6d01920d8043ca89b5239253284e4201905080840260601d6c0b7a86d7375468fac667a0a527019050808205915081711340daa0d5f769dba1915cef59f0815a55060291508183609f037d0267a36c0c95b3975ab3ee5b203a7614a3f75373f047d803ae7b6687f2b302019150817d57115e47018c7177eebf7cd370a3356a1b7863008a5ae8028c72b88642840191508160ae1d92505050919050565b5f5f8212156129f2576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016129e990613af9565b60405180910390fd5b819050919050565b5f7ffffffffffffffffffffffffffffffffffffffffffffffffdc0d0570925a462d7821315612bdf57680755bf798b4a1bf1e58212612a405763a37bfec95f526004601cfd5b6503782dace9d9604e83901b81612a5a57612a59613494565b5b0591505f60606b8000000000000000000000006bb17217f7d1cf79abc9e3b398606086901b81612a8d57612a8c613494565b5b0501901d90506bb17217f7d1cf79abc9e3b3988102830392505f6c10fe68e7fd37d0007b713f7650840190506d02d16720577bd19bf614176fe9ea6060858302901d0190505f6d04a4fd9f2a8b96949216d2255a6c8583010390506e0587f503bb6ea29d25fcb7401964506060838302901d01905079d835ebba824c98fb31b83b2ca45c0000000000000000000000008582020190505f6c240c330e9fb2d9cbaf0fd5aafc860390506d0277594991cfc85f6e2461837cd96060878302901d0190506d1a521255e34f6a5061b25ef1c9c46060878302901d0390506db1bbb201f443cf962f1a1d3db4a56060878302901d0190506e02c72388d9f74f51a9331fed693f156060878302901d0390506e05180bb14799ab47a8a8cb2a527d576060878302901d01905080820594508360c30374029d9dc38563c32e5c2f6dc192ee70ef65f9978af38602901c9450505050505b919050565b5f8284029050600115612c955781838583041485151702612c8f575f198385098181108201810383858709845f038516828611612c285763ae47f7025f526004601cfd5b808604955085600302600218808702600203810290508087026002038102905080870260020381029050808702600203810290508087026002038102905080818802600203028284880304600184855f030401888611870302170295505050505050612c95565b81810490505b9392505050565b60605f8203612ce2576040518060400160405280600181526020017f30000000000000000000000000000000000000000000000000000000000000008152509050612dcf565b5f612cec83612dd4565b60ff1690505f8167ffffffffffffffff811115612d0c57612d0b6139c7565b5b6040519080825280601f01601f191660200182016040528015612d3e5781602001600182028036833780820191505090505b5090505b5f8414612dc957600182612d5691906131eb565b9150600a84612d659190613b17565b6030612d719190613994565b60f81b818381518110612d8757612d866139f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a905350600a84612dc2919061372d565b9350612d42565b80925050505b919050565b5f5f8203612de55760019050612e18565b5f5f90505b5f8314612e13578080612dfc90613b53565b915050600a83612e0c919061372d565b9250612dea565b809150505b919050565b6040518060a001604052805f81526020015f81526020015f81526020015f81526020015f81525090565b5f5ffd5b5f819050919050565b612e5d81612e4b565b8114612e67575f5ffd5b50565b5f81359050612e7881612e54565b92915050565b5f819050919050565b612e9081612e7e565b8114612e9a575f5ffd5b50565b5f81359050612eab81612e87565b92915050565b5f5f5f60608486031215612ec857612ec7612e47565b5b5f612ed586828701612e6a565b9350506020612ee686828701612e6a565b9250506040612ef786828701612e9d565b9150509250925092565b5f8115159050919050565b612f1581612f01565b82525050565b5f602082019050612f2e5f830184612f0c565b92915050565b5f81519050919050565b5f82825260208201905092915050565b8281835e5f83830152505050565b5f601f19601f8301169050919050565b5f612f7682612f34565b612f808185612f3e565b9350612f90818560208601612f4e565b612f9981612f5c565b840191505092915050565b5f6020820190508181035f830152612fbc8184612f6c565b905092915050565b5f5f60408385031215612fda57612fd9612e47565b5b5f612fe785828601612e6a565b9250506020612ff885828601612e9d565b9150509250929050565b5f5f5f6060848603121561301957613018612e47565b5b5f61302686828701612e6a565b935050602061303786828701612e9d565b925050604061304886828701612e6a565b9150509250925092565b5f5f6040838503121561306857613067612e47565b5b5f61307585828601612e6a565b925050602061308685828601612e6a565b9150509250929050565b5f5f5f606084860312156130a7576130a6612e47565b5b5f6130b486828701612e6a565b93505060206130c586828701612e9d565b92505060406130d686828701612e9d565b9150509250925092565b5f5f5f5f608085870312156130f8576130f7612e47565b5b5f61310587828801612e6a565b945050602061311687828801612e6a565b935050604061312787828801612e6a565b925050606061313887828801612e9d565b91505092959194509250565b61314d81612e4b565b82525050565b5f6020820190506131665f830184613144565b92915050565b5f6020828403121561318157613180612e47565b5b5f61318e84828501612e6a565b91505092915050565b5f6040820190506131aa5f830185613144565b6131b76020830184613144565b9392505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f6131f582612e7e565b915061320083612e7e565b9250828203905081811115613218576132176131be565b5b92915050565b5f8160011c9050919050565b5f5f8291508390505b60018511156132735780860481111561324f5761324e6131be565b5b600185161561325e5780820291505b808102905061326c8561321e565b9450613233565b94509492505050565b5f8261328b5760019050613346565b81613298575f9050613346565b81600181146132ae57600281146132b8576132e7565b6001915050613346565b60ff8411156132ca576132c96131be565b5b8360020a9150848211156132e1576132e06131be565b5b50613346565b5060208310610133831016604e8410600b841016171561331c5782820a905083811115613317576133166131be565b5b613346565b613329848484600161322a565b925090508184048111156133405761333f6131be565b5b81810290505b9392505050565b5f61335782612e7e565b915061336283612e7e565b925061338f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff848461327c565b905092915050565b5f6133a182612e4b565b91506133ac83612e4b565b92508282026133ba81612e4b565b91507f800000000000000000000000000000000000000000000000000000000000000084145f841216156133f1576133f06131be565b5b8282058414831517613406576134056131be565b5b5092915050565b5f61341782612e4b565b91507f80000000000000000000000000000000000000000000000000000000000000008203613449576134486131be565b5b815f039050919050565b5f61345d82612e4b565b915061346883612e4b565b92508282019050828112155f8312168382125f84121516171561348e5761348d6131be565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f6134cb82612e4b565b91506134d683612e4b565b9250826134e6576134e5613494565b5b60015f0383147f80000000000000000000000000000000000000000000000000000000000000008314161561351e5761351d6131be565b5b828205905092915050565b5f61353382612e4b565b915061353e83612e4b565b925082820390508181125f8412168282135f851215161715613563576135626131be565b5b92915050565b5f81905092915050565b5f61357d82612f34565b6135878185613569565b9350613597818560208601612f4e565b80840191505092915050565b7f2e000000000000000000000000000000000000000000000000000000000000005f82015250565b5f6135d7600183613569565b91506135e2826135a3565b600182019050919050565b5f6135f88286613573565b91506136048285613573565b915061360f826135cb565b915061361b8284613573565b9150819050949350505050565b7f65000000000000000000000000000000000000000000000000000000000000005f82015250565b5f61365c600183613569565b915061366782613628565b600182019050919050565b5f61367d8287613573565b91506136898286613573565b9150613694826135cb565b91506136a08285613573565b91506136ab82613650565b91506136b78284613573565b915081905095945050505050565b7f73686966743a207c697c20746f6f206c617267650000000000000000000000005f82015250565b5f6136f9601483612f3e565b9150613704826136c5565b602082019050919050565b5f6020820190508181035f830152613726816136ed565b9050919050565b5f61373782612e7e565b915061374283612e7e565b92508261375257613751613494565b5b828204905092915050565b5f61376782612e7e565b915061377283612e7e565b925082820261378081612e7e565b91508282048414831517613797576137966131be565b5b5092915050565b5f6137a882612e4b565b91506137b383612e4b565b9250826137c3576137c2613494565b5b828207905092915050565b5f6137d882612e4b565b91507f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361380a576138096131be565b5b600182019050919050565b5f61381f82612e4b565b91507f80000000000000000000000000000000000000000000000000000000000000008203613851576138506131be565b5b600182039050919050565b7f4d616e7469737361206f766572666c6f770000000000000000000000000000005f82015250565b5f613890601183612f3e565b915061389b8261385c565b602082019050919050565b5f6020820190508181035f8301526138bd81613884565b9050919050565b7f4578706f6e656e74206f766572666c6f770000000000000000000000000000005f82015250565b5f6138f8601183612f3e565b9150613903826138c4565b602082019050919050565b5f6020820190508181035f830152613925816138ec565b9050919050565b7f56616c7565206f7574206f6620696e743235362072616e6765000000000000005f82015250565b5f613960601983612f3e565b915061396b8261392c565b602082019050919050565b5f6020820190508181035f83015261398d81613954565b9050919050565b5f61399e82612e7e565b91506139a983612e7e565b92508282019050808211156139c1576139c06131be565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f613a2b82612e7e565b91505f8203613a3d57613a3c6131be565b5b600182039050919050565b5f81519050919050565b5f81905092915050565b5f613a6682613a48565b613a708185613a52565b9350613a80818560208601612f4e565b80840191505092915050565b5f613a978285613573565b9150613aa38284613a5c565b91508190509392505050565b7f56616c7565206d757374206265206e6f6e2d6e656761746976650000000000005f82015250565b5f613ae3601a83612f3e565b9150613aee82613aaf565b602082019050919050565b5f6020820190508181035f830152613b1081613ad7565b9050919050565b5f613b2182612e7e565b9150613b2c83612e7e565b925082613b3c57613b3b613494565b5b828206905092915050565b5f60ff82169050919050565b5f613b5d82613b47565b915060ff8203613b7057613b6f6131be565b5b60018201905091905056fea26469706673582212209573e0249f0829e00655b3519e9c29531393724344f8f9fe64f26c1a6a2f02a464736f6c634300081e0033"
        },
        "deployedBytecode": {
          "object": "608060405234801561000f575f5ffd5b506004361061018c575f3560e01c806379102fa4116100dc578063bc1b392d11610095578063dad234fe1161006f578063dad234fe14610568578063e50ab79914610598578063ecf3f523146105c8578063fcfb9471146105f95761018c565b8063bc1b392d146104ea578063cc375c3d14610508578063cf32087a146105385761018c565b806379102fa4146103dc5780637bf90bbc1461040c5780638ed755bd1461043c578063901717d11461046c57806392c1eb9e1461048a578063a436cea8146104ba5761018c565b80633fb7e161116101495780635fcf9543116101235780635fcf9543146103405780635fdf05d71461037057806363658f821461038e578063643ceff9146103be5761018c565b80633fb7e161146102b057806350f46c17146102e057806353915fef146103105761018c565b80630b44b033146101905780630ff89c2b146101c057806311976261146101f05780631b7e5c19146102205780631e18b7b2146102505780632e293db014610280575b5f5ffd5b6101aa60048036038101906101a59190612eb1565b610629565b6040516101b79190612f1b565b60405180910390f35b6101da60048036038101906101d59190612eb1565b610674565b6040516101e79190612fa4565b60405180910390f35b61020a60048036038101906102059190612fc4565b6106c8565b6040516102179190612fa4565b60405180910390f35b61023a60048036038101906102359190613002565b6106ed565b6040516102479190612fa4565b60405180910390f35b61026a60048036038101906102659190613052565b61072a565b6040516102779190612fa4565b60405180910390f35b61029a60048036038101906102959190612eb1565b610746565b6040516102a79190612f1b565b60405180910390f35b6102ca60048036038101906102c59190612eb1565b610791565b6040516102d79190612f1b565b60405180910390f35b6102fa60048036038101906102f59190612eb1565b6107dc565b6040516103079190612fa4565b60405180910390f35b61032a60048036038101906103259190613090565b610830565b6040516103379190612fa4565b60405180910390f35b61035a60048036038101906103559190612fc4565b61086d565b6040516103679190612fa4565b60405180910390f35b61037861089f565b6040516103859190612fa4565b60405180910390f35b6103a860048036038101906103a39190612eb1565b610903565b6040516103b59190612f1b565b60405180910390f35b6103c661094e565b6040516103d39190612fa4565b60405180910390f35b6103f660048036038101906103f19190612eb1565b6109b1565b6040516104039190612f1b565b60405180910390f35b61042660048036038101906104219190612eb1565b6109fc565b6040516104339190612fa4565b60405180910390f35b610456600480360381019061045191906130e0565b610a50565b6040516104639190612fa4565b60405180910390f35b610474610ab4565b6040516104819190612fa4565b60405180910390f35b6104a4600480360381019061049f9190613052565b610b0c565b6040516104b19190612fa4565b60405180910390f35b6104d460048036038101906104cf9190612eb1565b610b28565b6040516104e19190612fa4565b60405180910390f35b6104f2610b7c565b6040516104ff9190612fa4565b60405180910390f35b610522600480360381019061051d9190612fc4565b610b8c565b60405161052f9190613153565b60405180910390f35b610552600480360381019061054d9190612fc4565b610bb5565b60405161055f9190612fa4565b60405180910390f35b610582600480360381019061057d919061316c565b610be7565b60405161058f9190612fa4565b60405180910390f35b6105b260048036038101906105ad9190612fc4565b610c01565b6040516105bf9190612fa4565b60405180910390f35b6105e260048036038101906105dd9190612fc4565b610c33565b6040516105f0929190613197565b60405180910390f35b610613600480360381019061060e91906130e0565b610c60565b6040516106209190612fa4565b60405180910390f35b5f5f61063e8386610cc490919063ffffffff16565b90505f6106548486610cc490919063ffffffff16565b90506106698183610ce890919063ffffffff16565b925050509392505050565b60605f61068a8386610cc490919063ffffffff16565b90505f6106a08486610cc490919063ffffffff16565b90506106bd6106b88284610d1790919063ffffffff16565b610da6565b925050509392505050565b60606106e56106e08385610cc490919063ffffffff16565b610da6565b905092915050565b60605f6107038486610cc490919063ffffffff16565b905061072061071b8483610f9590919063ffffffff16565b610da6565b9150509392505050565b606061073e61073984846111e2565b610da6565b905092915050565b5f5f61075b8386610cc490919063ffffffff16565b90505f6107718486610cc490919063ffffffff16565b9050610786818361132e90919063ffffffff16565b925050509392505050565b5f5f6107a68386610cc490919063ffffffff16565b90505f6107bc8486610cc490919063ffffffff16565b90506107d1818361135c90919063ffffffff16565b925050509392505050565b60605f6107f28386610cc490919063ffffffff16565b90505f6108088486610cc490919063ffffffff16565b9050610825610820828461138b90919063ffffffff16565b610da6565b925050509392505050565b60605f6108468486610cc490919063ffffffff16565b905061086361085e848361141a90919063ffffffff16565b610da6565b9150509392505050565b60605f6108838385610cc490919063ffffffff16565b9050610896610891826114ff565b610da6565b91505092915050565b60606108fe600160806001901b6108b691906131eb565b600160126108c491906131eb565b600a6108d0919061334d565b60026108dc9190613397565b166080600160126108ed91906131eb565b6108f69061340d565b901b17610da6565b905090565b5f5f6109188386610cc490919063ffffffff16565b90505f61092e8486610cc490919063ffffffff16565b9050610943818361152990919063ffffffff16565b925050509392505050565b60606109ac600160806001901b61096591906131eb565b6001601261097391906131eb565b600a61097f919061334d565b166080600180601261099191906131eb565b61099a9061340d565b6109a49190613453565b901b17610da6565b905090565b5f5f6109c68386610cc490919063ffffffff16565b90505f6109dc8486610cc490919063ffffffff16565b90506109f1818361155790919063ffffffff16565b925050509392505050565b60605f610a128386610cc490919063ffffffff16565b90505f610a288486610cc490919063ffffffff16565b9050610a45610a40828461158590919063ffffffff16565b610da6565b925050509392505050565b60605f610a668387610cc490919063ffffffff16565b90505f610a7c8487610cc490919063ffffffff16565b90505f610a928587610cc490919063ffffffff16565b9050610aa7610aa28484846115cd565b610da6565b9350505050949350505050565b6060610b07600160806001901b610acb91906131eb565b60016012610ad991906131eb565b600a610ae5919061334d565b16608060016012610af691906131eb565b610aff9061340d565b901b17610da6565b905090565b6060610b20610b1b84846119d9565b610da6565b905092915050565b60605f610b3e8386610cc490919063ffffffff16565b90505f610b548486610cc490919063ffffffff16565b9050610b71610b6c8284611b0b90919063ffffffff16565b610da6565b925050509392505050565b6060610b875f610da6565b905090565b5f5f610ba18385610cc490919063ffffffff16565b9050610bac81611b53565b91505092915050565b60605f610bcb8385610cc490919063ffffffff16565b9050610bde610bd982611bab565b610da6565b91505092915050565b6060610bfa610bf583611c31565b610da6565b9050919050565b60605f610c178385610cc490919063ffffffff16565b9050610c2a610c2582611c92565b610da6565b91505092915050565b5f5f5f610c498486610cc490919063ffffffff16565b9050610c5481611cbd565b92509250509250929050565b60605f610c768387610cc490919063ffffffff16565b90505f610c8c8487610cc490919063ffffffff16565b90505f610ca28587610cc490919063ffffffff16565b9050610cb7610cb2848484611cd9565b610da6565b9350505050949350505050565b5f610ce083610cd284611e54565b610cdb9061340d565b6111e2565b905092915050565b5f5f5f610cf58585611ec0565b91509150610d028161203f565b610d0b8361203f565b12159250505092915050565b5f5f610d228461204b565b90505f610d2e8461204b565b9050610d9c610d3c8261203f565b6012600a610d4a919061334d565b610d538561203f565b610d5d9190613397565b610d6791906134c1565b610d716012611e54565b610d7a8461206e565b610d838661206e565b610d8d9190613529565b610d979190613529565b6111e2565b9250505092915050565b6060806060610db48461204b565b93505f610dda60016012600a610dca919061334d565b610dd491906131eb565b5f6111e2565b90505f60016012610deb91906131eb565b90505f8190505f5f610dfc89611cbd565b91509150610e1b85610e0d8b6114ff565b61152990919063ffffffff16565b8015610e30575082610e2c9061340d565b8112155b15610ed157610e3e8961207e565b80975081985050505f8212610e615760405180602001604052805f815250610e98565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b87610ea288612512565b604051602001610eb4939291906135ed565b604051602081830303815290604052975050505050505050610f90565b610eec610ee78385610ee29061340d565b6111e2565b61207e565b80975081985050505f8212610f0f5760405180602001604052805f815250610f46565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b87610f5088612512565b610f648685610f5f9190613453565b612697565b604051602001610f779493929190613672565b6040516020818303038152906040529750505050505050505b919050565b5f5f610fa08461203f565b90505f831480610faf57505f81145b15610fbd57839150506111dc565b5f5f8413610fd45783610fcf9061340d565b610fd6565b835b90505f8290505f85610fe78861206e565b610ff19190613453565b90505f8613156110c3575b6010831061102d57662386f26fc100008261101791906134c1565b915060108361102691906131eb565b9250610ffc565b60088310611057576305f5e1008261104591906134c1565b915060088361105491906131eb565b92505b6004831061107f576127108261106d91906134c1565b915060048361107c91906131eb565b92505b600283106110a65760648261109491906134c1565b91506002836110a391906131eb565b92505b600183106110be57600a826110bb91906134c1565b91505b6111cb565b6012831115611107576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016110fe9061370f565b60405180910390fd5b5b6010831061113957662386f26fc10000826111239190613397565b915060108361113291906131eb565b9250611108565b60088310611163576305f5e100826111519190613397565b915060088361116091906131eb565b92505b6004831061118b57612710826111799190613397565b915060048361118891906131eb565b92505b600283106111b2576064826111a09190613397565b91506002836111af91906131eb565b92505b600183106111ca57600a826111c79190613397565b91505b5b6111d582826119d9565b9450505050505b92915050565b5f5f83036111f2575f9050611328565b5f8390505f8390505f61120483612723565b905060016012600a611216919061334d565b61122091906131eb565b81111561128f575b60016012600a611238919061334d565b61124291906131eb565b81111561127b57600a8361125691906134c1565b92506001826112659190613453565b9150600a81611274919061372d565b9050611228565b61128583836119d9565b9350505050611328565b6001601261129d91906131eb565b600a6112a9919061334d565b811015611318575b600160126112bf91906131eb565b600a6112cb919061334d565b81101561130457600a836112df9190613397565b92506001826112ee9190613529565b9150600a816112fd919061375d565b90506112b1565b61130e83836119d9565b9350505050611328565b61132283836119d9565b93505050505b92915050565b5f5f5f61133b8585611ec0565b915091506113488161203f565b6113518361203f565b139250505092915050565b5f5f5f6113698585611ec0565b915091506113768161203f565b61137f8361203f565b13159250505092915050565b5f5f6113968461204b565b90505f6113a28461204b565b90506114106012600a6113b5919061334d565b6113be8361203f565b6113c78561203f565b6113d19190613397565b6113db91906134c1565b6113e48361206e565b6113ed8561206e565b6113f76012611e54565b6114019190613453565b61140b9190613453565b6111e2565b9250505092915050565b5f5f6114258461203f565b03611432575f90506114f9565b5f61143c8461204b565b90505f83601261144c91906131eb565b600a611458919061334d565b90505f816114658461203f565b61146f91906134c1565b90505f8261147c8561203f565b611486919061379e565b9050826002826114969190613397565b126114aa5781806114a6906137ce565b9250505b826114b49061340d565b6002826114c19190613397565b136114d55781806114d190613815565b9250505b6114f283836114e49190613397565b6114ed8661206e565b6119d9565b9450505050505b92915050565b5f61152261151461150f8461203f565b612740565b61151d8461206e565b6119d9565b9050919050565b5f5f5f6115368585611ec0565b915091506115438161203f565b61154c8361203f565b129250505092915050565b5f5f5f6115648585611ec0565b915091506115718161203f565b61157a8361203f565b149250505092915050565b5f5f5f6115928585611ec0565b915091506115c36115a28261203f565b6115ab8461203f565b6115b59190613453565b6115be8461206e565b6111e2565b9250505092915050565b5f6115d6612e1d565b611646846116416115e7888961138b565b600160806001901b6115f991906131eb565b6001601261160791906131eb565b600a611613919061334d565b600361161f9190613397565b1660806001601261163091906131eb565b6116399061340d565b901b17610d17565b611b0b565b815f0181815250506116e96116a08461169b61166b896116668b8c61138b565b61138b565b61169660877fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6119d9565b610d17565b611585565b6116e46116ad888861138b565b6116df670429d069189e00007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffef6119d9565b610d17565b611b0b565b81602001818152505061179861176461170a8360200151846020015161138b565b600160806001901b61171c91906131eb565b6001601261172a91906131eb565b600a611736919061334d565b60046117429190613397565b1660806001601261175391906131eb565b61175c9061340d565b901b17610d17565b611793611783845f015161177e865f0151875f015161138b565b61138b565b61178e601b5f6119d9565b610d17565b611585565b8160400181815250506117af81604001515f611529565b156117e6576040517f4578c21400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61187161180a60026117fb8460400151611b53565b61180591906134c1565b611c31565b61186c8360200151600160806001901b61182491906131eb565b6001601261183291906131eb565b600a61183e919061334d565b600261184a9190613397565b1660806001601261185b91906131eb565b6118649061340d565b901b17610d17565b611b0b565b8160600181815250505f611888826060015161203f565b136118c3576118be6118b960036118aa6118a58560600151611c92565b611b53565b6118b491906134c1565b611c31565b611c92565b6118e5565b6118e460036118d58360600151611b53565b6118df91906134c1565b611c31565b5b8160800181815250506119cf61196c8260800151611967845f0151611962600160806001901b61191591906131eb565b6001601261192391906131eb565b600a61192f919061334d565b600361193b9190613397565b1660806001601261194c91906131eb565b6119559061340d565b901b17876080015161138b565b610d17565b611b0b565b6119ca87600160806001901b61198291906131eb565b6001601261199091906131eb565b600a61199c919061334d565b60036119a89190613397565b166080600160126119b991906131eb565b6119c29061340d565b901b17610d17565b611b0b565b9150509392505050565b5f7fffffffffffffffffffffffffffffffff80000000000000000000000000000000600f0b8312158015611a2057506f7fffffffffffffffffffffffffffffff600f0b8313155b611a5f576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611a56906138a6565b60405180910390fd5b7fffffffffffffffffffffffffffffffff80000000000000000000000000000000600f0b8212158015611aa557506f7fffffffffffffffffffffffffffffff600f0b8213155b611ae4576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611adb9061390e565b60405180910390fd5b5f600160806001901b611af791906131eb565b8416608084901b1790508091505092915050565b5f5f5f611b188585611ec0565b91509150611b49611b288261203f565b611b318461203f565b611b3b9190613529565b611b448461206e565b6111e2565b9250505092915050565b5f5f611b5e8361204b565b9050671ff46cf1450516f46012611b748361206e565b611b7e9190613453565b611b889190613397565b611b99611b948361203f565b612755565b611ba39190613453565b915050919050565b5f5f5f611bb784611cbd565b915091505f811215611c26575f8290505f5b611bdb83611bd69061340d565b6129ae565b811015611c1157600a82611bef91906134c1565b91505f8203611c04575f945050505050611c2c565b8080600101915050611bc9565b50611c1c815f6119d9565b9350505050611c2c565b83925050505b919050565b5f5f671ff46cf1450516f483611c4791906134c1565b90505f671ff46cf1450516f482611c5e9190613397565b84611c699190613529565b9050611c89611c77826129fa565b601284611c849190613529565b6111e2565b92505050919050565b5f611cb6611c9f8361203f565b611ca89061340d565b611cb18461206e565b6119d9565b9050919050565b5f5f5f83905080600f0b9250608081901d600f0b915050915091565b5f5f600190505f611ce98661203f565b1215611d1e577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81611d1b9190613397565b90505b5f611d288561203f565b1215611d5d577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81611d5a9190613397565b90505b5f611d678461203f565b1215611d9c577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81611d999190613397565b90505b5f611da68661204b565b90505f611db28661204b565b90505f611dbe8661204b565b9050611e47611e08611dd7611dd28561203f565b612740565b611de8611de38561203f565b612740565b611df9611df48861203f565b612740565b612be49092919063ffffffff16565b85611e139190613397565b611e1c8361206e565b611e258561206e565b611e2e8761206e565b611e389190613453565b611e429190613529565b6111e2565b9450505050509392505050565b5f7f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821115611eb8576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611eaf90613976565b60405180910390fd5b819050919050565b5f5f5f5f611ecd86611cbd565b915091505f5f611edc87611cbd565b915091505f84148015611eee57505f82145b15611f02575f5f9550955050505050612038565b5f8403611f2a57611f135f826119d9565b611f1d83836119d9565b9550955050505050612038565b5f8203611f5257611f3b84846119d9565b611f455f856119d9565b9550955050505050612038565b5f611f5c8961204b565b90505f611f688961204b565b9050611f738261203f565b9550611f7e8261206e565b9450611f898161203f565b9350611f948161206e565b92505f8386611fa39190613529565b90505f8112611feb576012811115611fd05782611fc05f886119d9565b9850985050505050505050612038565b82611fdb8383610f95565b9850985050505050505050612038565b601281611ff79061340d565b1115612018576120075f856119d9565b829850985050505050505050612038565b61202b83826120269061340d565b610f95565b8298509850505050505050505b9250929050565b5f81600f0b9050919050565b5f5f5f61205784611cbd565b9150915061206582826111e2565b92505050919050565b5f608082901d600f0b9050919050565b6060805f61208b84611cbd565b5090505f810361210b576040518060400160405280600181526020017f30000000000000000000000000000000000000000000000000000000000000008152506040518060400160405280600181526020017f3000000000000000000000000000000000000000000000000000000000000000815250925092505061250d565b5f61211585611bab565b905060605f5f61212484611cbd565b915091505f820361216c576040518060400160405280600181526020017f300000000000000000000000000000000000000000000000000000000000000081525092506122d9565b5f61218e5f84121561218757836121829061340d565b612189565b835b612c9c565b905081815161219d9190613994565b67ffffffffffffffff8111156121b6576121b56139c7565b5b6040519080825280601f01601f1916602001820160405280156121e85781602001600182028036833780820191505090505b5093505f5f90505b84518110156122d657815181101561226657818181518110612215576122146139f4565b5b602001015160f81c60f81b858281518110612233576122326139f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053506122c9565b7f300000000000000000000000000000000000000000000000000000000000000085828151811061229a576122996139f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053505b80806001019150506121f0565b50505b5f5f83036122e9578890506122f6565b6122f38986611b0b565b90505b60605f5f61230384611cbd565b915091505f820361234b576040518060400160405280600181526020017f300000000000000000000000000000000000000000000000000000000000000081525092506124fd565b5f61236d5f84121561236657836123619061340d565b612368565b835b612c9c565b9050816123799061340d565b67ffffffffffffffff811115612392576123916139c7565b5b6040519080825280601f01601f1916602001820160405280156123c45781602001600182028036833780820191505090505b5093505f5f90505b84518110156124fa578151811015612472578181600184516123ee91906131eb565b6123f891906131eb565b81518110612409576124086139f4565b5b602001015160f81c60f81b85826001885161242491906131eb565b61242e91906131eb565b8151811061243f5761243e6139f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053506124ed565b7f30000000000000000000000000000000000000000000000000000000000000008582600188516124a391906131eb565b6124ad91906131eb565b815181106124be576124bd6139f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a9053505b80806001019150506123cc565b50505b86839a509a505050505050505050505b915091565b60605f6001835161252391906131eb565b90505b5f8111801561259357507f3000000000000000000000000000000000000000000000000000000000000000838281518110612564576125636139f4565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b156125ab5780806125a390613a21565b915050612526565b5f6001826125b99190613994565b67ffffffffffffffff8111156125d2576125d16139c7565b5b6040519080825280601f01601f1916602001820160405280156126045781602001600182028036833780820191505090505b5090505f5f90505b6001836126199190613994565b81101561268c57848181518110612633576126326139f4565b5b602001015160f81c60f81b828281518110612651576126506139f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a905350808060010191505061260c565b508092505050919050565b60605f82126126b45760405180602001604052805f8152506126eb565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b6126fc6126f784612740565b612c9c565b60405160200161270d929190613a8c565b6040516020818303038152906040529050919050565b5f5f82126127335781905061273b565b600182190190505b919050565b5f60ff82901d60ff83901d8301189050919050565b5f816fffffffffffffffffffffffffffffffff1060071b905081811c67ffffffffffffffff1060061b8117905081811c63ffffffff1060051b8117905081811c61ffff1060041b8117905081811c60ff1060031b811790505f82136127c157631615e6385f526004601cfd5b7ff8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff6f8421084210842108cc6318c6db6d54be83831c1c601f161a8118905081811b609f1c91506c8c3f38e95a6b1ff2ab1c3b3437828384856c29508e458543d8aa4df2abee78010260601d6d0139601a2efabe717e604cbb4894010260601d6d02247f7a7b6594320649aa03aba1010260601d036d02384773bdf1ac5676facced609183820260601d0390506cb9a025d814b29c212b8b1a07ce83820260601d0390506c0a09507084cc699bb0e71ea86a60601b838202039050826c465772b2bbbb5f824b15207a300180840260601d6d0388eaa27412d5aca026815d636e01905080840260601d6d0df99ac502031bf953eff472fdcc01905080840260601d6d13cdffb29d51d99322bdff5f221101905080840260601d6d0a0f742023def783a307a986912e01905080840260601d6d01920d8043ca89b5239253284e4201905080840260601d6c0b7a86d7375468fac667a0a527019050808205915081711340daa0d5f769dba1915cef59f0815a55060291508183609f037d0267a36c0c95b3975ab3ee5b203a7614a3f75373f047d803ae7b6687f2b302019150817d57115e47018c7177eebf7cd370a3356a1b7863008a5ae8028c72b88642840191508160ae1d92505050919050565b5f5f8212156129f2576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016129e990613af9565b60405180910390fd5b819050919050565b5f7ffffffffffffffffffffffffffffffffffffffffffffffffdc0d0570925a462d7821315612bdf57680755bf798b4a1bf1e58212612a405763a37bfec95f526004601cfd5b6503782dace9d9604e83901b81612a5a57612a59613494565b5b0591505f60606b8000000000000000000000006bb17217f7d1cf79abc9e3b398606086901b81612a8d57612a8c613494565b5b0501901d90506bb17217f7d1cf79abc9e3b3988102830392505f6c10fe68e7fd37d0007b713f7650840190506d02d16720577bd19bf614176fe9ea6060858302901d0190505f6d04a4fd9f2a8b96949216d2255a6c8583010390506e0587f503bb6ea29d25fcb7401964506060838302901d01905079d835ebba824c98fb31b83b2ca45c0000000000000000000000008582020190505f6c240c330e9fb2d9cbaf0fd5aafc860390506d0277594991cfc85f6e2461837cd96060878302901d0190506d1a521255e34f6a5061b25ef1c9c46060878302901d0390506db1bbb201f443cf962f1a1d3db4a56060878302901d0190506e02c72388d9f74f51a9331fed693f156060878302901d0390506e05180bb14799ab47a8a8cb2a527d576060878302901d01905080820594508360c30374029d9dc38563c32e5c2f6dc192ee70ef65f9978af38602901c9450505050505b919050565b5f8284029050600115612c955781838583041485151702612c8f575f198385098181108201810383858709845f038516828611612c285763ae47f7025f526004601cfd5b808604955085600302600218808702600203810290508087026002038102905080870260020381029050808702600203810290508087026002038102905080818802600203028284880304600184855f030401888611870302170295505050505050612c95565b81810490505b9392505050565b60605f8203612ce2576040518060400160405280600181526020017f30000000000000000000000000000000000000000000000000000000000000008152509050612dcf565b5f612cec83612dd4565b60ff1690505f8167ffffffffffffffff811115612d0c57612d0b6139c7565b5b6040519080825280601f01601f191660200182016040528015612d3e5781602001600182028036833780820191505090505b5090505b5f8414612dc957600182612d5691906131eb565b9150600a84612d659190613b17565b6030612d719190613994565b60f81b818381518110612d8757612d866139f4565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690815f1a905350600a84612dc2919061372d565b9350612d42565b80925050505b919050565b5f5f8203612de55760019050612e18565b5f5f90505b5f8314612e13578080612dfc90613b53565b915050600a83612e0c919061372d565b9250612dea565b809150505b919050565b6040518060a001604052805f81526020015f81526020015f81526020015f81526020015f81525090565b5f5ffd5b5f819050919050565b612e5d81612e4b565b8114612e67575f5ffd5b50565b5f81359050612e7881612e54565b92915050565b5f819050919050565b612e9081612e7e565b8114612e9a575f5ffd5b50565b5f81359050612eab81612e87565b92915050565b5f5f5f60608486031215612ec857612ec7612e47565b5b5f612ed586828701612e6a565b9350506020612ee686828701612e6a565b9250506040612ef786828701612e9d565b9150509250925092565b5f8115159050919050565b612f1581612f01565b82525050565b5f602082019050612f2e5f830184612f0c565b92915050565b5f81519050919050565b5f82825260208201905092915050565b8281835e5f83830152505050565b5f601f19601f8301169050919050565b5f612f7682612f34565b612f808185612f3e565b9350612f90818560208601612f4e565b612f9981612f5c565b840191505092915050565b5f6020820190508181035f830152612fbc8184612f6c565b905092915050565b5f5f60408385031215612fda57612fd9612e47565b5b5f612fe785828601612e6a565b9250506020612ff885828601612e9d565b9150509250929050565b5f5f5f6060848603121561301957613018612e47565b5b5f61302686828701612e6a565b935050602061303786828701612e9d565b925050604061304886828701612e6a565b9150509250925092565b5f5f6040838503121561306857613067612e47565b5b5f61307585828601612e6a565b925050602061308685828601612e6a565b9150509250929050565b5f5f5f606084860312156130a7576130a6612e47565b5b5f6130b486828701612e6a565b93505060206130c586828701612e9d565b92505060406130d686828701612e9d565b9150509250925092565b5f5f5f5f608085870312156130f8576130f7612e47565b5b5f61310587828801612e6a565b945050602061311687828801612e6a565b935050604061312787828801612e6a565b925050606061313887828801612e9d565b91505092959194509250565b61314d81612e4b565b82525050565b5f6020820190506131665f830184613144565b92915050565b5f6020828403121561318157613180612e47565b5b5f61318e84828501612e6a565b91505092915050565b5f6040820190506131aa5f830185613144565b6131b76020830184613144565b9392505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f6131f582612e7e565b915061320083612e7e565b9250828203905081811115613218576132176131be565b5b92915050565b5f8160011c9050919050565b5f5f8291508390505b60018511156132735780860481111561324f5761324e6131be565b5b600185161561325e5780820291505b808102905061326c8561321e565b9450613233565b94509492505050565b5f8261328b5760019050613346565b81613298575f9050613346565b81600181146132ae57600281146132b8576132e7565b6001915050613346565b60ff8411156132ca576132c96131be565b5b8360020a9150848211156132e1576132e06131be565b5b50613346565b5060208310610133831016604e8410600b841016171561331c5782820a905083811115613317576133166131be565b5b613346565b613329848484600161322a565b925090508184048111156133405761333f6131be565b5b81810290505b9392505050565b5f61335782612e7e565b915061336283612e7e565b925061338f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff848461327c565b905092915050565b5f6133a182612e4b565b91506133ac83612e4b565b92508282026133ba81612e4b565b91507f800000000000000000000000000000000000000000000000000000000000000084145f841216156133f1576133f06131be565b5b8282058414831517613406576134056131be565b5b5092915050565b5f61341782612e4b565b91507f80000000000000000000000000000000000000000000000000000000000000008203613449576134486131be565b5b815f039050919050565b5f61345d82612e4b565b915061346883612e4b565b92508282019050828112155f8312168382125f84121516171561348e5761348d6131be565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f6134cb82612e4b565b91506134d683612e4b565b9250826134e6576134e5613494565b5b60015f0383147f80000000000000000000000000000000000000000000000000000000000000008314161561351e5761351d6131be565b5b828205905092915050565b5f61353382612e4b565b915061353e83612e4b565b925082820390508181125f8412168282135f851215161715613563576135626131be565b5b92915050565b5f81905092915050565b5f61357d82612f34565b6135878185613569565b9350613597818560208601612f4e565b80840191505092915050565b7f2e000000000000000000000000000000000000000000000000000000000000005f82015250565b5f6135d7600183613569565b91506135e2826135a3565b600182019050919050565b5f6135f88286613573565b91506136048285613573565b915061360f826135cb565b915061361b8284613573565b9150819050949350505050565b7f65000000000000000000000000000000000000000000000000000000000000005f82015250565b5f61365c600183613569565b915061366782613628565b600182019050919050565b5f61367d8287613573565b91506136898286613573565b9150613694826135cb565b91506136a08285613573565b91506136ab82613650565b91506136b78284613573565b915081905095945050505050565b7f73686966743a207c697c20746f6f206c617267650000000000000000000000005f82015250565b5f6136f9601483612f3e565b9150613704826136c5565b602082019050919050565b5f6020820190508181035f830152613726816136ed565b9050919050565b5f61373782612e7e565b915061374283612e7e565b92508261375257613751613494565b5b828204905092915050565b5f61376782612e7e565b915061377283612e7e565b925082820261378081612e7e565b91508282048414831517613797576137966131be565b5b5092915050565b5f6137a882612e4b565b91506137b383612e4b565b9250826137c3576137c2613494565b5b828207905092915050565b5f6137d882612e4b565b91507f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361380a576138096131be565b5b600182019050919050565b5f61381f82612e4b565b91507f80000000000000000000000000000000000000000000000000000000000000008203613851576138506131be565b5b600182039050919050565b7f4d616e7469737361206f766572666c6f770000000000000000000000000000005f82015250565b5f613890601183612f3e565b915061389b8261385c565b602082019050919050565b5f6020820190508181035f8301526138bd81613884565b9050919050565b7f4578706f6e656e74206f766572666c6f770000000000000000000000000000005f82015250565b5f6138f8601183612f3e565b9150613903826138c4565b602082019050919050565b5f6020820190508181035f830152613925816138ec565b9050919050565b7f56616c7565206f7574206f6620696e743235362072616e6765000000000000005f82015250565b5f613960601983612f3e565b915061396b8261392c565b602082019050919050565b5f6020820190508181035f83015261398d81613954565b9050919050565b5f61399e82612e7e565b91506139a983612e7e565b92508282019050808211156139c1576139c06131be565b5b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f613a2b82612e7e565b91505f8203613a3d57613a3c6131be565b5b600182039050919050565b5f81519050919050565b5f81905092915050565b5f613a6682613a48565b613a708185613a52565b9350613a80818560208601612f4e565b80840191505092915050565b5f613a978285613573565b9150613aa38284613a5c565b91508190509392505050565b7f56616c7565206d757374206265206e6f6e2d6e656761746976650000000000005f82015250565b5f613ae3601a83612f3e565b9150613aee82613aaf565b602082019050919050565b5f6020820190508181035f830152613b1081613ad7565b9050919050565b5f613b2182612e7e565b9150613b2c83612e7e565b925082613b3c57613b3b613494565b5b828206905092915050565b5f60ff82169050919050565b5f613b5d82613b47565b915060ff8203613b7057613b6f6131be565b5b60018201905091905056fea26469706673582212209573e0249f0829e00655b3519e9c29531393724344f8f9fe64f26c1a6a2f02a464736f6c634300081e0033"
        }
      }
    }
  },
  "modules": {
    "/Users/williamcory/cavalre-contracts/playground/contracts/FloatCalculator.s.sol": {
      "id": "/Users/williamcory/cavalre-contracts/playground/contracts/FloatCalculator.s.sol",
      "rawCode": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {Float, FloatLib} from \"../../libraries/FloatLib.sol\";\nimport {FloatStrings} from \"../../libraries/FloatStrings.sol\";\n\ncontract FloatCalculator {\n    using FloatLib for Float;\n    using FloatLib for int256;\n    using FloatLib for uint256;\n    using FloatStrings for Float;\n\n    // ==================\n    //     Arithmetic\n    // ==================\n\n    function add(int256 a, int256 b, uint256 decimals) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        return fa.plus(fb).toString();\n    }\n\n    function subtract(int256 a, int256 b, uint256 decimals) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        return fa.minus(fb).toString();\n    }\n\n    function multiply(int256 a, int256 b, uint256 decimals) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        return fa.times(fb).toString();\n    }\n\n    function divide(int256 a, int256 b, uint256 decimals) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        return fa.divide(fb).toString();\n    }\n\n    function negate(int256 a, uint256 decimals) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        return fa.minus().toString();\n    }\n\n    // ==================\n    //    Comparisons\n    // ==================\n\n    function isEqual(int256 a, int256 b, uint256 decimals) external pure returns (bool) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        return fa.isEQ(fb);\n    }\n\n    function isGreaterThan(int256 a, int256 b, uint256 decimals) external pure returns (bool) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        return fa.isGT(fb);\n    }\n\n    function isLessThan(int256 a, int256 b, uint256 decimals) external pure returns (bool) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        return fa.isLT(fb);\n    }\n\n    function isGreaterOrEqual(int256 a, int256 b, uint256 decimals) external pure returns (bool) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        return fa.isGEQ(fb);\n    }\n\n    function isLessOrEqual(int256 a, int256 b, uint256 decimals) external pure returns (bool) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        return fa.isLEQ(fb);\n    }\n\n    // ==================\n    //  Transformations\n    // ==================\n\n    function absoluteValue(int256 a, uint256 decimals) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        return fa.abs().toString();\n    }\n\n    function getIntegerPart(int256 a, uint256 decimals) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        return fa.integerPart().toString();\n    }\n\n    function shift(int256 a, uint256 decimals, int256 places) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        return fa.shift(places).toString();\n    }\n\n    function roundTo(int256 a, uint256 decimals, uint256 digits) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        return fa.round(digits).toString();\n    }\n\n    // ==================\n    //  Special Functions\n    // ==================\n\n    function exponential(int256 a) external pure returns (string memory) {\n        // exp takes raw int256 (18 decimal fixed point)\n        return FloatLib.exp(a).toString();\n    }\n\n    function naturalLog(int256 a, uint256 decimals) external pure returns (int256) {\n        Float fa = a.toFloat(decimals);\n        return fa.log();\n    }\n\n    function cubicSolve(int256 b, int256 c, int256 d, uint256 decimals) external pure returns (string memory) {\n        Float fb = b.toFloat(decimals);\n        Float fc = c.toFloat(decimals);\n        Float fd = d.toFloat(decimals);\n        return FloatLib.cubicsolve(fb, fc, fd).toString();\n    }\n\n    function fullMulDiv(int256 a, int256 b, int256 c, uint256 decimals) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        Float fc = c.toFloat(decimals);\n        return FloatLib.fullMulDiv(fa, fb, fc).toString();\n    }\n\n    // ==================\n    //     Utilities\n    // ==================\n\n    function toFloatString(int256 value, uint256 decimals) external pure returns (string memory) {\n        return value.toFloat(decimals).toString();\n    }\n\n    function getComponents(int256 value, uint256 decimals) external pure returns (int256 mantissa, int256 exponent) {\n        Float f = value.toFloat(decimals);\n        return FloatLib.components(f);\n    }\n\n    function fromComponents(int256 mantissa, int256 exponent) external pure returns (string memory) {\n        return FloatLib.from(mantissa, exponent).toString();\n    }\n\n    function normalize(int256 mantissa, int256 exponent) external pure returns (string memory) {\n        return FloatLib.normalize(mantissa, exponent).toString();\n    }\n\n    // ==================\n    //     Constants\n    // ==================\n\n    function zero() external pure returns (string memory) {\n        return FloatLib.ZERO.toString();\n    }\n\n    function one() external pure returns (string memory) {\n        return FloatLib.ONE.toString();\n    }\n\n    function two() external pure returns (string memory) {\n        return FloatLib.TWO.toString();\n    }\n\n    function ten() external pure returns (string memory) {\n        return FloatLib.TEN.toString();\n    }\n}\n",
      "importedIds": [
        "/Users/williamcory/cavalre-contracts/libraries/FloatLib.sol",
        "/Users/williamcory/cavalre-contracts/libraries/FloatStrings.sol"
      ],
      "code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.26;\n\nimport {Float, FloatLib} from \"/Users/williamcory/cavalre-contracts/libraries/FloatLib.sol\";\nimport {FloatStrings} from \"/Users/williamcory/cavalre-contracts/libraries/FloatStrings.sol\";\n\ncontract FloatCalculator {\n    using FloatLib for Float;\n    using FloatLib for int256;\n    using FloatLib for uint256;\n    using FloatStrings for Float;\n\n    // ==================\n    //     Arithmetic\n    // ==================\n\n    function add(int256 a, int256 b, uint256 decimals) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        return fa.plus(fb).toString();\n    }\n\n    function subtract(int256 a, int256 b, uint256 decimals) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        return fa.minus(fb).toString();\n    }\n\n    function multiply(int256 a, int256 b, uint256 decimals) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        return fa.times(fb).toString();\n    }\n\n    function divide(int256 a, int256 b, uint256 decimals) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        return fa.divide(fb).toString();\n    }\n\n    function negate(int256 a, uint256 decimals) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        return fa.minus().toString();\n    }\n\n    // ==================\n    //    Comparisons\n    // ==================\n\n    function isEqual(int256 a, int256 b, uint256 decimals) external pure returns (bool) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        return fa.isEQ(fb);\n    }\n\n    function isGreaterThan(int256 a, int256 b, uint256 decimals) external pure returns (bool) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        return fa.isGT(fb);\n    }\n\n    function isLessThan(int256 a, int256 b, uint256 decimals) external pure returns (bool) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        return fa.isLT(fb);\n    }\n\n    function isGreaterOrEqual(int256 a, int256 b, uint256 decimals) external pure returns (bool) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        return fa.isGEQ(fb);\n    }\n\n    function isLessOrEqual(int256 a, int256 b, uint256 decimals) external pure returns (bool) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        return fa.isLEQ(fb);\n    }\n\n    // ==================\n    //  Transformations\n    // ==================\n\n    function absoluteValue(int256 a, uint256 decimals) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        return fa.abs().toString();\n    }\n\n    function getIntegerPart(int256 a, uint256 decimals) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        return fa.integerPart().toString();\n    }\n\n    function shift(int256 a, uint256 decimals, int256 places) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        return fa.shift(places).toString();\n    }\n\n    function roundTo(int256 a, uint256 decimals, uint256 digits) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        return fa.round(digits).toString();\n    }\n\n    // ==================\n    //  Special Functions\n    // ==================\n\n    function exponential(int256 a) external pure returns (string memory) {\n        // exp takes raw int256 (18 decimal fixed point)\n        return FloatLib.exp(a).toString();\n    }\n\n    function naturalLog(int256 a, uint256 decimals) external pure returns (int256) {\n        Float fa = a.toFloat(decimals);\n        return fa.log();\n    }\n\n    function cubicSolve(int256 b, int256 c, int256 d, uint256 decimals) external pure returns (string memory) {\n        Float fb = b.toFloat(decimals);\n        Float fc = c.toFloat(decimals);\n        Float fd = d.toFloat(decimals);\n        return FloatLib.cubicsolve(fb, fc, fd).toString();\n    }\n\n    function fullMulDiv(int256 a, int256 b, int256 c, uint256 decimals) external pure returns (string memory) {\n        Float fa = a.toFloat(decimals);\n        Float fb = b.toFloat(decimals);\n        Float fc = c.toFloat(decimals);\n        return FloatLib.fullMulDiv(fa, fb, fc).toString();\n    }\n\n    // ==================\n    //     Utilities\n    // ==================\n\n    function toFloatString(int256 value, uint256 decimals) external pure returns (string memory) {\n        return value.toFloat(decimals).toString();\n    }\n\n    function getComponents(int256 value, uint256 decimals) external pure returns (int256 mantissa, int256 exponent) {\n        Float f = value.toFloat(decimals);\n        return FloatLib.components(f);\n    }\n\n    function fromComponents(int256 mantissa, int256 exponent) external pure returns (string memory) {\n        return FloatLib.from(mantissa, exponent).toString();\n    }\n\n    function normalize(int256 mantissa, int256 exponent) external pure returns (string memory) {\n        return FloatLib.normalize(mantissa, exponent).toString();\n    }\n\n    // ==================\n    //     Constants\n    // ==================\n\n    function zero() external pure returns (string memory) {\n        return FloatLib.ZERO.toString();\n    }\n\n    function one() external pure returns (string memory) {\n        return FloatLib.ONE.toString();\n    }\n\n    function two() external pure returns (string memory) {\n        return FloatLib.TWO.toString();\n    }\n\n    function ten() external pure returns (string memory) {\n        return FloatLib.TEN.toString();\n    }\n}\n"
    },
    "/Users/williamcory/cavalre-contracts/libraries/FloatStrings.sol": {
      "id": "/Users/williamcory/cavalre-contracts/libraries/FloatStrings.sol",
      "rawCode": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {Float, FloatLib} from \"./FloatLib.sol\";\nimport {FixedPointMathLib} from \"solady/src/utils/FixedPointMathLib.sol\";\n\nlibrary FloatStrings {\n    using FixedPointMathLib for int256;\n    using FloatLib for Float;\n\n    // Most significant bit\n    function msb(int256 value_) internal pure returns (uint256) {\n        if (value_ == 0) {\n            return 0;\n        }\n\n        return toStringBytes(value_.abs()).length;\n    }\n\n    function shiftStringBytesLeft(bytes memory strBytes_, uint256 numChars_) public pure returns (bytes memory) {\n        bytes memory _result = new bytes(strBytes_.length + numChars_);\n\n        for (uint256 _i = 0; _i < _result.length; _i++) {\n            if (_i < strBytes_.length) {\n                _result[_i] = strBytes_[_i];\n            } else {\n                _result[_i] = \"0\";\n            }\n        }\n\n        return _result;\n    }\n\n    function shiftStringLeft(string memory str_, uint256 numChars_) public pure returns (string memory) {\n        return string(shiftStringBytesLeft(bytes(str_), numChars_));\n    }\n\n    function shiftStringBytesRight(bytes memory strBytes_, uint256 numChars_)\n        public\n        pure\n        returns (bytes memory _result, bytes memory _remainder)\n    {\n        uint256 _resultChars;\n        uint256 _remainderChars;\n        uint256 _excessChars;\n        if (numChars_ > strBytes_.length) {\n            _resultChars = 0;\n            _excessChars = numChars_ - strBytes_.length;\n            _result = new bytes(1);\n        } else {\n            _resultChars = strBytes_.length - numChars_;\n            _result = new bytes(_resultChars);\n        }\n        _remainderChars = numChars_;\n        _remainder = new bytes(_remainderChars);\n\n        for (uint256 _i = 0; _i < strBytes_.length; _i++) {\n            if (_i < _resultChars) {\n                _result[_i] = strBytes_[_i];\n            } else {\n                _remainder[_remainderChars - 1 + _resultChars - _i] =\n                    strBytes_[strBytes_.length - 1 + _resultChars - _i];\n            }\n        }\n\n        return (_result, _remainder);\n    }\n\n    function shiftStringRight(string memory str_, uint256 numChars_)\n        public\n        pure\n        returns (string memory _result, string memory _remainder)\n    {\n        bytes memory _strBytes = bytes(str_);\n        bytes memory _resultBytes;\n        bytes memory _remainderBytes;\n        (_resultBytes, _remainderBytes) = shiftStringBytesRight(_strBytes, numChars_);\n        _result = string(_resultBytes);\n        _remainder = string(_remainderBytes);\n    }\n\n    function toStringBytes(uint256 value_) public pure returns (bytes memory) {\n        // Handle the special case of zero.\n        if (value_ == 0) {\n            return bytes(\"0\");\n        }\n\n        // Determine the length of the decimal number.\n        uint256 _digits = digits(value_);\n\n        // Create a temporary byte array to fill with the digits of the number.\n        bytes memory _buffer = new bytes(_digits);\n        while (value_ != 0) {\n            _digits -= 1;\n            _buffer[_digits] = bytes1(uint8(48 + (value_ % 10)));\n            value_ /= 10;\n        }\n\n        // Convert the byte array to a string and return it.\n        return _buffer;\n    }\n\n    function toStringBytes(Float value_) internal pure returns (bytes memory, bytes memory) {\n        (int256 _mantissa, ) = FloatLib.components(value_);\n        if (_mantissa == 0) {\n            return (bytes(\"0\"), bytes(\"0\"));\n        }\n\n        Float _integerPartFloat = FloatLib.integerPart(value_);\n        bytes memory _integerPartBytes;\n\n        (int256 _intMantissa, int256 _intExponent) = FloatLib.components(_integerPartFloat);\n        if (_intMantissa == 0) {\n            _integerPartBytes = bytes(\"0\");\n        } else {\n            bytes memory _integerPartMantissaBytes =\n                toStringBytes(uint256(_intMantissa >= 0 ? _intMantissa : -_intMantissa));\n\n            _integerPartBytes = new bytes(_integerPartMantissaBytes.length + uint256(_intExponent));\n\n            for (uint256 _i = 0; _i < _integerPartBytes.length; _i++) {\n                if (_i < _integerPartMantissaBytes.length) {\n                    _integerPartBytes[_i] = _integerPartMantissaBytes[_i];\n                } else {\n                    _integerPartBytes[_i] = bytes1(\"0\");\n                }\n            }\n        }\n\n        Float _fractionalPartFloat;\n        if (_intMantissa == 0) {\n            _fractionalPartFloat = value_;\n        } else {\n            _fractionalPartFloat = FloatLib.minus(value_, _integerPartFloat);\n        }\n\n        bytes memory _fractionalPartBytes;\n        (int256 _fracMantissa, int256 _fracExponent) = FloatLib.components(_fractionalPartFloat);\n        if (_fracMantissa == 0) {\n            _fractionalPartBytes = bytes(\"0\");\n        } else {\n            bytes memory _fractionalPartMantissaBytes =\n                toStringBytes(uint256(_fracMantissa >= 0 ? _fracMantissa : -_fracMantissa));\n\n            _fractionalPartBytes = new bytes(uint256(-_fracExponent));\n\n            for (uint256 _i = 0; _i < _fractionalPartBytes.length; _i++) {\n                if (_i < _fractionalPartMantissaBytes.length) {\n                    _fractionalPartBytes[_fractionalPartBytes.length - 1 - _i] =\n                        _fractionalPartMantissaBytes[_fractionalPartMantissaBytes.length - 1 - _i];\n                } else {\n                    _fractionalPartBytes[_fractionalPartBytes.length - 1 - _i] = bytes1(\"0\");\n                }\n            }\n        }\n\n        return (_integerPartBytes, _fractionalPartBytes);\n    }\n\n    function toString(uint256 value_) public pure returns (string memory) {\n        return string(toStringBytes(value_));\n    }\n\n    function toString(int256 value_) public pure returns (string memory) {\n        return string(abi.encodePacked(value_ < 0 ? \"-\" : \"\", toStringBytes(value_.abs())));\n    }\n\n    function trimStringBytesRight(bytes memory strBytes_) public pure returns (bytes memory) {\n        uint256 _i = strBytes_.length - 1;\n        while (_i > 0 && strBytes_[_i] == \"0\") {\n            _i--;\n        }\n        bytes memory _result = new bytes(_i + 1);\n        for (uint256 _j = 0; _j < _i + 1; _j++) {\n            _result[_j] = strBytes_[_j];\n        }\n        return _result;\n    }\n\n    function trimStringRight(string memory str_) public pure returns (string memory) {\n        return string(trimStringBytesRight(bytes(str_)));\n    }\n\n    function toString(Float number_) internal pure returns (string memory) {\n        bytes memory _integerPartBytes;\n        bytes memory _fractionalPartBytes;\n\n        number_ = FloatLib.normalize(number_);\n\n        Float _max = FloatLib.normalize(int256(FloatLib.NORMALIZED_MANTISSA_MAX), 0);\n\n        uint256 _ushift = FloatLib.SIGNIFICANT_DIGITS - 1;\n        int256 _ishift = int256(_ushift);\n\n        (int256 _mantissa, int256 _exponent) = FloatLib.components(number_);\n        if (FloatLib.abs(number_).isLT(_max) && _exponent >= -_ishift) {\n            (_integerPartBytes, _fractionalPartBytes) = toStringBytes(number_);\n            return string(\n                abi.encodePacked(\n                    _mantissa < 0 ? \"-\" : \"\",\n                    string(_integerPartBytes),\n                    \".\",\n                    string(trimStringBytesRight(_fractionalPartBytes))\n                )\n            );\n        } else {\n            (_integerPartBytes, _fractionalPartBytes) = toStringBytes(FloatLib.normalize(_mantissa, -_ishift));\n            return string(\n                abi.encodePacked(\n                    _mantissa < 0 ? \"-\" : \"\",\n                    string(_integerPartBytes),\n                    \".\",\n                    string(trimStringBytesRight(_fractionalPartBytes)),\n                    \"e\",\n                    toString(_exponent + _ishift)\n                )\n            );\n        }\n    }\n\n    function digits(uint256 number_) public pure returns (uint8) {\n        if (number_ == 0) {\n            return 1; // Zero has 1 significant digit\n        }\n\n        uint8 count = 0;\n        while (number_ != 0) {\n            count++;\n            number_ /= 10; // Remove the least significant digit\n        }\n        return count;\n    }\n}\n",
      "importedIds": [
        "/Users/williamcory/cavalre-contracts/libraries/FloatLib.sol",
        "/Users/williamcory/cavalre-contracts/node_modules/solady/src/utils/FixedPointMathLib.sol"
      ],
      "code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.26;\n\nimport {Float, FloatLib} from \"/Users/williamcory/cavalre-contracts/libraries/FloatLib.sol\";\nimport {FixedPointMathLib} from \"/Users/williamcory/cavalre-contracts/node_modules/solady/src/utils/FixedPointMathLib.sol\";\n\nlibrary FloatStrings {\n    using FixedPointMathLib for int256;\n    using FloatLib for Float;\n\n    // Most significant bit\n    function msb(int256 value_) internal pure returns (uint256) {\n        if (value_ == 0) {\n            return 0;\n        }\n\n        return toStringBytes(value_.abs()).length;\n    }\n\n    function shiftStringBytesLeft(bytes memory strBytes_, uint256 numChars_) public pure returns (bytes memory) {\n        bytes memory _result = new bytes(strBytes_.length + numChars_);\n\n        for (uint256 _i = 0; _i < _result.length; _i++) {\n            if (_i < strBytes_.length) {\n                _result[_i] = strBytes_[_i];\n            } else {\n                _result[_i] = \"0\";\n            }\n        }\n\n        return _result;\n    }\n\n    function shiftStringLeft(string memory str_, uint256 numChars_) public pure returns (string memory) {\n        return string(shiftStringBytesLeft(bytes(str_), numChars_));\n    }\n\n    function shiftStringBytesRight(bytes memory strBytes_, uint256 numChars_)\n        public\n        pure\n        returns (bytes memory _result, bytes memory _remainder)\n    {\n        uint256 _resultChars;\n        uint256 _remainderChars;\n        uint256 _excessChars;\n        if (numChars_ > strBytes_.length) {\n            _resultChars = 0;\n            _excessChars = numChars_ - strBytes_.length;\n            _result = new bytes(1);\n        } else {\n            _resultChars = strBytes_.length - numChars_;\n            _result = new bytes(_resultChars);\n        }\n        _remainderChars = numChars_;\n        _remainder = new bytes(_remainderChars);\n\n        for (uint256 _i = 0; _i < strBytes_.length; _i++) {\n            if (_i < _resultChars) {\n                _result[_i] = strBytes_[_i];\n            } else {\n                _remainder[_remainderChars - 1 + _resultChars - _i] =\n                    strBytes_[strBytes_.length - 1 + _resultChars - _i];\n            }\n        }\n\n        return (_result, _remainder);\n    }\n\n    function shiftStringRight(string memory str_, uint256 numChars_)\n        public\n        pure\n        returns (string memory _result, string memory _remainder)\n    {\n        bytes memory _strBytes = bytes(str_);\n        bytes memory _resultBytes;\n        bytes memory _remainderBytes;\n        (_resultBytes, _remainderBytes) = shiftStringBytesRight(_strBytes, numChars_);\n        _result = string(_resultBytes);\n        _remainder = string(_remainderBytes);\n    }\n\n    function toStringBytes(uint256 value_) public pure returns (bytes memory) {\n        // Handle the special case of zero.\n        if (value_ == 0) {\n            return bytes(\"0\");\n        }\n\n        // Determine the length of the decimal number.\n        uint256 _digits = digits(value_);\n\n        // Create a temporary byte array to fill with the digits of the number.\n        bytes memory _buffer = new bytes(_digits);\n        while (value_ != 0) {\n            _digits -= 1;\n            _buffer[_digits] = bytes1(uint8(48 + (value_ % 10)));\n            value_ /= 10;\n        }\n\n        // Convert the byte array to a string and return it.\n        return _buffer;\n    }\n\n    function toStringBytes(Float value_) internal pure returns (bytes memory, bytes memory) {\n        (int256 _mantissa, ) = FloatLib.components(value_);\n        if (_mantissa == 0) {\n            return (bytes(\"0\"), bytes(\"0\"));\n        }\n\n        Float _integerPartFloat = FloatLib.integerPart(value_);\n        bytes memory _integerPartBytes;\n\n        (int256 _intMantissa, int256 _intExponent) = FloatLib.components(_integerPartFloat);\n        if (_intMantissa == 0) {\n            _integerPartBytes = bytes(\"0\");\n        } else {\n            bytes memory _integerPartMantissaBytes =\n                toStringBytes(uint256(_intMantissa >= 0 ? _intMantissa : -_intMantissa));\n\n            _integerPartBytes = new bytes(_integerPartMantissaBytes.length + uint256(_intExponent));\n\n            for (uint256 _i = 0; _i < _integerPartBytes.length; _i++) {\n                if (_i < _integerPartMantissaBytes.length) {\n                    _integerPartBytes[_i] = _integerPartMantissaBytes[_i];\n                } else {\n                    _integerPartBytes[_i] = bytes1(\"0\");\n                }\n            }\n        }\n\n        Float _fractionalPartFloat;\n        if (_intMantissa == 0) {\n            _fractionalPartFloat = value_;\n        } else {\n            _fractionalPartFloat = FloatLib.minus(value_, _integerPartFloat);\n        }\n\n        bytes memory _fractionalPartBytes;\n        (int256 _fracMantissa, int256 _fracExponent) = FloatLib.components(_fractionalPartFloat);\n        if (_fracMantissa == 0) {\n            _fractionalPartBytes = bytes(\"0\");\n        } else {\n            bytes memory _fractionalPartMantissaBytes =\n                toStringBytes(uint256(_fracMantissa >= 0 ? _fracMantissa : -_fracMantissa));\n\n            _fractionalPartBytes = new bytes(uint256(-_fracExponent));\n\n            for (uint256 _i = 0; _i < _fractionalPartBytes.length; _i++) {\n                if (_i < _fractionalPartMantissaBytes.length) {\n                    _fractionalPartBytes[_fractionalPartBytes.length - 1 - _i] =\n                        _fractionalPartMantissaBytes[_fractionalPartMantissaBytes.length - 1 - _i];\n                } else {\n                    _fractionalPartBytes[_fractionalPartBytes.length - 1 - _i] = bytes1(\"0\");\n                }\n            }\n        }\n\n        return (_integerPartBytes, _fractionalPartBytes);\n    }\n\n    function toString(uint256 value_) public pure returns (string memory) {\n        return string(toStringBytes(value_));\n    }\n\n    function toString(int256 value_) public pure returns (string memory) {\n        return string(abi.encodePacked(value_ < 0 ? \"-\" : \"\", toStringBytes(value_.abs())));\n    }\n\n    function trimStringBytesRight(bytes memory strBytes_) public pure returns (bytes memory) {\n        uint256 _i = strBytes_.length - 1;\n        while (_i > 0 && strBytes_[_i] == \"0\") {\n            _i--;\n        }\n        bytes memory _result = new bytes(_i + 1);\n        for (uint256 _j = 0; _j < _i + 1; _j++) {\n            _result[_j] = strBytes_[_j];\n        }\n        return _result;\n    }\n\n    function trimStringRight(string memory str_) public pure returns (string memory) {\n        return string(trimStringBytesRight(bytes(str_)));\n    }\n\n    function toString(Float number_) internal pure returns (string memory) {\n        bytes memory _integerPartBytes;\n        bytes memory _fractionalPartBytes;\n\n        number_ = FloatLib.normalize(number_);\n\n        Float _max = FloatLib.normalize(int256(FloatLib.NORMALIZED_MANTISSA_MAX), 0);\n\n        uint256 _ushift = FloatLib.SIGNIFICANT_DIGITS - 1;\n        int256 _ishift = int256(_ushift);\n\n        (int256 _mantissa, int256 _exponent) = FloatLib.components(number_);\n        if (FloatLib.abs(number_).isLT(_max) && _exponent >= -_ishift) {\n            (_integerPartBytes, _fractionalPartBytes) = toStringBytes(number_);\n            return string(\n                abi.encodePacked(\n                    _mantissa < 0 ? \"-\" : \"\",\n                    string(_integerPartBytes),\n                    \".\",\n                    string(trimStringBytesRight(_fractionalPartBytes))\n                )\n            );\n        } else {\n            (_integerPartBytes, _fractionalPartBytes) = toStringBytes(FloatLib.normalize(_mantissa, -_ishift));\n            return string(\n                abi.encodePacked(\n                    _mantissa < 0 ? \"-\" : \"\",\n                    string(_integerPartBytes),\n                    \".\",\n                    string(trimStringBytesRight(_fractionalPartBytes)),\n                    \"e\",\n                    toString(_exponent + _ishift)\n                )\n            );\n        }\n    }\n\n    function digits(uint256 number_) public pure returns (uint8) {\n        if (number_ == 0) {\n            return 1; // Zero has 1 significant digit\n        }\n\n        uint8 count = 0;\n        while (number_ != 0) {\n            count++;\n            number_ /= 10; // Remove the least significant digit\n        }\n        return count;\n    }\n}\n"
    },
    "/Users/williamcory/cavalre-contracts/node_modules/solady/src/utils/FixedPointMathLib.sol": {
      "id": "/Users/williamcory/cavalre-contracts/node_modules/solady/src/utils/FixedPointMathLib.sol",
      "rawCode": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error ExpOverflow();\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error FactorialOverflow();\n\n    /// @dev The operation failed, due to an overflow.\n    error RPowOverflow();\n\n    /// @dev The mantissa is too big to fit.\n    error MantissaOverflow();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error MulWadFailed();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error SMulWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error DivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error SDivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error MulDivFailed();\n\n    /// @dev The division failed, as the denominator is zero.\n    error DivFailed();\n\n    /// @dev The full precision multiply-divide operation failed, either due\n    /// to the result being larger than 256 bits, or a division by a zero.\n    error FullMulDivFailed();\n\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\n    error LnWadUndefined();\n\n    /// @dev The input outside the acceptable domain.\n    error OutOfDomain();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The scalar of ETH and most ERC20s.\n    uint256 internal constant WAD = 1e18;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if gt(x, div(not(0), y)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function sMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require((x == 0 || z / x == y) && !(x == -1 && y == type(int256).min))`.\n            if iszero(gt(or(iszero(x), eq(sdiv(z, x), y)), lt(not(x), eq(y, shl(255, 1))))) {\n                mstore(0x00, 0xedcd4dd4) // `SMulWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawMulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawSMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if iszero(eq(div(z, y), x)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := add(iszero(iszero(mod(z, WAD))), div(z, WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up, but without overflow checks.\n    function rawMulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function sDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, WAD)\n            // Equivalent to `require(y != 0 && ((x * WAD) / WAD == x))`.\n            if iszero(mul(y, eq(sdiv(z, WAD), x))) {\n                mstore(0x00, 0x5c43740d) // `SDivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawDivWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawSDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up, but without overflow and divide by zero checks.\n    function rawDivWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `x` to the power of `y`.\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\n    /// Note: This function is an approximation.\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Using `ln(x)` means `x` must be greater than 0.\n        return expWad((lnWad(x) * y) / int256(WAD));\n    }\n\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is less than 0.5 we return zero.\n            // This happens when `x <= (log(1e-18) * 1e18) ~ -4.15e19`.\n            if (x <= -41446531673892822313) return r;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // When the result is greater than `(2**255 - 1) / 1e18` we can not represent it as\n                // an int. This happens when `x >= floor(log((2**255 - 1) / 1e18) * 1e18) ≈ 135`.\n                if iszero(slt(x, 135305999368893231589)) {\n                    mstore(0x00, 0xa37bfec9) // `ExpOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            // `x` is now in the range `(-42, 136) * 1e18`. Convert to `(-42, 136) * 2**96`\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5 ** 18;\n\n            // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // `k` is in the range `[-61, 195]`.\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // `p` is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already `2**96` too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range `(0.09, 0.25) * 2**96`.\n\n            // We now need to multiply r by:\n            // - The scale factor `s ≈ 6.031367120`.\n            // - The `2**k` factor from the range reduction.\n            // - The `1e18 / 2**96` factor for base conversion.\n            // We do this all at once, with an intermediate result in `2**213`\n            // basis, so the final right shift is always by a positive amount.\n            r = int256(\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\n            );\n        }\n    }\n\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We want to convert `x` from `10**18` fixed point to `2**96` fixed point.\n            // We do this by multiplying by `2**96 / 10**18`. But since\n            // `ln(x * C) = ln(x) + ln(C)`, we can simply do nothing here\n            // and add `ln(2**96 / 10**18)` at the end.\n\n            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // We place the check here for more optimal stack operations.\n            if iszero(sgt(x, 0)) {\n                mstore(0x00, 0x1615e638) // `LnWadUndefined()`.\n                revert(0x1c, 0x04)\n            }\n            // forgefmt: disable-next-item\n            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            x := shr(159, shl(r, x))\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // `p` is made monic, we will multiply by a scale factor later.\n            // forgefmt: disable-next-item\n            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.\n                sar(96, mul(add(43456485725739037958740375743393,\n                sar(96, mul(add(24828157081833163892658089445524,\n                sar(96, mul(add(3273285459638523848632254066296,\n                    x), x))), x))), x)), 11111509109440967052023855526967)\n            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)\n            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)\n            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n\n            // `q` is monic by convention.\n            let q := add(5573035233440673466300451813936, x)\n            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))\n            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))\n            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))\n            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))\n            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))\n            q := add(909429971244387300277376558375, sar(96, mul(x, q)))\n\n            // `p / q` is in the range `(0, 0.125) * 2**96`.\n\n            // Finalization, we need to:\n            // - Multiply by the scale factor `s = 5.549…`.\n            // - Add `ln(2**96 / 10**18)`.\n            // - Add `k * ln(2)`.\n            // - Multiply by `10**18 / 2**96 = 5**18 >> 78`.\n\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already `2**96` too large.\n            p := sdiv(p, q)\n            // Multiply by the scaling factor: `s * 5**18 * 2**96`, base is now `5**18 * 2**192`.\n            p := mul(1677202110996718588342820967067443963516166, p)\n            // Add `ln(2) * k * 5**18 * 2**192`.\n            // forgefmt: disable-next-item\n            p := add(mul(16597577552685614221487285958193947469193820559219878177908093499208371, sub(159, r)), p)\n            // Add `ln(2**96 / 10**18) * 5**18 * 2**192`.\n            p := add(600920179829731861736702779321621459595472258049074101567377883020018308, p)\n            // Base conversion: mul `2**18 / 2**192`.\n            r := sar(174, p)\n        }\n    }\n\n    /// @dev Returns `W_0(x)`, denominated in `WAD`.\n    /// See: https://en.wikipedia.org/wiki/Lambert_W_function\n    /// a.k.a. Product log function. This is an approximation of the principal branch.\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lambertW0Wad(int256 x) internal pure returns (int256 w) {\n        // forgefmt: disable-next-item\n        unchecked {\n            if ((w = x) <= -367879441171442322) revert OutOfDomain(); // `x` less than `-1/e`.\n            (int256 wad, int256 p) = (int256(WAD), x);\n            uint256 c; // Whether we need to avoid catastrophic cancellation.\n            uint256 i = 4; // Number of iterations.\n            if (w <= 0x1ffffffffffff) {\n                if (-0x4000000000000 <= w) {\n                    i = 1; // Inputs near zero only take one step to converge.\n                } else if (w <= -0x3ffffffffffffff) {\n                    i = 32; // Inputs near `-1/e` take very long to converge.\n                }\n            } else if (uint256(w >> 63) == uint256(0)) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // Inline log2 for more performance, since the range is small.\n                    let v := shr(49, w)\n                    let l := shl(3, lt(0xff, v))\n                    l := add(or(l, byte(and(0x1f, shr(shr(l, v), 0x8421084210842108cc6318c6db6d54be)),\n                        0x0706060506020504060203020504030106050205030304010505030400000000)), 49)\n                    w := sdiv(shl(l, 7), byte(sub(l, 31), 0x0303030303030303040506080c13))\n                    c := gt(l, 60)\n                    i := add(2, add(gt(l, 53), c))\n                }\n            } else {\n                int256 ll = lnWad(w = lnWad(w));\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // `w = ln(x) - ln(ln(x)) + b * ln(ln(x)) / ln(x)`.\n                    w := add(sdiv(mul(ll, 1023715080943847266), w), sub(w, ll))\n                    i := add(3, iszero(shr(68, x)))\n                    c := iszero(shr(143, x))\n                }\n                if (c == uint256(0)) {\n                    do { // If `x` is big, use Newton's so that intermediate values won't overflow.\n                        int256 e = expWad(w);\n                        /// @solidity memory-safe-assembly\n                        assembly {\n                            let t := mul(w, div(e, wad))\n                            w := sub(w, sdiv(sub(t, x), div(add(e, t), wad)))\n                        }\n                        if (p <= w) break;\n                        p = w;\n                    } while (--i != uint256(0));\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        w := sub(w, sgt(w, 2))\n                    }\n                    return w;\n                }\n            }\n            do { // Otherwise, use Halley's for faster convergence.\n                int256 e = expWad(w);\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let t := add(w, wad)\n                    let s := sub(mul(w, e), mul(x, wad))\n                    w := sub(w, sdiv(mul(s, wad), sub(mul(e, t), sdiv(mul(add(t, wad), s), add(t, t)))))\n                }\n                if (p <= w) break;\n                p = w;\n            } while (--i != c);\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sub(w, sgt(w, 2))\n            }\n            // For certain ranges of `x`, we'll use the quadratic-rate recursive formula of\n            // R. Iacono and J.P. Boyd for the last iteration, to avoid catastrophic cancellation.\n            if (c == uint256(0)) return w;\n            int256 t = w | 1;\n            /// @solidity memory-safe-assembly\n            assembly {\n                x := sdiv(mul(x, wad), t)\n            }\n            x = (t * (wad + lnWad(x)));\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sdiv(x, add(wad, t))\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  GENERAL NUMBER UTILITIES                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `a * b == x * y`, with full precision.\n    function fullMulEq(uint256 a, uint256 b, uint256 x, uint256 y)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(mul(a, b), mul(x, y)), eq(mulmod(x, y, not(0)), mulmod(a, b, not(0))))\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/21/muldiv\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // 512-bit multiply `[p1 p0] = x * y`.\n            // Compute the product mod `2**256` and mod `2**256 - 1`\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that `product = p1 * 2**256 + p0`.\n\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`.\n            for {} 1 {} {\n                // If overflows.\n                if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n\n                    /*------------------- 512 by 256 division --------------------*/\n\n                    // Make division exact by subtracting the remainder from `[p1 p0]`.\n                    let r := mulmod(x, y, d) // Compute remainder using mulmod.\n                    let t := and(d, sub(0, d)) // The least significant bit of `d`. `t >= 1`.\n                    // Make sure `z` is less than `2**256`. Also prevents `d == 0`.\n                    // Placing the check here seems to give more optimal stack operations.\n                    if iszero(gt(d, p1)) {\n                        mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    d := div(d, t) // Divide `d` by `t`, which is a power of two.\n                    // Invert `d mod 2**256`\n                    // Now that `d` is an odd number, it has an inverse\n                    // modulo `2**256` such that `d * inv = 1 mod 2**256`.\n                    // Compute the inverse by starting with a seed that is correct\n                    // correct for four bits. That is, `d * inv = 1 mod 2**4`.\n                    let inv := xor(2, mul(3, d))\n                    // Now use Newton-Raphson iteration to improve the precision.\n                    // Thanks to Hensel's lifting lemma, this also works in modular\n                    // arithmetic, doubling the correct bits in each step.\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\n                    z :=\n                        mul(\n                            // Divide [p1 p0] by the factors of two.\n                            // Shift in bits from `p1` into `p0`. For this we need\n                            // to flip `t` such that it is `2**256 / t`.\n                            or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                            mul(sub(2, mul(d, inv)), inv) // inverse mod 2**256\n                        )\n                    break\n                }\n                z := div(z, d)\n                break\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Behavior is undefined if `d` is zero or the final result cannot fit in 256 bits.\n    /// Performs the full 512 bit calculation regardless.\n    function fullMulDivUnchecked(uint256 x, uint256 y, uint256 d)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            let mm := mulmod(x, y, not(0))\n            let p1 := sub(mm, add(z, lt(mm, z)))\n            let t := and(d, sub(0, d))\n            let r := mulmod(x, y, d)\n            d := div(d, t)\n            let inv := xor(2, mul(3, d))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            z :=\n                mul(\n                    or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                    mul(sub(2, mul(d, inv)), inv)\n                )\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Uniswap-v3-core under MIT license:\n    /// https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        z = fullMulDiv(x, y, d);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mulmod(x, y, d) {\n                z := add(z, 1)\n                if iszero(z) {\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / 2 ** n)` with full precision.\n    /// Throws if result overflows a uint256.\n    /// Credit to Philogy under MIT license:\n    /// https://github.com/SorellaLabs/angstrom/blob/main/contracts/src/libraries/X128MathLib.sol\n    function fullMulDivN(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`. We'll call this `z`.\n            for {} 1 {} {\n                if iszero(or(iszero(x), eq(div(z, x), y))) {\n                    let k := and(n, 0xff) // `n`, cleaned.\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n                    //         |      p1     |      z     |\n                    // Before: | p1_0 ¦ p1_1 | z_0  ¦ z_1 |\n                    // Final:  |   0  ¦ p1_0 | p1_1 ¦ z_0 |\n                    // Check that final `z` doesn't overflow by checking that p1_0 = 0.\n                    if iszero(shr(k, p1)) {\n                        z := add(shl(sub(256, k), p1), shr(k, z))\n                        break\n                    }\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                z := shr(and(n, 0xff), z)\n                break\n            }\n        }\n    }\n\n    /// @dev Returns `floor(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(z, d)\n        }\n    }\n\n    /// @dev Returns `ceil(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(z, d))), div(z, d))\n        }\n    }\n\n    /// @dev Returns `x`, the modular multiplicative inverse of `a`, such that `(a * x) % n == 1`.\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256 x) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let g := n\n            let r := mod(a, n)\n            for { let y := 1 } 1 {} {\n                let q := div(g, r)\n                let t := g\n                g := r\n                r := sub(t, mul(r, q))\n                let u := x\n                x := y\n                y := sub(u, mul(y, q))\n                if iszero(r) { break }\n            }\n            x := mul(eq(g, 1), add(x, mul(slt(x, 0), n)))\n        }\n    }\n\n    /// @dev Returns `ceil(x / d)`.\n    /// Reverts if `d` is zero.\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(d) {\n                mstore(0x00, 0x65244e4e) // `DivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`. Alias for `saturatingSub`.\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`.\n    function saturatingSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Returns `min(2 ** 256 - 1, x + y)`.\n    function saturatingAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(sub(0, lt(add(x, y), x)), add(x, y))\n        }\n    }\n\n    /// @dev Returns `min(2 ** 256 - 1, x * y)`.\n    function saturatingMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(sub(or(iszero(x), eq(div(mul(x, y), x), y)), 1), mul(x, y))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, address x, address y) internal pure returns (address z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `x != 0 ? x : y`, without branching.\n    function coalesce(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, mul(y, iszero(x)))\n        }\n    }\n\n    /// @dev Returns `x != bytes32(0) ? x : y`, without branching.\n    function coalesce(bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, mul(y, iszero(x)))\n        }\n    }\n\n    /// @dev Returns `x != address(0) ? x : y`, without branching.\n    function coalesce(address x, address y) internal pure returns (address z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, mul(y, iszero(shl(96, x))))\n        }\n    }\n\n    /// @dev Exponentiate `x` to `y` by squaring, denominated in base `b`.\n    /// Reverts if the computation overflows.\n    function rpow(uint256 x, uint256 y, uint256 b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(b, iszero(y)) // `0 ** 0 = 1`. Otherwise, `0 ** n = 0`.\n            if x {\n                z := xor(b, mul(xor(b, x), and(y, 1))) // `z = isEven(y) ? scale : x`\n                let half := shr(1, b) // Divide `b` by 2.\n                // Divide `y` by 2 every iteration.\n                for { y := shr(1, y) } y { y := shr(1, y) } {\n                    let xx := mul(x, x) // Store x squared.\n                    let xxRound := add(xx, half) // Round to the nearest number.\n                    // Revert if `xx + half` overflowed, or if `x ** 2` overflows.\n                    if or(lt(xxRound, xx), shr(128, x)) {\n                        mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                        revert(0x1c, 0x04)\n                    }\n                    x := div(xxRound, b) // Set `x` to scaled `xxRound`.\n                    // If `y` is odd:\n                    if and(y, 1) {\n                        let zx := mul(z, x) // Compute `z * x`.\n                        let zxRound := add(zx, half) // Round to the nearest number.\n                        // If `z * x` overflowed or `zx + half` overflowed:\n                        if or(xor(div(zx, x), z), lt(zxRound, zx)) {\n                            // Revert if `x` is non-zero.\n                            if x {\n                                mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                                revert(0x1c, 0x04)\n                            }\n                        }\n                        z := div(zxRound, b) // Return properly scaled `zxRound`.\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the square root of `x`, rounded down.\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // Let `y = x / 2**r`. We check `y >= 2**(k + 8)`\n            // but shift right by `k` bits to ensure that if `x >= 256`, then `y >= 256`.\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\n            z := shl(shr(1, r), z)\n\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\n\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\n\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\n\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\n            // Then we can estimate `sqrt(y)` using\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\n\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If `x+1` is a perfect square, the Babylonian method cycles between\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, rounded down.\n    /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:\n    /// https://github.com/pcaversaccio/snekmate/blob/main/src/snekmate/utils/math.vy\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // Makeshift lookup table to nudge the approximate log2 result.\n            z := div(shl(div(r, 3), shl(lt(0xf, shr(r, x)), 0xf)), xor(7, mod(r, 3)))\n            // Newton-Raphson's.\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            // Round down.\n            z := sub(z, lt(div(x, mul(z, z)), z))\n        }\n    }\n\n    /// @dev Returns the square root of `x`, denominated in `WAD`, rounded down.\n    function sqrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 18) return sqrt(x * 10 ** 18);\n            z = (1 + sqrt(x)) * 10 ** 9;\n            z = (fullMulDivUnchecked(x, 10 ** 18, z) + z) >> 1;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sub(z, gt(999999999999999999, sub(mulmod(z, z, x), 1))) // Round down.\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, denominated in `WAD`, rounded down.\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 36) return cbrt(x * 10 ** 36);\n            z = (1 + cbrt(x)) * 10 ** 12;\n            z = (fullMulDivUnchecked(x, 10 ** 36, z * z) + z + z) / 3;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let p := x\n            for {} 1 {} {\n                if iszero(shr(229, p)) {\n                    if iszero(shr(199, p)) {\n                        p := mul(p, 100000000000000000) // 10 ** 17.\n                        break\n                    }\n                    p := mul(p, 100000000) // 10 ** 8.\n                    break\n                }\n                if iszero(shr(249, p)) { p := mul(p, 100) }\n                break\n            }\n            let t := mulmod(mul(z, z), z, p)\n            z := sub(z, gt(lt(t, shr(1, p)), iszero(t))) // Round down.\n        }\n    }\n\n    /// @dev Returns the factorial of `x`.\n    function factorial(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := 1\n            if iszero(lt(x, 58)) {\n                mstore(0x00, 0xaba0f2a2) // `FactorialOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            for {} x { x := sub(x, 1) } { z := mul(z, x) }\n        }\n    }\n\n    /// @dev Returns the log2 of `x`.\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\n    /// Returns 0 if `x` is zero.\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020504060203020504030106050205030304010505030400000000))\n        }\n    }\n\n    /// @dev Returns the log2 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\n        r = log2(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(r, 1), x))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log10(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, 100000000000000000000000000000000000000)) {\n                x := div(x, 100000000000000000000000000000000000000)\n                r := 38\n            }\n            if iszero(lt(x, 100000000000000000000)) {\n                x := div(x, 100000000000000000000)\n                r := add(r, 20)\n            }\n            if iszero(lt(x, 10000000000)) {\n                x := div(x, 10000000000)\n                r := add(r, 10)\n            }\n            if iszero(lt(x, 100000)) {\n                x := div(x, 100000)\n                r := add(r, 5)\n            }\n            r := add(r, add(gt(x, 9), add(gt(x, 99), add(gt(x, 999), gt(x, 9999)))))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log10Up(uint256 x) internal pure returns (uint256 r) {\n        r = log10(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(exp(10, r), x))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(shr(3, r), lt(0xff, shr(r, x)))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log256Up(uint256 x) internal pure returns (uint256 r) {\n        r = log256(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(shl(3, r), 1), x))\n        }\n    }\n\n    /// @dev Returns the scientific notation format `mantissa * 10 ** exponent` of `x`.\n    /// Useful for compressing prices (e.g. using 25 bit mantissa and 7 bit exponent).\n    function sci(uint256 x) internal pure returns (uint256 mantissa, uint256 exponent) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mantissa := x\n            if mantissa {\n                if iszero(mod(mantissa, 1000000000000000000000000000000000)) {\n                    mantissa := div(mantissa, 1000000000000000000000000000000000)\n                    exponent := 33\n                }\n                if iszero(mod(mantissa, 10000000000000000000)) {\n                    mantissa := div(mantissa, 10000000000000000000)\n                    exponent := add(exponent, 19)\n                }\n                if iszero(mod(mantissa, 1000000000000)) {\n                    mantissa := div(mantissa, 1000000000000)\n                    exponent := add(exponent, 12)\n                }\n                if iszero(mod(mantissa, 1000000)) {\n                    mantissa := div(mantissa, 1000000)\n                    exponent := add(exponent, 6)\n                }\n                if iszero(mod(mantissa, 10000)) {\n                    mantissa := div(mantissa, 10000)\n                    exponent := add(exponent, 4)\n                }\n                if iszero(mod(mantissa, 100)) {\n                    mantissa := div(mantissa, 100)\n                    exponent := add(exponent, 2)\n                }\n                if iszero(mod(mantissa, 10)) {\n                    mantissa := div(mantissa, 10)\n                    exponent := add(exponent, 1)\n                }\n            }\n        }\n    }\n\n    /// @dev Convenience function for packing `x` into a smaller number using `sci`.\n    /// The `mantissa` will be in bits [7..255] (the upper 249 bits).\n    /// The `exponent` will be in bits [0..6] (the lower 7 bits).\n    /// Use `SafeCastLib` to safely ensure that the `packed` number is small\n    /// enough to fit in the desired unsigned integer type:\n    /// ```\n    ///     uint32 packed = SafeCastLib.toUint32(FixedPointMathLib.packSci(777 ether));\n    /// ```\n    function packSci(uint256 x) internal pure returns (uint256 packed) {\n        (x, packed) = sci(x); // Reuse for `mantissa` and `exponent`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            if shr(249, x) {\n                mstore(0x00, 0xce30380c) // `MantissaOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            packed := or(shl(7, x), packed)\n        }\n    }\n\n    /// @dev Convenience function for unpacking a packed number from `packSci`.\n    function unpackSci(uint256 packed) internal pure returns (uint256 unpacked) {\n        unchecked {\n            unpacked = (packed >> 7) * 10 ** (packed & 0x7f);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards zero.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = (x & y) + ((x ^ y) >> 1);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards negative infinity.\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @dev Returns the absolute value of `x`.\n    function abs(int256 x) internal pure returns (uint256 z) {\n        unchecked {\n            z = (uint256(x) + uint256(x >> 255)) ^ uint256(x >> 255);\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, gt(x, y)), sub(y, x)), gt(x, y))\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, sgt(x, y)), sub(y, x)), sgt(x, y))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), lt(y, x)))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), slt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), gt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), gt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), lt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), sgt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), slt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns greatest common divisor of `x` and `y`.\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { z := x } y {} {\n                let t := y\n                y := mod(z, y)\n                z := t\n            }\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`,\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(uint256 a, uint256 b, uint256 t, uint256 begin, uint256 end)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        unchecked {\n            if (b >= a) return a + fullMulDiv(b - a, t - begin, end - begin);\n            return a - fullMulDiv(a - b, t - begin, end - begin);\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`.\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(int256 a, int256 b, int256 t, int256 begin, int256 end)\n        internal\n        pure\n        returns (int256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        // forgefmt: disable-next-item\n        unchecked {\n            if (b >= a) return int256(uint256(a) + fullMulDiv(uint256(b - a),\n                uint256(t - begin), uint256(end - begin)));\n            return int256(uint256(a) - fullMulDiv(uint256(a - b),\n                uint256(t - begin), uint256(end - begin)));\n        }\n    }\n\n    /// @dev Returns if `x` is an even number. Some people may need this.\n    function isEven(uint256 x) internal pure returns (bool) {\n        return x & uint256(1) == uint256(0);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   RAW NUMBER OPERATIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(x, y)\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mod(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := smod(x, y)\n        }\n    }\n\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := addmod(x, y, d)\n        }\n    }\n\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mulmod(x, y, d)\n        }\n    }\n}\n",
      "importedIds": [],
      "code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error ExpOverflow();\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error FactorialOverflow();\n\n    /// @dev The operation failed, due to an overflow.\n    error RPowOverflow();\n\n    /// @dev The mantissa is too big to fit.\n    error MantissaOverflow();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error MulWadFailed();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error SMulWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error DivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error SDivWadFailed();\n\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\n    error MulDivFailed();\n\n    /// @dev The division failed, as the denominator is zero.\n    error DivFailed();\n\n    /// @dev The full precision multiply-divide operation failed, either due\n    /// to the result being larger than 256 bits, or a division by a zero.\n    error FullMulDivFailed();\n\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\n    error LnWadUndefined();\n\n    /// @dev The input outside the acceptable domain.\n    error OutOfDomain();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The scalar of ETH and most ERC20s.\n    uint256 internal constant WAD = 1e18;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if gt(x, div(not(0), y)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function sMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require((x == 0 || z / x == y) && !(x == -1 && y == type(int256).min))`.\n            if iszero(gt(or(iszero(x), eq(sdiv(z, x), y)), lt(not(x), eq(y, shl(255, 1))))) {\n                mstore(0x00, 0xedcd4dd4) // `SMulWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawMulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\n    function rawSMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if iszero(eq(div(z, y), x)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := add(iszero(iszero(mod(z, WAD))), div(z, WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up, but without overflow checks.\n    function rawMulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function sDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, WAD)\n            // Equivalent to `require(y != 0 && ((x * WAD) / WAD == x))`.\n            if iszero(mul(y, eq(sdiv(z, WAD), x))) {\n                mstore(0x00, 0x5c43740d) // `SDivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawDivWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\n    function rawSDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up, but without overflow and divide by zero checks.\n    function rawDivWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `x` to the power of `y`.\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\n    /// Note: This function is an approximation.\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Using `ln(x)` means `x` must be greater than 0.\n        return expWad((lnWad(x) * y) / int256(WAD));\n    }\n\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is less than 0.5 we return zero.\n            // This happens when `x <= (log(1e-18) * 1e18) ~ -4.15e19`.\n            if (x <= -41446531673892822313) return r;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // When the result is greater than `(2**255 - 1) / 1e18` we can not represent it as\n                // an int. This happens when `x >= floor(log((2**255 - 1) / 1e18) * 1e18) ≈ 135`.\n                if iszero(slt(x, 135305999368893231589)) {\n                    mstore(0x00, 0xa37bfec9) // `ExpOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            // `x` is now in the range `(-42, 136) * 1e18`. Convert to `(-42, 136) * 2**96`\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5 ** 18;\n\n            // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // `k` is in the range `[-61, 195]`.\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // `p` is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already `2**96` too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range `(0.09, 0.25) * 2**96`.\n\n            // We now need to multiply r by:\n            // - The scale factor `s ≈ 6.031367120`.\n            // - The `2**k` factor from the range reduction.\n            // - The `1e18 / 2**96` factor for base conversion.\n            // We do this all at once, with an intermediate result in `2**213`\n            // basis, so the final right shift is always by a positive amount.\n            r = int256(\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\n            );\n        }\n    }\n\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/22/exp-ln\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We want to convert `x` from `10**18` fixed point to `2**96` fixed point.\n            // We do this by multiplying by `2**96 / 10**18`. But since\n            // `ln(x * C) = ln(x) + ln(C)`, we can simply do nothing here\n            // and add `ln(2**96 / 10**18)` at the end.\n\n            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // We place the check here for more optimal stack operations.\n            if iszero(sgt(x, 0)) {\n                mstore(0x00, 0x1615e638) // `LnWadUndefined()`.\n                revert(0x1c, 0x04)\n            }\n            // forgefmt: disable-next-item\n            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            x := shr(159, shl(r, x))\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // `p` is made monic, we will multiply by a scale factor later.\n            // forgefmt: disable-next-item\n            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.\n                sar(96, mul(add(43456485725739037958740375743393,\n                sar(96, mul(add(24828157081833163892658089445524,\n                sar(96, mul(add(3273285459638523848632254066296,\n                    x), x))), x))), x)), 11111509109440967052023855526967)\n            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)\n            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)\n            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n\n            // `q` is monic by convention.\n            let q := add(5573035233440673466300451813936, x)\n            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))\n            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))\n            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))\n            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))\n            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))\n            q := add(909429971244387300277376558375, sar(96, mul(x, q)))\n\n            // `p / q` is in the range `(0, 0.125) * 2**96`.\n\n            // Finalization, we need to:\n            // - Multiply by the scale factor `s = 5.549…`.\n            // - Add `ln(2**96 / 10**18)`.\n            // - Add `k * ln(2)`.\n            // - Multiply by `10**18 / 2**96 = 5**18 >> 78`.\n\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already `2**96` too large.\n            p := sdiv(p, q)\n            // Multiply by the scaling factor: `s * 5**18 * 2**96`, base is now `5**18 * 2**192`.\n            p := mul(1677202110996718588342820967067443963516166, p)\n            // Add `ln(2) * k * 5**18 * 2**192`.\n            // forgefmt: disable-next-item\n            p := add(mul(16597577552685614221487285958193947469193820559219878177908093499208371, sub(159, r)), p)\n            // Add `ln(2**96 / 10**18) * 5**18 * 2**192`.\n            p := add(600920179829731861736702779321621459595472258049074101567377883020018308, p)\n            // Base conversion: mul `2**18 / 2**192`.\n            r := sar(174, p)\n        }\n    }\n\n    /// @dev Returns `W_0(x)`, denominated in `WAD`.\n    /// See: https://en.wikipedia.org/wiki/Lambert_W_function\n    /// a.k.a. Product log function. This is an approximation of the principal branch.\n    /// Note: This function is an approximation. Monotonically increasing.\n    function lambertW0Wad(int256 x) internal pure returns (int256 w) {\n        // forgefmt: disable-next-item\n        unchecked {\n            if ((w = x) <= -367879441171442322) revert OutOfDomain(); // `x` less than `-1/e`.\n            (int256 wad, int256 p) = (int256(WAD), x);\n            uint256 c; // Whether we need to avoid catastrophic cancellation.\n            uint256 i = 4; // Number of iterations.\n            if (w <= 0x1ffffffffffff) {\n                if (-0x4000000000000 <= w) {\n                    i = 1; // Inputs near zero only take one step to converge.\n                } else if (w <= -0x3ffffffffffffff) {\n                    i = 32; // Inputs near `-1/e` take very long to converge.\n                }\n            } else if (uint256(w >> 63) == uint256(0)) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // Inline log2 for more performance, since the range is small.\n                    let v := shr(49, w)\n                    let l := shl(3, lt(0xff, v))\n                    l := add(or(l, byte(and(0x1f, shr(shr(l, v), 0x8421084210842108cc6318c6db6d54be)),\n                        0x0706060506020504060203020504030106050205030304010505030400000000)), 49)\n                    w := sdiv(shl(l, 7), byte(sub(l, 31), 0x0303030303030303040506080c13))\n                    c := gt(l, 60)\n                    i := add(2, add(gt(l, 53), c))\n                }\n            } else {\n                int256 ll = lnWad(w = lnWad(w));\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // `w = ln(x) - ln(ln(x)) + b * ln(ln(x)) / ln(x)`.\n                    w := add(sdiv(mul(ll, 1023715080943847266), w), sub(w, ll))\n                    i := add(3, iszero(shr(68, x)))\n                    c := iszero(shr(143, x))\n                }\n                if (c == uint256(0)) {\n                    do { // If `x` is big, use Newton's so that intermediate values won't overflow.\n                        int256 e = expWad(w);\n                        /// @solidity memory-safe-assembly\n                        assembly {\n                            let t := mul(w, div(e, wad))\n                            w := sub(w, sdiv(sub(t, x), div(add(e, t), wad)))\n                        }\n                        if (p <= w) break;\n                        p = w;\n                    } while (--i != uint256(0));\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        w := sub(w, sgt(w, 2))\n                    }\n                    return w;\n                }\n            }\n            do { // Otherwise, use Halley's for faster convergence.\n                int256 e = expWad(w);\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let t := add(w, wad)\n                    let s := sub(mul(w, e), mul(x, wad))\n                    w := sub(w, sdiv(mul(s, wad), sub(mul(e, t), sdiv(mul(add(t, wad), s), add(t, t)))))\n                }\n                if (p <= w) break;\n                p = w;\n            } while (--i != c);\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sub(w, sgt(w, 2))\n            }\n            // For certain ranges of `x`, we'll use the quadratic-rate recursive formula of\n            // R. Iacono and J.P. Boyd for the last iteration, to avoid catastrophic cancellation.\n            if (c == uint256(0)) return w;\n            int256 t = w | 1;\n            /// @solidity memory-safe-assembly\n            assembly {\n                x := sdiv(mul(x, wad), t)\n            }\n            x = (t * (wad + lnWad(x)));\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sdiv(x, add(wad, t))\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  GENERAL NUMBER UTILITIES                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `a * b == x * y`, with full precision.\n    function fullMulEq(uint256 a, uint256 b, uint256 x, uint256 y)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(mul(a, b), mul(x, y)), eq(mulmod(x, y, not(0)), mulmod(a, b, not(0))))\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Remco Bloemen under MIT license: https://2π.com/21/muldiv\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // 512-bit multiply `[p1 p0] = x * y`.\n            // Compute the product mod `2**256` and mod `2**256 - 1`\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that `product = p1 * 2**256 + p0`.\n\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`.\n            for {} 1 {} {\n                // If overflows.\n                if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n\n                    /*------------------- 512 by 256 division --------------------*/\n\n                    // Make division exact by subtracting the remainder from `[p1 p0]`.\n                    let r := mulmod(x, y, d) // Compute remainder using mulmod.\n                    let t := and(d, sub(0, d)) // The least significant bit of `d`. `t >= 1`.\n                    // Make sure `z` is less than `2**256`. Also prevents `d == 0`.\n                    // Placing the check here seems to give more optimal stack operations.\n                    if iszero(gt(d, p1)) {\n                        mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    d := div(d, t) // Divide `d` by `t`, which is a power of two.\n                    // Invert `d mod 2**256`\n                    // Now that `d` is an odd number, it has an inverse\n                    // modulo `2**256` such that `d * inv = 1 mod 2**256`.\n                    // Compute the inverse by starting with a seed that is correct\n                    // correct for four bits. That is, `d * inv = 1 mod 2**4`.\n                    let inv := xor(2, mul(3, d))\n                    // Now use Newton-Raphson iteration to improve the precision.\n                    // Thanks to Hensel's lifting lemma, this also works in modular\n                    // arithmetic, doubling the correct bits in each step.\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\n                    z :=\n                        mul(\n                            // Divide [p1 p0] by the factors of two.\n                            // Shift in bits from `p1` into `p0`. For this we need\n                            // to flip `t` such that it is `2**256 / t`.\n                            or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                            mul(sub(2, mul(d, inv)), inv) // inverse mod 2**256\n                        )\n                    break\n                }\n                z := div(z, d)\n                break\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision.\n    /// Behavior is undefined if `d` is zero or the final result cannot fit in 256 bits.\n    /// Performs the full 512 bit calculation regardless.\n    function fullMulDivUnchecked(uint256 x, uint256 y, uint256 d)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            let mm := mulmod(x, y, not(0))\n            let p1 := sub(mm, add(z, lt(mm, z)))\n            let t := and(d, sub(0, d))\n            let r := mulmod(x, y, d)\n            d := div(d, t)\n            let inv := xor(2, mul(3, d))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            z :=\n                mul(\n                    or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                    mul(sub(2, mul(d, inv)), inv)\n                )\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\n    /// Throws if result overflows a uint256 or when `d` is zero.\n    /// Credit to Uniswap-v3-core under MIT license:\n    /// https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        z = fullMulDiv(x, y, d);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mulmod(x, y, d) {\n                z := add(z, 1)\n                if iszero(z) {\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Calculates `floor(x * y / 2 ** n)` with full precision.\n    /// Throws if result overflows a uint256.\n    /// Credit to Philogy under MIT license:\n    /// https://github.com/SorellaLabs/angstrom/blob/main/contracts/src/libraries/X128MathLib.sol\n    function fullMulDivN(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`. We'll call this `z`.\n            for {} 1 {} {\n                if iszero(or(iszero(x), eq(div(z, x), y))) {\n                    let k := and(n, 0xff) // `n`, cleaned.\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n                    //         |      p1     |      z     |\n                    // Before: | p1_0 ¦ p1_1 | z_0  ¦ z_1 |\n                    // Final:  |   0  ¦ p1_0 | p1_1 ¦ z_0 |\n                    // Check that final `z` doesn't overflow by checking that p1_0 = 0.\n                    if iszero(shr(k, p1)) {\n                        z := add(shl(sub(256, k), p1), shr(k, z))\n                        break\n                    }\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                z := shr(and(n, 0xff), z)\n                break\n            }\n        }\n    }\n\n    /// @dev Returns `floor(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(z, d)\n        }\n    }\n\n    /// @dev Returns `ceil(x * y / d)`.\n    /// Reverts if `x * y` overflows, or `d` is zero.\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(z, d))), div(z, d))\n        }\n    }\n\n    /// @dev Returns `x`, the modular multiplicative inverse of `a`, such that `(a * x) % n == 1`.\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256 x) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let g := n\n            let r := mod(a, n)\n            for { let y := 1 } 1 {} {\n                let q := div(g, r)\n                let t := g\n                g := r\n                r := sub(t, mul(r, q))\n                let u := x\n                x := y\n                y := sub(u, mul(y, q))\n                if iszero(r) { break }\n            }\n            x := mul(eq(g, 1), add(x, mul(slt(x, 0), n)))\n        }\n    }\n\n    /// @dev Returns `ceil(x / d)`.\n    /// Reverts if `d` is zero.\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(d) {\n                mstore(0x00, 0x65244e4e) // `DivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`. Alias for `saturatingSub`.\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`.\n    function saturatingSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Returns `min(2 ** 256 - 1, x + y)`.\n    function saturatingAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(sub(0, lt(add(x, y), x)), add(x, y))\n        }\n    }\n\n    /// @dev Returns `min(2 ** 256 - 1, x * y)`.\n    function saturatingMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(sub(or(iszero(x), eq(div(mul(x, y), x), y)), 1), mul(x, y))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `condition ? x : y`, without branching.\n    function ternary(bool condition, address x, address y) internal pure returns (address z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }\n\n    /// @dev Returns `x != 0 ? x : y`, without branching.\n    function coalesce(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, mul(y, iszero(x)))\n        }\n    }\n\n    /// @dev Returns `x != bytes32(0) ? x : y`, without branching.\n    function coalesce(bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, mul(y, iszero(x)))\n        }\n    }\n\n    /// @dev Returns `x != address(0) ? x : y`, without branching.\n    function coalesce(address x, address y) internal pure returns (address z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, mul(y, iszero(shl(96, x))))\n        }\n    }\n\n    /// @dev Exponentiate `x` to `y` by squaring, denominated in base `b`.\n    /// Reverts if the computation overflows.\n    function rpow(uint256 x, uint256 y, uint256 b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(b, iszero(y)) // `0 ** 0 = 1`. Otherwise, `0 ** n = 0`.\n            if x {\n                z := xor(b, mul(xor(b, x), and(y, 1))) // `z = isEven(y) ? scale : x`\n                let half := shr(1, b) // Divide `b` by 2.\n                // Divide `y` by 2 every iteration.\n                for { y := shr(1, y) } y { y := shr(1, y) } {\n                    let xx := mul(x, x) // Store x squared.\n                    let xxRound := add(xx, half) // Round to the nearest number.\n                    // Revert if `xx + half` overflowed, or if `x ** 2` overflows.\n                    if or(lt(xxRound, xx), shr(128, x)) {\n                        mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                        revert(0x1c, 0x04)\n                    }\n                    x := div(xxRound, b) // Set `x` to scaled `xxRound`.\n                    // If `y` is odd:\n                    if and(y, 1) {\n                        let zx := mul(z, x) // Compute `z * x`.\n                        let zxRound := add(zx, half) // Round to the nearest number.\n                        // If `z * x` overflowed or `zx + half` overflowed:\n                        if or(xor(div(zx, x), z), lt(zxRound, zx)) {\n                            // Revert if `x` is non-zero.\n                            if x {\n                                mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                                revert(0x1c, 0x04)\n                            }\n                        }\n                        z := div(zxRound, b) // Return properly scaled `zxRound`.\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the square root of `x`, rounded down.\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // Let `y = x / 2**r`. We check `y >= 2**(k + 8)`\n            // but shift right by `k` bits to ensure that if `x >= 256`, then `y >= 256`.\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\n            z := shl(shr(1, r), z)\n\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\n\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\n\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\n\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\n            // Then we can estimate `sqrt(y)` using\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\n\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If `x+1` is a perfect square, the Babylonian method cycles between\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, rounded down.\n    /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:\n    /// https://github.com/pcaversaccio/snekmate/blob/main/src/snekmate/utils/math.vy\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // Makeshift lookup table to nudge the approximate log2 result.\n            z := div(shl(div(r, 3), shl(lt(0xf, shr(r, x)), 0xf)), xor(7, mod(r, 3)))\n            // Newton-Raphson's.\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            // Round down.\n            z := sub(z, lt(div(x, mul(z, z)), z))\n        }\n    }\n\n    /// @dev Returns the square root of `x`, denominated in `WAD`, rounded down.\n    function sqrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 18) return sqrt(x * 10 ** 18);\n            z = (1 + sqrt(x)) * 10 ** 9;\n            z = (fullMulDivUnchecked(x, 10 ** 18, z) + z) >> 1;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sub(z, gt(999999999999999999, sub(mulmod(z, z, x), 1))) // Round down.\n        }\n    }\n\n    /// @dev Returns the cube root of `x`, denominated in `WAD`, rounded down.\n    /// Formally verified by xuwinnie:\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\n    function cbrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 36) return cbrt(x * 10 ** 36);\n            z = (1 + cbrt(x)) * 10 ** 12;\n            z = (fullMulDivUnchecked(x, 10 ** 36, z * z) + z + z) / 3;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let p := x\n            for {} 1 {} {\n                if iszero(shr(229, p)) {\n                    if iszero(shr(199, p)) {\n                        p := mul(p, 100000000000000000) // 10 ** 17.\n                        break\n                    }\n                    p := mul(p, 100000000) // 10 ** 8.\n                    break\n                }\n                if iszero(shr(249, p)) { p := mul(p, 100) }\n                break\n            }\n            let t := mulmod(mul(z, z), z, p)\n            z := sub(z, gt(lt(t, shr(1, p)), iszero(t))) // Round down.\n        }\n    }\n\n    /// @dev Returns the factorial of `x`.\n    function factorial(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := 1\n            if iszero(lt(x, 58)) {\n                mstore(0x00, 0xaba0f2a2) // `FactorialOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            for {} x { x := sub(x, 1) } { z := mul(z, x) }\n        }\n    }\n\n    /// @dev Returns the log2 of `x`.\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\n    /// Returns 0 if `x` is zero.\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020504060203020504030106050205030304010505030400000000))\n        }\n    }\n\n    /// @dev Returns the log2 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\n        r = log2(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(r, 1), x))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log10(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, 100000000000000000000000000000000000000)) {\n                x := div(x, 100000000000000000000000000000000000000)\n                r := 38\n            }\n            if iszero(lt(x, 100000000000000000000)) {\n                x := div(x, 100000000000000000000)\n                r := add(r, 20)\n            }\n            if iszero(lt(x, 10000000000)) {\n                x := div(x, 10000000000)\n                r := add(r, 10)\n            }\n            if iszero(lt(x, 100000)) {\n                x := div(x, 100000)\n                r := add(r, 5)\n            }\n            r := add(r, add(gt(x, 9), add(gt(x, 99), add(gt(x, 999), gt(x, 9999)))))\n        }\n    }\n\n    /// @dev Returns the log10 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log10Up(uint256 x) internal pure returns (uint256 r) {\n        r = log10(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(exp(10, r), x))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`.\n    /// Returns 0 if `x` is zero.\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(shr(3, r), lt(0xff, shr(r, x)))\n        }\n    }\n\n    /// @dev Returns the log256 of `x`, rounded up.\n    /// Returns 0 if `x` is zero.\n    function log256Up(uint256 x) internal pure returns (uint256 r) {\n        r = log256(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(shl(3, r), 1), x))\n        }\n    }\n\n    /// @dev Returns the scientific notation format `mantissa * 10 ** exponent` of `x`.\n    /// Useful for compressing prices (e.g. using 25 bit mantissa and 7 bit exponent).\n    function sci(uint256 x) internal pure returns (uint256 mantissa, uint256 exponent) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mantissa := x\n            if mantissa {\n                if iszero(mod(mantissa, 1000000000000000000000000000000000)) {\n                    mantissa := div(mantissa, 1000000000000000000000000000000000)\n                    exponent := 33\n                }\n                if iszero(mod(mantissa, 10000000000000000000)) {\n                    mantissa := div(mantissa, 10000000000000000000)\n                    exponent := add(exponent, 19)\n                }\n                if iszero(mod(mantissa, 1000000000000)) {\n                    mantissa := div(mantissa, 1000000000000)\n                    exponent := add(exponent, 12)\n                }\n                if iszero(mod(mantissa, 1000000)) {\n                    mantissa := div(mantissa, 1000000)\n                    exponent := add(exponent, 6)\n                }\n                if iszero(mod(mantissa, 10000)) {\n                    mantissa := div(mantissa, 10000)\n                    exponent := add(exponent, 4)\n                }\n                if iszero(mod(mantissa, 100)) {\n                    mantissa := div(mantissa, 100)\n                    exponent := add(exponent, 2)\n                }\n                if iszero(mod(mantissa, 10)) {\n                    mantissa := div(mantissa, 10)\n                    exponent := add(exponent, 1)\n                }\n            }\n        }\n    }\n\n    /// @dev Convenience function for packing `x` into a smaller number using `sci`.\n    /// The `mantissa` will be in bits [7..255] (the upper 249 bits).\n    /// The `exponent` will be in bits [0..6] (the lower 7 bits).\n    /// Use `SafeCastLib` to safely ensure that the `packed` number is small\n    /// enough to fit in the desired unsigned integer type:\n    /// ```\n    ///     uint32 packed = SafeCastLib.toUint32(FixedPointMathLib.packSci(777 ether));\n    /// ```\n    function packSci(uint256 x) internal pure returns (uint256 packed) {\n        (x, packed) = sci(x); // Reuse for `mantissa` and `exponent`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            if shr(249, x) {\n                mstore(0x00, 0xce30380c) // `MantissaOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            packed := or(shl(7, x), packed)\n        }\n    }\n\n    /// @dev Convenience function for unpacking a packed number from `packSci`.\n    function unpackSci(uint256 packed) internal pure returns (uint256 unpacked) {\n        unchecked {\n            unpacked = (packed >> 7) * 10 ** (packed & 0x7f);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards zero.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = (x & y) + ((x ^ y) >> 1);\n        }\n    }\n\n    /// @dev Returns the average of `x` and `y`. Rounds towards negative infinity.\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @dev Returns the absolute value of `x`.\n    function abs(int256 x) internal pure returns (uint256 z) {\n        unchecked {\n            z = (uint256(x) + uint256(x >> 255)) ^ uint256(x >> 255);\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, gt(x, y)), sub(y, x)), gt(x, y))\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, sgt(x, y)), sub(y, x)), sgt(x, y))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), lt(y, x)))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), slt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), gt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), gt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), lt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), sgt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), slt(maxValue, z)))\n        }\n    }\n\n    /// @dev Returns greatest common divisor of `x` and `y`.\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { z := x } y {} {\n                let t := y\n                y := mod(z, y)\n                z := t\n            }\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`,\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(uint256 a, uint256 b, uint256 t, uint256 begin, uint256 end)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        unchecked {\n            if (b >= a) return a + fullMulDiv(b - a, t - begin, end - begin);\n            return a - fullMulDiv(a - b, t - begin, end - begin);\n        }\n    }\n\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`.\n    /// with `t` clamped between `begin` and `end` (inclusive).\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\n    /// If `begins == end`, returns `t <= begin ? a : b`.\n    function lerp(int256 a, int256 b, int256 t, int256 begin, int256 end)\n        internal\n        pure\n        returns (int256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        // forgefmt: disable-next-item\n        unchecked {\n            if (b >= a) return int256(uint256(a) + fullMulDiv(uint256(b - a),\n                uint256(t - begin), uint256(end - begin)));\n            return int256(uint256(a) - fullMulDiv(uint256(a - b),\n                uint256(t - begin), uint256(end - begin)));\n        }\n    }\n\n    /// @dev Returns if `x` is an even number. Some people may need this.\n    function isEven(uint256 x) internal pure returns (bool) {\n        return x & uint256(1) == uint256(0);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   RAW NUMBER OPERATIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x + y`, without checking for overflow.\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x - y`, without checking for underflow.\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x * y`, without checking for overflow.\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(x, y)\n        }\n    }\n\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mod(x, y)\n        }\n    }\n\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := smod(x, y)\n        }\n    }\n\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := addmod(x, y, d)\n        }\n    }\n\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mulmod(x, y, d)\n        }\n    }\n}\n"
    },
    "/Users/williamcory/cavalre-contracts/libraries/FloatLib.sol": {
      "id": "/Users/williamcory/cavalre-contracts/libraries/FloatLib.sol",
      "rawCode": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {FixedPointMathLib} from \"solady/src/utils/FixedPointMathLib.sol\";\n\ntype Float is int256;\n\nlibrary FloatLib {\n    using FloatLib for Float;\n    using FixedPointMathLib for uint256;\n    using FixedPointMathLib for int256;\n\n    // Errors\n    error NoSolution();\n\n    //===============\n    //   Constants\n    //===============\n    uint256 constant SIGNIFICANT_DIGITS = 18;\n    uint256 constant NORMALIZED_MANTISSA_MAX = 10 ** SIGNIFICANT_DIGITS - 1;\n    uint256 constant NORMALIZED_MANTISSA_MIN = 10 ** (SIGNIFICANT_DIGITS - 1);\n\n    int256 constant ONE_MANTISSA = int256(10 ** (SIGNIFICANT_DIGITS - 1));\n    int256 constant ONE_EXPONENT = -int256(SIGNIFICANT_DIGITS - 1);\n\n    int256 constant LOG10 = 2302585092994045684;\n\n    uint256 constant MANTISSA_MASK = (uint256(1) << 128) - 1;\n\n    Float constant ZERO = Float.wrap(0);\n    Float constant ONE = Float.wrap((ONE_EXPONENT << 128) | (ONE_MANTISSA & int256(MANTISSA_MASK)));\n    Float constant TWO = Float.wrap((ONE_EXPONENT << 128) | ((2 * ONE_MANTISSA) & int256(MANTISSA_MASK)));\n    Float constant THREE = Float.wrap((ONE_EXPONENT << 128) | ((3 * ONE_MANTISSA) & int256(MANTISSA_MASK)));\n    Float constant FOUR = Float.wrap((ONE_EXPONENT << 128) | ((4 * ONE_MANTISSA) & int256(MANTISSA_MASK)));\n    Float constant FIVE = Float.wrap((ONE_EXPONENT << 128) | ((5 * ONE_MANTISSA) & int256(MANTISSA_MASK)));\n    Float constant SIX = Float.wrap((ONE_EXPONENT << 128) | ((6 * ONE_MANTISSA) & int256(MANTISSA_MASK)));\n    Float constant SEVEN = Float.wrap((ONE_EXPONENT << 128) | ((7 * ONE_MANTISSA) & int256(MANTISSA_MASK)));\n    Float constant EIGHT = Float.wrap((ONE_EXPONENT << 128) | ((8 * ONE_MANTISSA) & int256(MANTISSA_MASK)));\n    Float constant NINE = Float.wrap((ONE_EXPONENT << 128) | ((9 * ONE_MANTISSA) & int256(MANTISSA_MASK)));\n    Float constant TEN = Float.wrap(((ONE_EXPONENT + 1) << 128) | (ONE_MANTISSA & int256(MANTISSA_MASK)));\n\n    //=================\n    //   Conversions\n    //=================\n\n    //-----------\n    //   toInt\n    //-----------\n    function toInt(uint256 a_) internal pure returns (int256) {\n        require(a_ <= uint256(type(int256).max), \"Value out of int256 range\");\n        return int256(a_);\n    }\n\n    function toInt(Float a_, uint256 decimals_) internal pure returns (int256) {\n        (int256 _mantissa, int256 _exponent) = components(a_);\n        int256 _exp = _exponent + toInt(decimals_);\n        if (_exp >= 0) {\n            return _mantissa * int256(10 ** toUInt(_exp));\n        } else {\n            return _mantissa / int256(10 ** toUInt(-_exp));\n        }\n    }\n\n    function toInt(Float a_) internal pure returns (int256) {\n        return toInt(a_, 18);\n    }\n\n    //------------\n    //   toUInt\n    //------------\n    function toUInt(int256 a_) internal pure returns (uint256) {\n        require(a_ >= 0, \"Value must be non-negative\");\n        return uint256(a_);\n    }\n\n    function toUInt(Float a_, uint256 decimals_) internal pure returns (uint256) {\n        (int256 _mantissa, int256 _exponent) = components(a_);\n        require(_mantissa >= 0, \"Value must be non-negative\");\n        int256 _exp = _exponent + toInt(decimals_);\n        if (_exp >= 0) {\n            return uint256(_mantissa) * 10 ** toUInt(_exp);\n        } else {\n            return uint256(_mantissa) / 10 ** toUInt(-_exp);\n        }\n    }\n\n    function toUInt(Float a_) internal pure returns (uint256) {\n        return toUInt(a_, 18);\n    }\n\n    //--------------\n    //   toFloat\n    //--------------\n\n    function toFloat(int256 a_, uint256 decimals_) internal pure returns (Float) {\n        return normalize(a_, -toInt(decimals_));\n    }\n\n    function toFloat(int256 a_) internal pure returns (Float) {\n        return toFloat(a_, 18);\n    }\n\n    function toFloat(uint256 a_, uint256 decimals_) internal pure returns (Float) {\n        require(a_ <= uint256(type(int256).max), \"Value out of int256 range\");\n        return normalize(int256(a_), -toInt(decimals_));\n    }\n\n    function toFloat(uint256 a_) internal pure returns (Float) {\n        return toFloat(a_, 18);\n    }\n\n    //-------------------\n    //   toFloatArray\n    //-------------------\n\n    function toFloatArray(int256[] memory a_, uint256[] memory decimals_) internal pure returns (Float[] memory) {\n        Float[] memory _result = new Float[](a_.length);\n        for (uint256 _i = 0; _i < a_.length; _i++) {\n            _result[_i] = toFloat(a_[_i], decimals_[_i]);\n        }\n        return _result;\n    }\n\n    function toFloatArray(int256[] memory a_) internal pure returns (Float[] memory) {\n        Float[] memory _result = new Float[](a_.length);\n        for (uint256 _i = 0; _i < a_.length; _i++) {\n            _result[_i] = toFloat(a_[_i]);\n        }\n        return _result;\n    }\n\n    //=================\n    //   Comparisons\n    //=================\n    //----------\n    //   isEQ\n    //----------\n    function isEQ(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) == mantissa(_alignedB);\n    }\n\n    function isGT(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) > mantissa(_alignedB);\n    }\n\n    function isGEQ(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) >= mantissa(_alignedB);\n    }\n\n    function isLT(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) < mantissa(_alignedB);\n    }\n\n    function isLEQ(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) <= mantissa(_alignedB);\n    }\n\n    //=====================\n    //   Transformations\n    //=====================\n    function abs(Float a_) internal pure returns (Float) {\n        return from(int256(mantissa(a_).abs()), exponent(a_));\n    }\n\n    function integerPart(Float number_) internal pure returns (Float) {\n        (int256 _mantissa, int256 _exponent) = components(number_);\n        if (_exponent < 0) {\n            int256 _temp = _mantissa;\n            for (uint256 _i; _i < toUInt(-_exponent); _i++) {\n                _temp /= 10;\n                if (_temp == 0) return ZERO;\n            }\n            return from(_temp, 0);\n        } else {\n            return number_;\n        }\n    }\n\n    //-----------\n    //   Shift\n    //-----------\n    function shift(Float a_, int256 i_) internal pure returns (Float) {\n        int256 _mantissa = mantissa(a_);\n        if (i_ == 0 || _mantissa == 0) return a_;\n\n        uint256 _k = i_ > 0 ? uint256(i_) : uint256(-i_);\n\n        int256 _m = _mantissa;\n        int256 _e = exponent(a_) + i_;\n\n        if (i_ > 0) {\n            while (_k >= 16) {\n                _m /= 1e16;\n                _k -= 16;\n            }\n            if (_k >= 8) {\n                _m /= 1e8;\n                _k -= 8;\n            }\n            if (_k >= 4) {\n                _m /= 1e4;\n                _k -= 4;\n            }\n            if (_k >= 2) {\n                _m /= 1e2;\n                _k -= 2;\n            }\n            if (_k >= 1) _m /= 10;\n        } else {\n            require(_k <= SIGNIFICANT_DIGITS, \"shift: |i| too large\");\n            while (_k >= 16) {\n                _m *= 1e16;\n                _k -= 16;\n            }\n            if (_k >= 8) {\n                _m *= 1e8;\n                _k -= 8;\n            }\n            if (_k >= 4) {\n                _m *= 1e4;\n                _k -= 4;\n            }\n            if (_k >= 2) {\n                _m *= 1e2;\n                _k -= 2;\n            }\n            if (_k >= 1) _m *= 10;\n        }\n\n        return from(_m, _e);\n    }\n\n    //---------------\n    //   normalize\n    //---------------\n    function normalize(int256 mantissa_, int256 exponent_) internal pure returns (Float) {\n        if (mantissa_ == 0) return ZERO;\n\n        int256 _m = mantissa_;\n        int256 _e = exponent_;\n\n        uint256 _mag = abs256(_m);\n\n        if (_mag > NORMALIZED_MANTISSA_MAX) {\n            while (_mag > NORMALIZED_MANTISSA_MAX) {\n                _m /= 10;\n                _e += 1;\n                _mag /= 10;\n            }\n            return from(_m, _e);\n        }\n\n        if (_mag < NORMALIZED_MANTISSA_MIN) {\n            while (_mag < NORMALIZED_MANTISSA_MIN) {\n                _m *= 10;\n                _e -= 1;\n                _mag *= 10;\n            }\n            return from(_m, _e);\n        }\n\n        return from(_m, _e);\n    }\n\n    function normalize(Float a_) internal pure returns (Float) {\n        (int256 _mantissa, int256 _exponent) = components(a_);\n        return normalize(_mantissa, _exponent);\n    }\n\n    //-----------\n    //   align\n    //-----------\n    function align(Float a_, Float b_) internal pure returns (Float, Float) {\n        (int256 _aMantissa, int256 _aExponent) = components(a_);\n        (int256 _bMantissa, int256 _bExponent) = components(b_);\n        if (_aMantissa == 0 && _bMantissa == 0) {\n            return (ZERO, ZERO);\n        } else if (_aMantissa == 0) {\n            return (from(0, _bExponent), from(_bMantissa, _bExponent));\n        } else if (_bMantissa == 0) {\n            return (from(_aMantissa, _aExponent), from(0, _aExponent));\n        }\n\n        Float _normA = normalize(a_);\n        Float _normB = normalize(b_);\n        _aMantissa = mantissa(_normA);\n        _aExponent = exponent(_normA);\n        _bMantissa = mantissa(_normB);\n        _bExponent = exponent(_normB);\n\n        int256 _delta = _aExponent - _bExponent;\n        if (_delta >= 0) {\n            if (uint256(_delta) > SIGNIFICANT_DIGITS) {\n                return (_normA, from(0, _aExponent));\n            }\n            return (_normA, shift(_normB, _delta));\n        } else {\n            if (uint256(-_delta) > SIGNIFICANT_DIGITS) {\n                return (from(0, _bExponent), _normB);\n            }\n            return (shift(_normA, -_delta), _normB);\n        }\n    }\n\n    //================\n    //   Arithmetic\n    //================\n    function plus(Float a_, Float b_) internal pure returns (Float) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return normalize(mantissa(_alignedA) + mantissa(_alignedB), exponent(_alignedA));\n    }\n\n    function minus(Float a_) internal pure returns (Float) {\n        return from(-mantissa(a_), exponent(a_));\n    }\n\n    function minus(Float a_, Float b_) internal pure returns (Float) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return normalize(mantissa(_alignedA) - mantissa(_alignedB), exponent(_alignedA));\n    }\n\n    function times(Float a_, Float b_) internal pure returns (Float) {\n        Float _normA = normalize(a_);\n        Float _normB = normalize(b_);\n        return normalize(\n            (mantissa(_normA) * mantissa(_normB)) / int256(10 ** SIGNIFICANT_DIGITS),\n            toInt(SIGNIFICANT_DIGITS) + exponent(_normA) + exponent(_normB)\n        );\n    }\n\n    function divide(Float a_, Float b_) internal pure returns (Float) {\n        Float _normA = normalize(a_);\n        Float _normB = normalize(b_);\n        return normalize(\n            (mantissa(_normA) * int256(10 ** SIGNIFICANT_DIGITS)) / mantissa(_normB),\n            exponent(_normA) - exponent(_normB) - toInt(SIGNIFICANT_DIGITS)\n        );\n    }\n\n    //=======================\n    //   Special functions\n    //=======================\n    function round(Float a_, uint256 digits_) internal pure returns (Float) {\n        if (mantissa(a_) == 0) return ZERO;\n        Float _norm = normalize(a_);\n        int256 _factor = int256(10 ** (SIGNIFICANT_DIGITS - digits_));\n        int256 _scaled = mantissa(_norm) / _factor;\n        int256 _remainder = mantissa(_norm) % _factor;\n        if (_remainder * 2 >= _factor) {\n            _scaled++;\n        }\n        if (_remainder * 2 <= -_factor) {\n            _scaled--;\n        }\n        return from(_scaled * _factor, exponent(_norm));\n    }\n\n    function exp(int256 a_) internal pure returns (Float) {\n        int256 _k = a_ / LOG10;\n        int256 _aprime = a_ - _k * LOG10;\n        return normalize(_aprime.expWad(), _k - 18);\n    }\n\n    function log(Float a_) internal pure returns (int256) {\n        Float _norm = normalize(a_);\n        return int256(mantissa(_norm)).lnWad() + (exponent(_norm) + 18) * LOG10;\n    }\n\n    struct Cubic {\n        Float p;\n        Float q;\n        Float rad;\n        Float u;\n        Float w;\n    }\n\n    function cubicsolve(Float b_, Float c_, Float d_) internal pure returns (Float _x) {\n        Cubic memory _cubic;\n\n        _cubic.p = minus(c_, divide(times(b_, b_), THREE));\n        _cubic.q =\n            minus(plus(d_, divide(times(b_, times(b_, b_)), from(135, -1))), divide(times(b_, c_), from(3e17, -17)));\n        _cubic.rad = plus(\n            divide(times(_cubic.q, _cubic.q), FOUR), divide(times(_cubic.p, times(_cubic.p, _cubic.p)), from(27, 0))\n        );\n        if (isLT(_cubic.rad, ZERO)) revert NoSolution();\n        _cubic.u = minus(exp(log(_cubic.rad) / 2), divide(_cubic.q, TWO));\n        _cubic.w = mantissa(_cubic.u) > 0 ? exp(log(_cubic.u) / 3) : minus(exp(log(minus(_cubic.u)) / 3));\n\n        _x = minus(minus(_cubic.w, divide(_cubic.p, times(THREE, _cubic.w))), divide(b_, THREE));\n    }\n\n    function fullMulDiv(Float a_, Float b_, Float c_) internal pure returns (Float) {\n        int256 _sign = 1;\n        if (mantissa(a_) < 0) {\n            _sign *= -1;\n        }\n        if (mantissa(b_) < 0) {\n            _sign *= -1;\n        }\n        if (mantissa(c_) < 0) {\n            _sign *= -1;\n        }\n        Float _normA = normalize(a_);\n        Float _normB = normalize(b_);\n        Float _normC = normalize(c_);\n        return normalize(\n            _sign * int256(mantissa(_normA).abs().fullMulDiv(mantissa(_normB).abs(), mantissa(_normC).abs())),\n            exponent(_normA) + exponent(_normB) - exponent(_normC)\n        );\n    }\n\n    //====================\n    //   Helper methods\n    //====================\n    function from(int256 mantissa_, int256 exponent_) internal pure returns (Float) {\n        require(mantissa_ >= type(int128).min && mantissa_ <= type(int128).max, \"Mantissa overflow\");\n        require(exponent_ >= type(int128).min && exponent_ <= type(int128).max, \"Exponent overflow\");\n        int256 _packed = (exponent_ << 128) | (mantissa_ & int256(MANTISSA_MASK));\n        return Float.wrap(_packed);\n    }\n\n    function components(Float a_) internal pure returns (int256 _mantissa, int256 _exponent) {\n        int256 _raw = Float.unwrap(a_);\n        _mantissa = int256(int128(_raw));\n        _exponent = int256(int128(_raw >> 128));\n    }\n\n    function mantissa(Float a_) internal pure returns (int256) {\n        return int256(int128(Float.unwrap(a_)));\n    }\n\n    function exponent(Float a_) internal pure returns (int256) {\n        return int256(int128(Float.unwrap(a_) >> 128));\n    }\n\n    function abs256(int256 x_) internal pure returns (uint256) {\n        if (x_ >= 0) return uint256(x_);\n        unchecked {\n            return uint256(~x_) + 1;\n        }\n    }\n}\n",
      "importedIds": [
        "/Users/williamcory/cavalre-contracts/node_modules/solady/src/utils/FixedPointMathLib.sol"
      ],
      "code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.26;\n\nimport {FixedPointMathLib} from \"/Users/williamcory/cavalre-contracts/node_modules/solady/src/utils/FixedPointMathLib.sol\";\n\ntype Float is int256;\n\nlibrary FloatLib {\n    using FloatLib for Float;\n    using FixedPointMathLib for uint256;\n    using FixedPointMathLib for int256;\n\n    // Errors\n    error NoSolution();\n\n    //===============\n    //   Constants\n    //===============\n    uint256 constant SIGNIFICANT_DIGITS = 18;\n    uint256 constant NORMALIZED_MANTISSA_MAX = 10 ** SIGNIFICANT_DIGITS - 1;\n    uint256 constant NORMALIZED_MANTISSA_MIN = 10 ** (SIGNIFICANT_DIGITS - 1);\n\n    int256 constant ONE_MANTISSA = int256(10 ** (SIGNIFICANT_DIGITS - 1));\n    int256 constant ONE_EXPONENT = -int256(SIGNIFICANT_DIGITS - 1);\n\n    int256 constant LOG10 = 2302585092994045684;\n\n    uint256 constant MANTISSA_MASK = (uint256(1) << 128) - 1;\n\n    Float constant ZERO = Float.wrap(0);\n    Float constant ONE = Float.wrap((ONE_EXPONENT << 128) | (ONE_MANTISSA & int256(MANTISSA_MASK)));\n    Float constant TWO = Float.wrap((ONE_EXPONENT << 128) | ((2 * ONE_MANTISSA) & int256(MANTISSA_MASK)));\n    Float constant THREE = Float.wrap((ONE_EXPONENT << 128) | ((3 * ONE_MANTISSA) & int256(MANTISSA_MASK)));\n    Float constant FOUR = Float.wrap((ONE_EXPONENT << 128) | ((4 * ONE_MANTISSA) & int256(MANTISSA_MASK)));\n    Float constant FIVE = Float.wrap((ONE_EXPONENT << 128) | ((5 * ONE_MANTISSA) & int256(MANTISSA_MASK)));\n    Float constant SIX = Float.wrap((ONE_EXPONENT << 128) | ((6 * ONE_MANTISSA) & int256(MANTISSA_MASK)));\n    Float constant SEVEN = Float.wrap((ONE_EXPONENT << 128) | ((7 * ONE_MANTISSA) & int256(MANTISSA_MASK)));\n    Float constant EIGHT = Float.wrap((ONE_EXPONENT << 128) | ((8 * ONE_MANTISSA) & int256(MANTISSA_MASK)));\n    Float constant NINE = Float.wrap((ONE_EXPONENT << 128) | ((9 * ONE_MANTISSA) & int256(MANTISSA_MASK)));\n    Float constant TEN = Float.wrap(((ONE_EXPONENT + 1) << 128) | (ONE_MANTISSA & int256(MANTISSA_MASK)));\n\n    //=================\n    //   Conversions\n    //=================\n\n    //-----------\n    //   toInt\n    //-----------\n    function toInt(uint256 a_) internal pure returns (int256) {\n        require(a_ <= uint256(type(int256).max), \"Value out of int256 range\");\n        return int256(a_);\n    }\n\n    function toInt(Float a_, uint256 decimals_) internal pure returns (int256) {\n        (int256 _mantissa, int256 _exponent) = components(a_);\n        int256 _exp = _exponent + toInt(decimals_);\n        if (_exp >= 0) {\n            return _mantissa * int256(10 ** toUInt(_exp));\n        } else {\n            return _mantissa / int256(10 ** toUInt(-_exp));\n        }\n    }\n\n    function toInt(Float a_) internal pure returns (int256) {\n        return toInt(a_, 18);\n    }\n\n    //------------\n    //   toUInt\n    //------------\n    function toUInt(int256 a_) internal pure returns (uint256) {\n        require(a_ >= 0, \"Value must be non-negative\");\n        return uint256(a_);\n    }\n\n    function toUInt(Float a_, uint256 decimals_) internal pure returns (uint256) {\n        (int256 _mantissa, int256 _exponent) = components(a_);\n        require(_mantissa >= 0, \"Value must be non-negative\");\n        int256 _exp = _exponent + toInt(decimals_);\n        if (_exp >= 0) {\n            return uint256(_mantissa) * 10 ** toUInt(_exp);\n        } else {\n            return uint256(_mantissa) / 10 ** toUInt(-_exp);\n        }\n    }\n\n    function toUInt(Float a_) internal pure returns (uint256) {\n        return toUInt(a_, 18);\n    }\n\n    //--------------\n    //   toFloat\n    //--------------\n\n    function toFloat(int256 a_, uint256 decimals_) internal pure returns (Float) {\n        return normalize(a_, -toInt(decimals_));\n    }\n\n    function toFloat(int256 a_) internal pure returns (Float) {\n        return toFloat(a_, 18);\n    }\n\n    function toFloat(uint256 a_, uint256 decimals_) internal pure returns (Float) {\n        require(a_ <= uint256(type(int256).max), \"Value out of int256 range\");\n        return normalize(int256(a_), -toInt(decimals_));\n    }\n\n    function toFloat(uint256 a_) internal pure returns (Float) {\n        return toFloat(a_, 18);\n    }\n\n    //-------------------\n    //   toFloatArray\n    //-------------------\n\n    function toFloatArray(int256[] memory a_, uint256[] memory decimals_) internal pure returns (Float[] memory) {\n        Float[] memory _result = new Float[](a_.length);\n        for (uint256 _i = 0; _i < a_.length; _i++) {\n            _result[_i] = toFloat(a_[_i], decimals_[_i]);\n        }\n        return _result;\n    }\n\n    function toFloatArray(int256[] memory a_) internal pure returns (Float[] memory) {\n        Float[] memory _result = new Float[](a_.length);\n        for (uint256 _i = 0; _i < a_.length; _i++) {\n            _result[_i] = toFloat(a_[_i]);\n        }\n        return _result;\n    }\n\n    //=================\n    //   Comparisons\n    //=================\n    //----------\n    //   isEQ\n    //----------\n    function isEQ(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) == mantissa(_alignedB);\n    }\n\n    function isGT(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) > mantissa(_alignedB);\n    }\n\n    function isGEQ(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) >= mantissa(_alignedB);\n    }\n\n    function isLT(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) < mantissa(_alignedB);\n    }\n\n    function isLEQ(Float a_, Float b_) internal pure returns (bool) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return mantissa(_alignedA) <= mantissa(_alignedB);\n    }\n\n    //=====================\n    //   Transformations\n    //=====================\n    function abs(Float a_) internal pure returns (Float) {\n        return from(int256(mantissa(a_).abs()), exponent(a_));\n    }\n\n    function integerPart(Float number_) internal pure returns (Float) {\n        (int256 _mantissa, int256 _exponent) = components(number_);\n        if (_exponent < 0) {\n            int256 _temp = _mantissa;\n            for (uint256 _i; _i < toUInt(-_exponent); _i++) {\n                _temp /= 10;\n                if (_temp == 0) return ZERO;\n            }\n            return from(_temp, 0);\n        } else {\n            return number_;\n        }\n    }\n\n    //-----------\n    //   Shift\n    //-----------\n    function shift(Float a_, int256 i_) internal pure returns (Float) {\n        int256 _mantissa = mantissa(a_);\n        if (i_ == 0 || _mantissa == 0) return a_;\n\n        uint256 _k = i_ > 0 ? uint256(i_) : uint256(-i_);\n\n        int256 _m = _mantissa;\n        int256 _e = exponent(a_) + i_;\n\n        if (i_ > 0) {\n            while (_k >= 16) {\n                _m /= 1e16;\n                _k -= 16;\n            }\n            if (_k >= 8) {\n                _m /= 1e8;\n                _k -= 8;\n            }\n            if (_k >= 4) {\n                _m /= 1e4;\n                _k -= 4;\n            }\n            if (_k >= 2) {\n                _m /= 1e2;\n                _k -= 2;\n            }\n            if (_k >= 1) _m /= 10;\n        } else {\n            require(_k <= SIGNIFICANT_DIGITS, \"shift: |i| too large\");\n            while (_k >= 16) {\n                _m *= 1e16;\n                _k -= 16;\n            }\n            if (_k >= 8) {\n                _m *= 1e8;\n                _k -= 8;\n            }\n            if (_k >= 4) {\n                _m *= 1e4;\n                _k -= 4;\n            }\n            if (_k >= 2) {\n                _m *= 1e2;\n                _k -= 2;\n            }\n            if (_k >= 1) _m *= 10;\n        }\n\n        return from(_m, _e);\n    }\n\n    //---------------\n    //   normalize\n    //---------------\n    function normalize(int256 mantissa_, int256 exponent_) internal pure returns (Float) {\n        if (mantissa_ == 0) return ZERO;\n\n        int256 _m = mantissa_;\n        int256 _e = exponent_;\n\n        uint256 _mag = abs256(_m);\n\n        if (_mag > NORMALIZED_MANTISSA_MAX) {\n            while (_mag > NORMALIZED_MANTISSA_MAX) {\n                _m /= 10;\n                _e += 1;\n                _mag /= 10;\n            }\n            return from(_m, _e);\n        }\n\n        if (_mag < NORMALIZED_MANTISSA_MIN) {\n            while (_mag < NORMALIZED_MANTISSA_MIN) {\n                _m *= 10;\n                _e -= 1;\n                _mag *= 10;\n            }\n            return from(_m, _e);\n        }\n\n        return from(_m, _e);\n    }\n\n    function normalize(Float a_) internal pure returns (Float) {\n        (int256 _mantissa, int256 _exponent) = components(a_);\n        return normalize(_mantissa, _exponent);\n    }\n\n    //-----------\n    //   align\n    //-----------\n    function align(Float a_, Float b_) internal pure returns (Float, Float) {\n        (int256 _aMantissa, int256 _aExponent) = components(a_);\n        (int256 _bMantissa, int256 _bExponent) = components(b_);\n        if (_aMantissa == 0 && _bMantissa == 0) {\n            return (ZERO, ZERO);\n        } else if (_aMantissa == 0) {\n            return (from(0, _bExponent), from(_bMantissa, _bExponent));\n        } else if (_bMantissa == 0) {\n            return (from(_aMantissa, _aExponent), from(0, _aExponent));\n        }\n\n        Float _normA = normalize(a_);\n        Float _normB = normalize(b_);\n        _aMantissa = mantissa(_normA);\n        _aExponent = exponent(_normA);\n        _bMantissa = mantissa(_normB);\n        _bExponent = exponent(_normB);\n\n        int256 _delta = _aExponent - _bExponent;\n        if (_delta >= 0) {\n            if (uint256(_delta) > SIGNIFICANT_DIGITS) {\n                return (_normA, from(0, _aExponent));\n            }\n            return (_normA, shift(_normB, _delta));\n        } else {\n            if (uint256(-_delta) > SIGNIFICANT_DIGITS) {\n                return (from(0, _bExponent), _normB);\n            }\n            return (shift(_normA, -_delta), _normB);\n        }\n    }\n\n    //================\n    //   Arithmetic\n    //================\n    function plus(Float a_, Float b_) internal pure returns (Float) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return normalize(mantissa(_alignedA) + mantissa(_alignedB), exponent(_alignedA));\n    }\n\n    function minus(Float a_) internal pure returns (Float) {\n        return from(-mantissa(a_), exponent(a_));\n    }\n\n    function minus(Float a_, Float b_) internal pure returns (Float) {\n        (Float _alignedA, Float _alignedB) = align(a_, b_);\n        return normalize(mantissa(_alignedA) - mantissa(_alignedB), exponent(_alignedA));\n    }\n\n    function times(Float a_, Float b_) internal pure returns (Float) {\n        Float _normA = normalize(a_);\n        Float _normB = normalize(b_);\n        return normalize(\n            (mantissa(_normA) * mantissa(_normB)) / int256(10 ** SIGNIFICANT_DIGITS),\n            toInt(SIGNIFICANT_DIGITS) + exponent(_normA) + exponent(_normB)\n        );\n    }\n\n    function divide(Float a_, Float b_) internal pure returns (Float) {\n        Float _normA = normalize(a_);\n        Float _normB = normalize(b_);\n        return normalize(\n            (mantissa(_normA) * int256(10 ** SIGNIFICANT_DIGITS)) / mantissa(_normB),\n            exponent(_normA) - exponent(_normB) - toInt(SIGNIFICANT_DIGITS)\n        );\n    }\n\n    //=======================\n    //   Special functions\n    //=======================\n    function round(Float a_, uint256 digits_) internal pure returns (Float) {\n        if (mantissa(a_) == 0) return ZERO;\n        Float _norm = normalize(a_);\n        int256 _factor = int256(10 ** (SIGNIFICANT_DIGITS - digits_));\n        int256 _scaled = mantissa(_norm) / _factor;\n        int256 _remainder = mantissa(_norm) % _factor;\n        if (_remainder * 2 >= _factor) {\n            _scaled++;\n        }\n        if (_remainder * 2 <= -_factor) {\n            _scaled--;\n        }\n        return from(_scaled * _factor, exponent(_norm));\n    }\n\n    function exp(int256 a_) internal pure returns (Float) {\n        int256 _k = a_ / LOG10;\n        int256 _aprime = a_ - _k * LOG10;\n        return normalize(_aprime.expWad(), _k - 18);\n    }\n\n    function log(Float a_) internal pure returns (int256) {\n        Float _norm = normalize(a_);\n        return int256(mantissa(_norm)).lnWad() + (exponent(_norm) + 18) * LOG10;\n    }\n\n    struct Cubic {\n        Float p;\n        Float q;\n        Float rad;\n        Float u;\n        Float w;\n    }\n\n    function cubicsolve(Float b_, Float c_, Float d_) internal pure returns (Float _x) {\n        Cubic memory _cubic;\n\n        _cubic.p = minus(c_, divide(times(b_, b_), THREE));\n        _cubic.q =\n            minus(plus(d_, divide(times(b_, times(b_, b_)), from(135, -1))), divide(times(b_, c_), from(3e17, -17)));\n        _cubic.rad = plus(\n            divide(times(_cubic.q, _cubic.q), FOUR), divide(times(_cubic.p, times(_cubic.p, _cubic.p)), from(27, 0))\n        );\n        if (isLT(_cubic.rad, ZERO)) revert NoSolution();\n        _cubic.u = minus(exp(log(_cubic.rad) / 2), divide(_cubic.q, TWO));\n        _cubic.w = mantissa(_cubic.u) > 0 ? exp(log(_cubic.u) / 3) : minus(exp(log(minus(_cubic.u)) / 3));\n\n        _x = minus(minus(_cubic.w, divide(_cubic.p, times(THREE, _cubic.w))), divide(b_, THREE));\n    }\n\n    function fullMulDiv(Float a_, Float b_, Float c_) internal pure returns (Float) {\n        int256 _sign = 1;\n        if (mantissa(a_) < 0) {\n            _sign *= -1;\n        }\n        if (mantissa(b_) < 0) {\n            _sign *= -1;\n        }\n        if (mantissa(c_) < 0) {\n            _sign *= -1;\n        }\n        Float _normA = normalize(a_);\n        Float _normB = normalize(b_);\n        Float _normC = normalize(c_);\n        return normalize(\n            _sign * int256(mantissa(_normA).abs().fullMulDiv(mantissa(_normB).abs(), mantissa(_normC).abs())),\n            exponent(_normA) + exponent(_normB) - exponent(_normC)\n        );\n    }\n\n    //====================\n    //   Helper methods\n    //====================\n    function from(int256 mantissa_, int256 exponent_) internal pure returns (Float) {\n        require(mantissa_ >= type(int128).min && mantissa_ <= type(int128).max, \"Mantissa overflow\");\n        require(exponent_ >= type(int128).min && exponent_ <= type(int128).max, \"Exponent overflow\");\n        int256 _packed = (exponent_ << 128) | (mantissa_ & int256(MANTISSA_MASK));\n        return Float.wrap(_packed);\n    }\n\n    function components(Float a_) internal pure returns (int256 _mantissa, int256 _exponent) {\n        int256 _raw = Float.unwrap(a_);\n        _mantissa = int256(int128(_raw));\n        _exponent = int256(int128(_raw >> 128));\n    }\n\n    function mantissa(Float a_) internal pure returns (int256) {\n        return int256(int128(Float.unwrap(a_)));\n    }\n\n    function exponent(Float a_) internal pure returns (int256) {\n        return int256(int128(Float.unwrap(a_) >> 128));\n    }\n\n    function abs256(int256 x_) internal pure returns (uint256) {\n        if (x_ >= 0) return uint256(x_);\n        unchecked {\n            return uint256(~x_) + 1;\n        }\n    }\n}\n"
    }
  }
}